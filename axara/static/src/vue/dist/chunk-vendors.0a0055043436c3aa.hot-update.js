"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(typeof self !== 'undefined' ? self : this)["webpackHotUpdatefrontend"]("chunk-vendors",{

/***/ "./node_modules/@formkit/core/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@formkit/core/dist/index.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bfs\": function() { return /* binding */ bfs; },\n/* harmony export */   \"clearErrors\": function() { return /* binding */ clearErrors; },\n/* harmony export */   \"compile\": function() { return /* binding */ compile; },\n/* harmony export */   \"createClasses\": function() { return /* binding */ createClasses; },\n/* harmony export */   \"createConfig\": function() { return /* binding */ createConfig$1; },\n/* harmony export */   \"createMessage\": function() { return /* binding */ createMessage; },\n/* harmony export */   \"createNode\": function() { return /* binding */ createNode; },\n/* harmony export */   \"createValue\": function() { return /* binding */ createValue; },\n/* harmony export */   \"deregister\": function() { return /* binding */ deregister; },\n/* harmony export */   \"error\": function() { return /* binding */ error; },\n/* harmony export */   \"errorHandler\": function() { return /* binding */ errorHandler; },\n/* harmony export */   \"generateClassList\": function() { return /* binding */ generateClassList; },\n/* harmony export */   \"getNode\": function() { return /* binding */ getNode$1; },\n/* harmony export */   \"isComponent\": function() { return /* binding */ isComponent; },\n/* harmony export */   \"isConditional\": function() { return /* binding */ isConditional; },\n/* harmony export */   \"isDOM\": function() { return /* binding */ isDOM; },\n/* harmony export */   \"isList\": function() { return /* binding */ isList; },\n/* harmony export */   \"isNode\": function() { return /* binding */ isNode; },\n/* harmony export */   \"isSugar\": function() { return /* binding */ isSugar; },\n/* harmony export */   \"names\": function() { return /* binding */ names; },\n/* harmony export */   \"register\": function() { return /* binding */ register; },\n/* harmony export */   \"reset\": function() { return /* binding */ reset; },\n/* harmony export */   \"resetCount\": function() { return /* binding */ resetCount; },\n/* harmony export */   \"resetRegistry\": function() { return /* binding */ resetRegistry; },\n/* harmony export */   \"setErrors\": function() { return /* binding */ setErrors; },\n/* harmony export */   \"submitForm\": function() { return /* binding */ submitForm; },\n/* harmony export */   \"sugar\": function() { return /* binding */ sugar; },\n/* harmony export */   \"use\": function() { return /* binding */ use; },\n/* harmony export */   \"useIndex\": function() { return /* binding */ useIndex; },\n/* harmony export */   \"valueInserted\": function() { return /* binding */ valueInserted; },\n/* harmony export */   \"valueMoved\": function() { return /* binding */ valueMoved; },\n/* harmony export */   \"valueRemoved\": function() { return /* binding */ valueRemoved; },\n/* harmony export */   \"warn\": function() { return /* binding */ warn; },\n/* harmony export */   \"warningHandler\": function() { return /* binding */ warningHandler; },\n/* harmony export */   \"watchRegistry\": function() { return /* binding */ watchRegistry; }\n/* harmony export */ });\n/* harmony import */ var _formkit_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formkit/utils */ \"./node_modules/@formkit/utils/dist/index.mjs\");\n\n\n/**\n * Creates a new dispatcher that allows the addition/removal of middleware\n * functions, and the ability to dispatch a payload to all middleware.\n * @returns FormKitDispatcher\n */\nfunction createDispatcher() {\n    const middleware = [];\n    let currentIndex = 0;\n    const use = (dispatchable) => middleware.push(dispatchable);\n    const dispatch = (payload) => {\n        const current = middleware[currentIndex];\n        if (typeof current === 'function') {\n            return current(payload, (explicitPayload) => {\n                currentIndex++;\n                return dispatch(explicitPayload === undefined ? payload : explicitPayload);\n            });\n        }\n        currentIndex = 0;\n        return payload;\n    };\n    use.dispatch = dispatch;\n    use.unshift = (dispatchable) => middleware.unshift(dispatchable);\n    use.remove = (dispatchable) => {\n        const index = middleware.indexOf(dispatchable);\n        if (index > -1)\n            middleware.splice(index, 1);\n    };\n    return use;\n}\n\n/**\n * Creates a new event emitter, each node uses one of these to allow it to emit\n * events to local listeners and tree listeners.\n * @returns FormKitEventEmitter\n */\nfunction createEmitter() {\n    const listeners = new Map();\n    const receipts = new Map();\n    let buffer = undefined;\n    const emitter = (node, event) => {\n        if (buffer) {\n            buffer.set(event.name, [node, event]);\n            return;\n        }\n        if (listeners.has(event.name)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            listeners.get(event.name).forEach((wrapper) => {\n                if (event.origin === node || wrapper.modifiers.includes('deep')) {\n                    wrapper.listener(event);\n                }\n            });\n        }\n        if (event.bubble) {\n            node.bubble(event);\n        }\n    };\n    /**\n     * Add an event listener\n     * @param eventName - The name of the event to listen to\n     * @param listener - The callback\n     * @returns string\n     */\n    emitter.on = (eventName, listener) => {\n        const [event, ...modifiers] = eventName.split('.');\n        const receipt = listener.receipt || (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.token)();\n        const wrapper = {\n            modifiers,\n            event,\n            listener,\n            receipt,\n        };\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        listeners.has(event)\n            ? listeners.get(event).push(wrapper)\n            : listeners.set(event, [wrapper]);\n        receipts.has(receipt)\n            ? receipts.get(receipt).push(event)\n            : receipts.set(receipt, [event]);\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        return receipt;\n    };\n    /**\n     * Remove an event listener\n     * @param listenerOrReceipt - Either a receipt or the callback function.\n     */\n    emitter.off = (receipt) => {\n        var _a;\n        if (receipts.has(receipt)) {\n            (_a = receipts.get(receipt)) === null || _a === void 0 ? void 0 : _a.forEach((event) => {\n                const eventListeners = listeners.get(event);\n                if (Array.isArray(eventListeners)) {\n                    listeners.set(event, eventListeners.filter((wrapper) => wrapper.receipt !== receipt));\n                }\n            });\n            receipts.delete(receipt);\n        }\n    };\n    /**\n     * Pause emitting values. Any events emitted while paused will not be emitted\n     * but rather \"stored\" — and whichever events are emitted last will be output.\n     * For example:\n     * pause()\n     * emit('foo', 1)\n     * emit('foo', 2)\n     * emit('bar', 3)\n     * emit('bar', 4)\n     * play()\n     * // would result in\n     * emit('foo', 2)\n     * emit('bar', 4)\n     * Optionally pauses all children as well.\n     * @param node - A node to pause all children on.\n     */\n    emitter.pause = (node) => {\n        if (!buffer)\n            buffer = new Map();\n        if (node) {\n            node.walk((child) => child._e.pause());\n        }\n    };\n    /**\n     * Release the current event buffer.\n     * @param node - A node to unpause all children on.\n     */\n    emitter.play = (node) => {\n        if (!buffer)\n            return;\n        const events = buffer;\n        buffer = undefined;\n        events.forEach(([node, event]) => emitter(node, event));\n        if (node) {\n            node.walk((child) => child._e.play());\n        }\n    };\n    return emitter;\n}\n/**\n * Emit an event from this node.\n * @param node - The node that is emitting\n * @param context - The context of that node\n * @param name - The name of the event\n * @param payload - The payload to emit\n * @returns FormKitNode\n */\nfunction emit$1(node, context, name, payload, // eslint-disable-line @typescript-eslint/explicit-module-boundary-types,\nbubble = true) {\n    context._e(node, {\n        payload,\n        name,\n        bubble,\n        origin: node,\n    });\n    return node;\n}\n/**\n * Send an event from the given node up it's ancestor tree.\n * @param node -\n * @param _context -\n * @param event -\n */\nfunction bubble(node, _context, event) {\n    if (isNode(node.parent)) {\n        node.parent._e(node.parent, event);\n    }\n    return node;\n}\n/**\n * Adds an event listener to the node for a specific event. The event name is a\n * simple string matching the name of the event to listen to. It can optionally\n * include modifiers like eventName.deep\n * @param node -\n * @param context -\n * @param name -\n * @param listener -\n * @returns FormKitNode\n */\nfunction on(_node, context, name, listener) {\n    return context._e.on(name, listener);\n}\n/**\n * Removes an event listener from a node by the returned receipt from .on().\n * @param node - The node to remote the listener from\n * @param context - The context to remove\n * @param receipt - The receipt returned by .on()\n * @returns FormKitNode\n */\nfunction off(node, context, receipt) {\n    context._e.off(receipt);\n    return node;\n}\n\n/**\n * FormKit's global error handler.\n * @public\n */\nconst errorHandler = createDispatcher();\n/**\n * The default error handler just sets the error as the message.\n */\nerrorHandler((error, next) => {\n    if (!error.message)\n        error.message = String(`E${error.code}`);\n    return next(error);\n});\n/**\n * FormKit's global warning handler.\n * @public\n */\nconst warningHandler = createDispatcher();\nwarningHandler((warning, next) => {\n    if (!warning.message)\n        warning.message = String(`W${warning.code}`);\n    const result = next(warning);\n    if (console && typeof console.warn === 'function')\n        console.warn(result.message);\n    return result;\n});\n/**\n * Globally emits a warning.\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n * @public\n */\nfunction warn(code, data = {}) {\n    warningHandler.dispatch({ code, data });\n}\n/**\n * Emits an error, generally should result in an exception.\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n * @public\n */\nfunction error(code, data = {}) {\n    throw Error(errorHandler.dispatch({ code, data }).message);\n}\n\n/**\n * Creates a new FormKitMessage object.\n * @param conf - The message configuration\n * @returns FormKitMessage\n * @public\n */\nfunction createMessage(conf, node) {\n    const m = {\n        blocking: false,\n        key: (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.token)(),\n        meta: {},\n        type: 'state',\n        visible: true,\n        ...conf,\n    };\n    if (node && m.value && m.meta.localize !== false) {\n        m.value = node.t(m);\n        m.meta.locale = node.config.locale;\n    }\n    return m;\n}\n/**\n * The available traps on the node's store.\n */\nconst storeTraps = {\n    apply: applyMessages,\n    set: setMessage,\n    remove: removeMessage,\n    filter: filterMessages,\n    reduce: reduceMessages,\n    release: releaseBuffer,\n    touch: touchMessages,\n};\n/**\n * Creates a new FormKit message store.\n * @returns FormKitStore\n */\nfunction createStore(_buffer = false) {\n    const messages = {};\n    let node;\n    let buffer = _buffer;\n    let _b = [];\n    const _m = new Map();\n    let _r = undefined;\n    const store = new Proxy(messages, {\n        get(...args) {\n            const [_target, property] = args;\n            if (property === 'buffer')\n                return buffer;\n            if (property === '_b')\n                return _b;\n            if (property === '_m')\n                return _m;\n            if (property === '_r')\n                return _r;\n            if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(storeTraps, property)) {\n                return storeTraps[property].bind(null, messages, store, node);\n            }\n            return Reflect.get(...args);\n        },\n        set(_t, prop, value) {\n            if (prop === '_n') {\n                node = value;\n                if (_r === '__n')\n                    releaseMissed(node, store);\n                return true;\n            }\n            else if (prop === '_b') {\n                _b = value;\n                return true;\n            }\n            else if (prop === 'buffer') {\n                buffer = value;\n                return true;\n            }\n            else if (prop === '_r') {\n                _r = value;\n                return true;\n            }\n            error(101, node);\n            return false;\n        },\n    });\n    return store;\n}\n/**\n * Adds a new value to a FormKit message bag.\n * @param store - The store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param message - The message object\n * @returns FormKitStore\n */\nfunction setMessage(messageStore, store, node, message) {\n    if (store.buffer) {\n        store._b.push([[message]]);\n        return store;\n    }\n    if (messageStore[message.key] !== message) {\n        if (typeof message.value === 'string' && message.meta.localize !== false) {\n            // Expose the value to translation\n            const previous = message.value;\n            message.value = node.t(message);\n            if (message.value !== previous) {\n                message.meta.locale = node.props.locale;\n            }\n        }\n        const e = `message-${(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(messageStore, message.key) ? 'updated' : 'added'}`;\n        messageStore[message.key] = Object.freeze(node.hook.message.dispatch(message));\n        node.emit(e, message);\n    }\n    return store;\n}\n/**\n * Run through each message in the store, and ensure it has been translated\n * to the proper language. This most frequently happens after a locale change.\n */\nfunction touchMessages(messageStore, store) {\n    for (const key in messageStore) {\n        const message = { ...messageStore[key] };\n        store.set(message);\n    }\n}\n/**\n * Remove a message from the store.\n * @param store - The store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param key - The message key\n * @returns FormKitStore\n */\nfunction removeMessage(messageStore, store, node, key) {\n    if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(messageStore, key)) {\n        const message = messageStore[key];\n        delete messageStore[key];\n        node.emit('message-removed', message);\n    }\n    if (store.buffer === true) {\n        store._b = store._b.filter((buffered) => {\n            buffered[0] = buffered[0].filter((m) => m.key !== key);\n            return buffered[1] || buffered[0].length;\n        });\n    }\n    return store;\n}\n/**\n * Iterates over all messages removing those that are no longer wanted.\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n * @param callback - A callback accepting a message and returning a boolean\n * @param type - Pre filtered by a given message type\n */\nfunction filterMessages(messageStore, store, node, callback, type) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        if ((!type || message.type === type) && !callback(message)) {\n            removeMessage(messageStore, store, node, key);\n        }\n    }\n}\n/**\n * Reduce the message store to some other generic value.\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param _node - The node owner of this store\n * @param reducer - The callback that performs the reduction\n * @param accumulator - The initial value\n * @returns\n */\nfunction reduceMessages(messageStore, _store, _node, reducer, accumulator) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        accumulator = reducer(accumulator, message);\n    }\n    return accumulator;\n}\n/**\n *\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param node - The node owner of this store\n * @param messages - An array of FormKitMessages to apply to this input, or an object of messages to apply to children.\n */\nfunction applyMessages(_messageStore, store, node, messages, clear) {\n    if (Array.isArray(messages)) {\n        if (store.buffer) {\n            store._b.push([messages, clear]);\n            return;\n        }\n        // In this case we are applying messages to this node’s store.\n        const applied = new Set(messages.map((message) => {\n            store.set(message);\n            return message.key;\n        }));\n        // Remove any messages that were not part of the initial apply:\n        if (typeof clear === 'string') {\n            store.filter((message) => message.type !== clear || applied.has(message.key));\n        }\n        else if (typeof clear === 'function') {\n            store.filter((message) => !clear(message) || applied.has(message.key));\n        }\n    }\n    else {\n        for (const address in messages) {\n            const child = node.at(address);\n            if (child) {\n                child.store.apply(messages[address], clear);\n            }\n            else {\n                missed(node, store, address, messages[address], clear);\n            }\n        }\n    }\n}\n/**\n * Creates an array of message arrays from strings.\n * @param errors - Arrays or objects of form errors or input errors\n * @returns\n * @internal\n */\nfunction createMessages(node, ...errors) {\n    const sourceKey = `${node.name}-set`;\n    const make = (error) => createMessage({\n        key: (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.slugify)(error),\n        type: 'error',\n        value: error,\n        meta: { source: sourceKey, autoClear: true },\n    });\n    return errors\n        .filter((m) => !!m)\n        .map((errorSet) => {\n        if (typeof errorSet === 'string')\n            errorSet = [errorSet];\n        if (Array.isArray(errorSet)) {\n            return errorSet.map((error) => make(error));\n        }\n        else {\n            const errors = {};\n            for (const key in errorSet) {\n                if (Array.isArray(errorSet[key])) {\n                    errors[key] = errorSet[key].map((error) => make(error));\n                }\n                else {\n                    errors[key] = [make(errorSet[key])];\n                }\n            }\n            return errors;\n        }\n    });\n}\n/**\n *\n * @param store - The store to apply this missed applications.\n * @param address - The address that was missed (a node path that didn't yet exist)\n * @param messages - The messages that should have been applied.\n * @param clear - The clearing function (if any)\n */\nfunction missed(node, store, address, messages, clear) {\n    var _a;\n    const misses = store._m;\n    if (!misses.has(address))\n        misses.set(address, []);\n    // The created receipt\n    if (!store._r)\n        store._r = releaseMissed(node, store);\n    (_a = misses.get(address)) === null || _a === void 0 ? void 0 : _a.push([messages, clear]);\n}\n/**\n * Releases messages that were applied to a child via parent, but the child did\n * not exist. Once the child does exist, the created event for that child will\n * bubble to this point, and any stored applications will be applied serially.\n * @param store - The store object.\n * @returns\n */\nfunction releaseMissed(node, store) {\n    return node.on('child.deep', ({ payload: child }) => {\n        store._m.forEach((misses, address) => {\n            if (node.at(address) === child) {\n                misses.forEach(([messages, clear]) => {\n                    child.store.apply(messages, clear);\n                });\n                store._m.delete(address);\n            }\n        });\n        // If all the stored misses were applied, remove the listener.\n        if (store._m.size === 0 && store._r) {\n            node.off(store._r);\n            store._r = undefined;\n        }\n    });\n}\n/**\n * Iterates over all buffered messages and applies them in sequence.\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n */\nfunction releaseBuffer(_messageStore, store) {\n    store.buffer = false;\n    store._b.forEach(([messages, clear]) => store.apply(messages, clear));\n    store._b = [];\n}\n\n/**\n * Creates a new ledger for use on a single node's context.\n * @returns\n */\nfunction createLedger() {\n    const ledger = {};\n    let n;\n    return {\n        count: (...args) => createCounter(n, ledger, ...args),\n        init(node) {\n            n = node;\n            node.on('message-added.deep', add(ledger, 1));\n            node.on('message-removed.deep', add(ledger, -1));\n        },\n        merge: (child) => merge(n, ledger, child),\n        settled(counterName) {\n            return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(ledger, counterName)\n                ? ledger[counterName].promise\n                : Promise.resolve();\n        },\n        unmerge: (child) => merge(n, ledger, child, true),\n        value(counterName) {\n            return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(ledger, counterName) ? ledger[counterName].count : 0;\n        },\n    };\n}\n/**\n * Creates a new counter object in the counting ledger.\n * @param ledger - The actual ledger storage object\n * @param counterName - The name of the counter, can be arbitrary\n * @param condition - The condition function (or string) that filters messages\n * @param initialValue - The initial counter value\n * @returns\n */\nfunction createCounter(node, ledger, counterName, condition, increment = 0) {\n    condition = parseCondition(condition || counterName);\n    if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(ledger, counterName)) {\n        const counter = {\n            condition,\n            count: 0,\n            name: counterName,\n            node,\n            promise: Promise.resolve(),\n            resolve: () => { }, // eslint-disable-line @typescript-eslint/no-empty-function\n        };\n        ledger[counterName] = counter;\n        increment = node.store.reduce((sum, m) => sum + counter.condition(m) * 1, increment);\n        node.each((child) => {\n            child.ledger.count(counter.name, counter.condition);\n            increment += child.ledger.value(counter.name);\n        });\n    }\n    return count(ledger[counterName], increment).promise;\n}\n/**\n * We parse the condition to allow flexibility in how counters are specified.\n * @param condition - The condition that, if true, allows a message to change a counter's value\n * @returns\n */\nfunction parseCondition(condition) {\n    if (typeof condition === 'function') {\n        return condition;\n    }\n    return (m) => m.type === condition;\n}\n/**\n * Perform a counting action on the a given counter object of the ledger.\n * @param counter - A counter object\n * @param increment - The amount by which we are changing the count value\n * @returns\n */\nfunction count(counter, increment) {\n    const initial = counter.count;\n    const post = counter.count + increment;\n    counter.count = post;\n    if (initial === 0 && post !== 0) {\n        counter.node.emit(`unsettled:${counter.name}`, counter.count, false);\n        counter.promise = new Promise((r) => (counter.resolve = r));\n    }\n    else if (initial !== 0 && post === 0) {\n        counter.node.emit(`settled:${counter.name}`, counter.count, false);\n        counter.resolve();\n    }\n    counter.node.emit(`count:${counter.name}`, counter.count, false);\n    return counter;\n}\n/**\n * Returns a function to be used as an event listener for message events.\n * @param ledger - A ledger to operate on\n * @param delta - The amount to add or subtract\n * @returns\n */\nfunction add(ledger, delta) {\n    return (e) => {\n        for (const name in ledger) {\n            const counter = ledger[name];\n            if (counter.condition(e.payload)) {\n                count(counter, delta);\n            }\n        }\n    };\n}\n/**\n * Given a child node, add the parent node's counters to the child and then\n * rectify the upstream ledger counts. Generally used when attaching a child\n * to an already counted tree.\n * @param parent - The parent that is \"receiving\" the child\n * @param ledger - The ledger object\n * @param child - The child (can be a subtree) that is being attached\n */\nfunction merge(parent, ledger, child, remove = false) {\n    for (const key in ledger) {\n        const condition = ledger[key].condition;\n        if (!remove)\n            child.ledger.count(key, condition);\n        const increment = child.ledger.value(key) * (remove ? -1 : 1);\n        if (!parent)\n            continue;\n        do {\n            parent.ledger.count(key, condition, increment);\n            parent = parent.parent;\n        } while (parent);\n    }\n}\n\n/**\n * A global registry of nodes by their alias or name (if root).\n */\nconst registry = new Map();\nconst reflected = new Map();\n/**\n * An event emitter for registered/set/unset nodes\n */\nconst emit = createEmitter();\n/**\n * Receipts of listeners.\n */\nconst receipts = [];\n/**\n * Registers a node to the registry _if_ the node is a root node, _or_ if the\n * node has an explicit node.props.alias. If these two things are not true\n * then no node is registered (idempotent).\n *\n * @param node - A node to register\n * @public\n */\nfunction register(node) {\n    if (node.props.id) {\n        registry.set(node.props.id, node);\n        reflected.set(node, node.props.id);\n        emit(node, {\n            payload: node,\n            name: node.props.id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Deregister a node from the registry.\n * @param node - A node to remove\n * @public\n */\nfunction deregister(node) {\n    if (reflected.has(node)) {\n        const id = reflected.get(node); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        reflected.delete(node);\n        registry.delete(id);\n        emit(node, {\n            payload: null,\n            name: id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Get a node by a particular id.\n * @param node - Get a node by a given id\n * @public\n */\nfunction getNode$1(id) {\n    return registry.get(id);\n}\n/**\n * Reset the entire registry.\n * @public\n */\nfunction resetRegistry() {\n    registry.forEach((node) => {\n        deregister(node);\n    });\n    receipts.forEach((receipt) => emit.off(receipt));\n}\n/**\n *\n * @param id - An id to watch\n * @param callback - A callback to notify when the node is set or removed.\n * @public\n */\nfunction watchRegistry(id, callback) {\n    // register a listener\n    receipts.push(emit.on(id, callback));\n}\n\n/**\n * Applies a given config change to the node.\n * @param node - The node to check for config change\n * @param prop - Checks if this property exists in the local config or props\n * @param value - The value to set\n * @internal\n */\nfunction configChange(node, prop, value) {\n    // When we return false, node.walk will not continue into that child.\n    let usingFallback = true;\n    !(prop in node.config._t)\n        ? node.emit(`config:${prop}`, value, false)\n        : (usingFallback = false);\n    if (!(prop in node.props)) {\n        node.emit('prop', { prop, value });\n        node.emit(`prop:${prop}`, value);\n    }\n    return usingFallback;\n}\n/**\n * Creates a new instance of a global configuration option. This object is\n * essentially just a FormKitOption object, but it can be used as the root for\n * FormKitConfig's proxy and retain event \"emitting\".\n *\n * @param options - FormKit node options to be used globally.\n * @public\n */\nfunction createConfig$1(options = {}) {\n    const nodes = new Set();\n    const target = {\n        ...options,\n        ...{\n            _add: (node) => nodes.add(node),\n            _rm: (node) => node.remove(node),\n        },\n    };\n    const rootConfig = new Proxy(target, {\n        set(t, prop, value, r) {\n            if (typeof prop === 'string') {\n                nodes.forEach((node) => configChange(node, prop, value));\n            }\n            return Reflect.set(t, prop, value, r);\n        },\n    });\n    return rootConfig;\n}\n\n/**\n * Submits a FormKit form programmatically.\n * @param id - The id of the form\n * @public\n */\nfunction submitForm(id) {\n    const formElement = document.getElementById(id);\n    if (formElement instanceof HTMLFormElement) {\n        const event = new Event('submit', { cancelable: true, bubbles: true });\n        formElement.dispatchEvent(event);\n        return;\n    }\n    warn(151, id);\n}\n\n/**\n * Clear all state and error messages.\n */\nfunction clearState(node) {\n    const clear = (n) => {\n        for (const key in n.store) {\n            const message = n.store[key];\n            if (message.type === 'error' ||\n                (message.type === 'ui' && key === 'incomplete')) {\n                n.store.remove(key);\n            }\n            else if (message.type === 'state') {\n                n.store.set({ ...message, value: false });\n            }\n        }\n    };\n    clear(node);\n    node.walk(clear);\n}\n/**\n * Resets an input to it’s \"initial\" value — if the input is a group or list it\n * resets all the children as well.\n * @param id - The id of an input to reset\n * @returns\n * @public\n */\nfunction reset(id, resetTo) {\n    const node = typeof id === 'string' ? getNode$1(id) : id;\n    if (node) {\n        const initial = (n) => (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.cloneAny)(n.props.initial) ||\n            (n.type === 'group' ? {} : n.type === 'list' ? [] : undefined);\n        // pause all events in this tree.\n        node._e.pause(node);\n        // Set it back to basics\n        node.input((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.cloneAny)(resetTo) || initial(node), false);\n        // Set children back to basics in case they were additive (had their own value for example)\n        node.walk((child) => child.input(initial(child), false));\n        // Finally we need to lay any values back on top (if it is a group/list) since group values\n        // take precedence over child values.\n        const finalInit = initial(node);\n        node.input(typeof finalInit === 'object'\n            ? (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.cloneAny)(resetTo) || (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.init)(finalInit)\n            : finalInit, false);\n        // release the events.\n        node._e.play(node);\n        clearState(node);\n        node.emit('reset', node);\n        return node;\n    }\n    warn(152, id);\n    return;\n}\n\n/**\n * Default configuration options.\n */\nconst defaultConfig = {\n    delimiter: '.',\n    delay: 0,\n    locale: 'en',\n    rootClasses: (key) => ({ [`formkit-${(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.kebab)(key)}`]: true }),\n};\n/**\n * If a node’s name is set to useIndex, it replaces the node’s name with the\n * index of the node relative to its parent’s children.\n * @public\n */\nconst useIndex = Symbol('index');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * removed.\n * @public\n */\nconst valueRemoved = Symbol('removed');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * moved.\n * @public\n */\nconst valueMoved = Symbol('moved');\n/**\n * When creating a new node and having its value injected directly at a specific\n * location.\n * @public\n */\nconst valueInserted = Symbol('inserted');\n/**\n * A simple type guard to determine if the context being evaluated is a list\n * type.\n * @param arg -\n * @returns arg is FormKitListContext\n * @public\n */\nfunction isList(arg) {\n    return arg.type === 'list' && Array.isArray(arg._value);\n}\n/**\n * Determine if a given object is a node\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isNode(node) {\n    return node && typeof node === 'object' && node.__FKNode__ === true;\n}\n/**\n * The setter you are trying to access is invalid.\n */\nconst invalidSetter = (node, _context, property) => {\n    error(102, [node, property]);\n};\nconst traps = {\n    _c: trap(getContext, invalidSetter, false),\n    add: trap(addChild),\n    addProps: trap(addProps),\n    address: trap(getAddress, invalidSetter, false),\n    at: trap(getNode),\n    bubble: trap(bubble),\n    clearErrors: trap(clearErrors$1),\n    calm: trap(calm),\n    config: trap(false),\n    define: trap(define),\n    disturb: trap(disturb),\n    destroy: trap(destroy),\n    hydrate: trap(hydrate),\n    index: trap(getIndex, setIndex, false),\n    input: trap(input),\n    each: trap(eachChild),\n    emit: trap(emit$1),\n    find: trap(find),\n    on: trap(on),\n    off: trap(off),\n    parent: trap(false, setParent),\n    plugins: trap(false),\n    remove: trap(removeChild),\n    root: trap(getRoot, invalidSetter, false),\n    reset: trap(resetValue),\n    resetConfig: trap(resetConfig),\n    setErrors: trap(setErrors$1),\n    submit: trap(submit),\n    t: trap(text),\n    use: trap(use),\n    name: trap(getName, false, false),\n    walk: trap(walkTree),\n};\n/**\n * These are all the available \"traps\" for a given node. You can think of these\n * a little bit like methods, but they are really Proxy interceptors.\n */\nfunction createTraps() {\n    return new Map(Object.entries(traps));\n}\n/**\n * Creates a getter/setter trap and curries the context/node pair\n * @param getter - The getter function\n * @param setter - The setter function\n * @param curryGetter - Indicates if the getter should be curried or not\n * @returns\n */\nfunction trap(getter, setter, curryGetter = true) {\n    return {\n        get: getter\n            ? (node, context) => curryGetter\n                ? (...args) => getter(node, context, ...args)\n                : getter(node, context)\n            : false,\n        set: setter !== undefined ? setter : invalidSetter.bind(null),\n    };\n}\n/**\n * Create all of the node's hook dispatchers.\n */\nfunction createHooks() {\n    const hooks = new Map();\n    return new Proxy(hooks, {\n        get(_, property) {\n            if (!hooks.has(property)) {\n                hooks.set(property, createDispatcher());\n            }\n            return hooks.get(property);\n        },\n    });\n}\n/**\n * This is a simple integer counter of every createName() where the name needs\n * to be generated.\n */\nlet nameCount = 0;\n/**\n * This is a simple integer counter of every default id created.\n */\nlet idCount = 0;\n/**\n * Reports the global number of node registrations, useful for deterministic\n * node naming.\n * @public\n */\nfunction resetCount() {\n    nameCount = 0;\n    idCount = 0;\n}\n/**\n * Create a name based dictionary of all children in an array.\n * @param children -\n * @public\n */\nfunction names(children) {\n    return children.reduce((named, child) => Object.assign(named, { [child.name]: child }), {});\n}\n/**\n * This node is responsible for deterministically generating an id for this\n * node. This cannot just be a random id, it _must_ be deterministic to ensure\n * re-hydration of the form (like post-SSR) produces the same names/ids.\n *\n * @param options -\n * @returns string\n */\nfunction createName(options) {\n    var _a, _b;\n    if (((_a = options.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return useIndex;\n    return options.name || `${((_b = options.props) === null || _b === void 0 ? void 0 : _b.type) || 'input'}_${++nameCount}`;\n}\n/**\n * Creates the initial value for a node based on the options passed in and the\n * type of the input.\n * @param options -\n * @param type -\n * @returns\n * @internal\n */\nfunction createValue(options) {\n    if (options.type === 'group') {\n        return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.init)(options.value &&\n            typeof options.value === 'object' &&\n            !Array.isArray(options.value)\n            ? options.value\n            : {});\n    }\n    else if (options.type === 'list') {\n        return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.init)(Array.isArray(options.value) ? options.value : []);\n    }\n    return options.value === null ? '' : options.value;\n}\n/**\n * Sets the internal value of the node.\n * @param node -\n * @param context -\n * @param value -\n * @returns T\n */\nfunction input(node, context, value, async = true) {\n    context._value = validateInput(node, node.hook.input.dispatch(value));\n    node.emit('input', context._value);\n    if (context.isSettled)\n        node.disturb();\n    if (async) {\n        if (context._tmo)\n            clearTimeout(context._tmo);\n        context._tmo = setTimeout(commit, node.props.delay, node, context);\n    }\n    else {\n        commit(node, context);\n    }\n    return context.settled;\n}\n/**\n * Validate that the current input is allowed.\n * @param type - The type of node (input, list, group)\n * @param value - The value that is being set\n */\nfunction validateInput(node, value) {\n    switch (node.type) {\n        // Inputs are allowed to have any type\n        case 'input':\n            break;\n        case 'group':\n            if (!value || typeof value !== 'object')\n                error(107, [node, value]);\n            break;\n        case 'list':\n            if (!Array.isArray(value))\n                error(108, [node, value]);\n            break;\n    }\n    return value;\n}\n/**\n * Commits the working value to the node graph as the value of this node.\n * @param node -\n * @param context -\n * @param calm -\n * @param hydrate -\n */\nfunction commit(node, context, calm = true, hydrate = true) {\n    context._value = context.value = node.hook.commit.dispatch(context._value);\n    if (node.type !== 'input' && hydrate)\n        node.hydrate();\n    node.emit('commit', context.value);\n    if (calm)\n        node.calm();\n}\n/**\n * Perform a modification to a single element of a parent aggregate value. This\n * is only performed on the pre-committed value (_value), although typically\n * the value and _value are both linked in memory.\n * @param context -\n * @param name -\n * @param value -\n */\nfunction partial(context, { name, value, from }) {\n    if (Object.isFrozen(context._value))\n        return;\n    if (isList(context)) {\n        const insert = value === valueRemoved\n            ? []\n            : value === valueMoved && typeof from === 'number'\n                ? context._value.splice(from, 1)\n                : [value];\n        context._value.splice(name, value === valueMoved || from === valueInserted ? 0 : 1, ...insert);\n        return;\n    }\n    // In this case we know for sure we're dealing with a group, TS doesn't\n    // know that however, so we use some unpleasant casting here\n    if (value !== valueRemoved) {\n        context._value[name] = value;\n    }\n    else {\n        delete context._value[name];\n    }\n}\n/**\n * Pass values down to children by calling hydrate on them.\n * @param parent -\n * @param child -\n */\nfunction hydrate(node, context) {\n    const _value = context._value;\n    context.children.forEach((child) => {\n        if (typeof _value !== 'object')\n            return;\n        // if (has(context._value as FormKitGroupValue, child.name)) {\n        if (child.name in _value) {\n            // In this case, the parent has a value to give to the child, so we\n            // perform a down-tree synchronous input which will cascade values down\n            // and then ultimately back up.\n            const childValue = child.type !== 'input' ||\n                (_value[child.name] && typeof _value[child.name] === 'object')\n                ? (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.init)(_value[child.name])\n                : _value[child.name];\n            child.input(childValue, false);\n        }\n        else {\n            if (node.type !== 'list' || typeof child.name === 'number') {\n                // In this case, the parent’s values have no knowledge of the child\n                // value — this typically occurs on the commit at the end of addChild()\n                // we need to create a value reservation for this node’s name. This is\n                // especially important when dealing with lists where index matters.\n                partial(context, { name: child.name, value: child.value });\n            }\n            if (!_value.__init) {\n                // In this case, someone has explicitly set the value to an empty object\n                // with node.input({}) so we do not define the __init property:\n                if (child.type === 'group')\n                    child.input({}, false);\n                else if (child.type === 'list')\n                    child.input([], false);\n                else\n                    child.input(undefined, false);\n            }\n        }\n    });\n    return node;\n}\n/**\n * Disturbs the state of a node from settled to unsettled — creating appropriate\n * promises and resolutions.\n * @param node -\n * @param context -\n */\nfunction disturb(node, context) {\n    var _a;\n    if (context._d <= 0) {\n        context.isSettled = false;\n        node.emit('settled', false, false);\n        context.settled = new Promise((resolve) => {\n            context._resolve = resolve;\n        });\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.disturb();\n    }\n    context._d++;\n    return node;\n}\n/**\n * Calms the given node's disturbed state by one.\n * @param node -\n * @param context -\n */\nfunction calm(node, context, value) {\n    var _a;\n    if (value !== undefined && node.type !== 'input') {\n        partial(context, value);\n        // Commit the value up, but do not hydrate back down\n        return commit(node, context, true, false);\n    }\n    if (context._d > 0)\n        context._d--;\n    if (context._d === 0) {\n        context.isSettled = true;\n        node.emit('settled', true, false);\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.calm({ name: node.name, value: context.value });\n        if (context._resolve)\n            context._resolve(context.value);\n    }\n}\n/**\n * This node is being removed and needs to be cleaned up.\n * @param node - The node to shut down\n * @param context - The context to clean up\n */\nfunction destroy(node, context) {\n    node.emit('destroying', node);\n    // flush all messages out\n    node.store.filter(() => false);\n    if (node.parent) {\n        node.parent.remove(node);\n    }\n    deregister(node);\n    context._value = context.value = undefined;\n    node.emit('destroyed', node);\n}\n/**\n * Defines the current input type concretely.\n * @param definition - The definition of the current input type.\n */\nfunction define(node, context, definition) {\n    // Assign the type\n    context.type = definition.type;\n    // Assign the definition\n    context.props.definition = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.clone)(definition);\n    // Ensure the type is seeded with the `__init` value.\n    context.value = context._value = createValue({\n        type: node.type,\n        value: context.value,\n    });\n    // Apply any input features before resetting the props.\n    if (definition.features) {\n        definition.features.forEach((feature) => feature(node));\n    }\n    // Its possible that input-defined \"props\" have ended up in the context attrs\n    // these should be moved back out of the attrs object.\n    if (definition.props) {\n        node.addProps(definition.props);\n    }\n    node.emit('defined', definition);\n}\n/**\n * Adds props to a given node by stripping them out of the node.props.attrs and\n * then adding them to the nodes.\n *\n * @param node - The node to add props to\n * @param context - The internal context object\n * @param props - An array of prop strings (in camelCase!)\n */\nfunction addProps(node, context, props) {\n    var _a;\n    if (node.props.attrs) {\n        const attrs = { ...node.props.attrs };\n        // Temporarily disable prop emits\n        node.props._emit = false;\n        for (const attr in attrs) {\n            const camelName = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.camel)(attr);\n            if (props.includes(camelName)) {\n                node.props[camelName] = attrs[attr];\n                delete attrs[attr];\n            }\n        }\n        const initial = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.cloneAny)(context._value);\n        node.props.initial =\n            node.type !== 'input' ? (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.init)(initial) : initial;\n        // Re-enable prop emits\n        node.props._emit = true;\n        node.props.attrs = attrs;\n        if (node.props.definition) {\n            node.props.definition.props = [\n                ...(((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.props) || []),\n                ...props,\n            ];\n        }\n    }\n    node.emit('added-props', props);\n    return node;\n}\n/**\n * (node.add) Adds a child to the node.\n * @param context -\n * @param node -\n * @param child -\n */\nfunction addChild(parent, parentContext, child, listIndex) {\n    if (parent.type === 'input')\n        error(100, parent);\n    if (child.parent && child.parent !== parent) {\n        child.parent.remove(child);\n    }\n    // Synchronously set the initial value on the parent\n    if (!parentContext.children.includes(child)) {\n        if (listIndex !== undefined && parent.type === 'list') {\n            // Inject the child:\n            parentContext.children.splice(listIndex, 0, child);\n            if (Array.isArray(parent.value) &&\n                parent.value.length < parentContext.children.length) {\n                // When adding an node or value to a list it is absolutely critical to\n                // know if, at the moment of injection, the parent’s value or the node\n                // children are the source of truth. For example, if a user pushes or\n                // splices a new value onto the lists’s array then we want to use that\n                // value as the value of the new node, but if a user adds a node to the\n                // list then we want the node’s value. In this specific case, we\n                // assume (due to length) that a new node was injected into the list, so\n                // we want that new node’s value injected into the parent list value.\n                parent.disturb().calm({\n                    name: listIndex,\n                    value: child.value,\n                    from: valueInserted,\n                });\n            }\n        }\n        else {\n            parentContext.children.push(child);\n        }\n        if (!child.isSettled)\n            parent.disturb();\n    }\n    if (child.parent !== parent) {\n        child.parent = parent;\n        // In this edge case middleware changed the parent assignment so we need to\n        // re-add the child\n        if (child.parent !== parent) {\n            parent.remove(child);\n            child.parent.add(child);\n            return parent;\n        }\n    }\n    else {\n        // When a parent is properly assigned, we inject the parent's plugins on the\n        // child.\n        child.use(parent.plugins);\n    }\n    // Finally we call commit here, which sub-calls hydrate(), hydrate() will\n    // resolve any conflict between the parent and child values, and also ensure\n    // proper \"placeholders\" are made on the parent.\n    commit(parent, parentContext, false);\n    parent.ledger.merge(child);\n    parent.emit('child', child);\n    return parent;\n}\n/**\n * The setter for node.parent = FormKitNode\n * @param _context -\n * @param node -\n * @param _property -\n * @param parent -\n * @returns boolean\n */\nfunction setParent(child, context, _property, parent) {\n    if (isNode(parent)) {\n        if (child.parent && child.parent !== parent) {\n            child.parent.remove(child);\n        }\n        context.parent = parent;\n        child.resetConfig();\n        !parent.children.includes(child)\n            ? parent.add(child)\n            : child.use(parent.plugins);\n        return true;\n    }\n    if (parent === null) {\n        context.parent = null;\n        return true;\n    }\n    return false;\n}\n/**\n * (node.remove) Removes a child from the node.\n * @param context -\n * @param node -\n * @param child -\n */\nfunction removeChild(node, context, child) {\n    const childIndex = context.children.indexOf(child);\n    if (childIndex !== -1) {\n        if (child.isSettled)\n            node.disturb();\n        context.children.splice(childIndex, 1);\n        // If an ancestor uses the preserve prop, then we are expected to not remove\n        // our values on this node either, see #53\n        let preserve = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.undefine)(child.props.preserve);\n        let parent = child.parent;\n        while (preserve === undefined && parent) {\n            preserve = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.undefine)(parent.props.preserve);\n            parent = parent.parent;\n        }\n        if (!preserve) {\n            node.calm({\n                name: node.type === 'list' ? childIndex : child.name,\n                value: valueRemoved,\n            });\n        }\n        else {\n            node.calm();\n        }\n        child.parent = null;\n        // Remove the child from the config. Is this weird? Yes. Is it ok? Yes.\n        child.config._rmn = child;\n    }\n    node.ledger.unmerge(child);\n    return node;\n}\n/**\n * Iterate over each immediate child and perform a callback.\n * @param context -\n * @param _node -\n * @param callback -\n */\nfunction eachChild(_node, context, callback) {\n    context.children.forEach((child) => callback(child));\n}\n/**\n * Walk all nodes below this one and execute a callback.\n * @param _node -\n * @param context -\n * @param callback -\n */\nfunction walkTree(_node, context, callback, stopIfFalse = false) {\n    context.children.forEach((child) => {\n        if (callback(child) !== false || !stopIfFalse) {\n            child.walk(callback);\n        }\n    });\n}\n/**\n * Set the configuration options of the node and it's subtree.\n * @param node -\n * @param context -\n * @param _property -\n * @param config -\n */\nfunction resetConfig(node, context) {\n    const parent = node.parent || undefined;\n    context.config = createConfig(node.config._t, parent);\n    node.walk((n) => n.resetConfig());\n}\n/**\n * Adds a plugin to the node, it’s children, and executes it.\n * @param context -\n * @param node -\n * @param plugin -\n * @public\n */\nfunction use(node, context, plugin, run = true, library = true) {\n    if (Array.isArray(plugin) || plugin instanceof Set) {\n        plugin.forEach((p) => use(node, context, p));\n        return node;\n    }\n    if (!context.plugins.has(plugin)) {\n        if (library && typeof plugin.library === 'function')\n            plugin.library(node);\n        // When plugins return false, they are never added as to the plugins Set\n        // meaning they only ever have access to the single node they were added on.\n        if (run && plugin(node) !== false) {\n            context.plugins.add(plugin);\n            node.children.forEach((child) => child.use(plugin));\n        }\n    }\n    return node;\n}\n/**\n * Moves a node in the parent’s children to the given index.\n * @param node -\n * @param _context -\n * @param _property -\n * @param setIndex -\n */\nfunction setIndex(node, _context, _property, setIndex) {\n    if (isNode(node.parent)) {\n        const children = node.parent.children;\n        const index = setIndex >= children.length\n            ? children.length - 1\n            : setIndex < 0\n                ? 0\n                : setIndex;\n        const oldIndex = children.indexOf(node);\n        if (oldIndex === -1)\n            return false;\n        children.splice(oldIndex, 1);\n        children.splice(index, 0, node);\n        node.parent.children = children;\n        if (node.parent.type === 'list')\n            node.parent\n                .disturb()\n                .calm({ name: index, value: valueMoved, from: oldIndex });\n        return true;\n    }\n    return false;\n}\n/**\n * Retrieves the index of a node from the parent’s children.\n * @param node -\n */\nfunction getIndex(node) {\n    if (node.parent) {\n        const index = [...node.parent.children].indexOf(node);\n        // If the index is currently -1 then the node isnt finished booting, so it\n        // must be the next node.\n        return index === -1 ? node.parent.children.length : index;\n    }\n    return -1;\n}\n/**\n * Retrieves the context object of a given node. This is intended to be a\n * private trap and should absolutely not be used in plugins or user-land code.\n * @param _node -\n * @param context -\n */\nfunction getContext(_node, context) {\n    return context;\n}\n/**\n * Get the name of the current node, allowing for slight mutations.\n * @param node -\n * @param context -\n */\nfunction getName(node, context) {\n    var _a;\n    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return node.index;\n    return context.name !== useIndex ? context.name : node.index;\n}\n/**\n * Returns the address of the current node.\n * @param node -\n * @param context -\n */\nfunction getAddress(node, context) {\n    return context.parent\n        ? context.parent.address.concat([node.name])\n        : [node.name];\n}\n/**\n * Fetches a node from the tree by its address.\n * @param context -\n * @param node -\n * @param location -\n * @returns FormKitNode\n */\nfunction getNode(node, _context, locator) {\n    const address = typeof locator === 'string' ? locator.split(node.config.delimiter) : locator;\n    if (!address.length)\n        return undefined;\n    const first = address[0];\n    let pointer = node.parent;\n    if (!pointer) {\n        // This address names the root node, remove it to get child name:\n        if (String(address[0]) === String(node.name))\n            address.shift();\n        // All root nodes start at themselves ultimately:\n        pointer = node;\n    }\n    // Any addresses starting with $parent should discard it\n    if (first === '$parent')\n        address.shift();\n    while (pointer && address.length) {\n        const name = address.shift();\n        switch (name) {\n            case '$root':\n                pointer = node.root;\n                break;\n            case '$parent':\n                pointer = pointer.parent;\n                break;\n            case '$self':\n                pointer = node;\n                break;\n            default:\n                pointer =\n                    pointer.children.find((c) => String(c.name) === String(name)) ||\n                        select(pointer, name);\n        }\n    }\n    return pointer || undefined;\n}\n/**\n * Perform selections on a subtree using the address \"selector\" methods.\n * @param node -\n * @param selector -\n * @returns FormKitNode | undefined\n */\nfunction select(node, selector) {\n    const matches = String(selector).match(/^(find)\\((.*)\\)$/);\n    if (matches) {\n        const [, action, argStr] = matches;\n        const args = argStr.split(',').map((arg) => arg.trim());\n        switch (action) {\n            case 'find':\n                return node.find(args[0], args[1]);\n            default:\n                return undefined;\n        }\n    }\n    return undefined;\n}\n/**\n * Perform a breadth first search and return the first instance of a node that\n * is found in the subtree or undefined.\n * @param node - The node to start the search on/under\n * @param _context - The context object\n * @param searchTerm - The term we are searching for\n * @param searcher - Either a key to search on, or a function\n * @returns\n */\nfunction find(node, _context, searchTerm, searcher) {\n    return bfs(node, searchTerm, searcher);\n}\n/**\n * Perform a breadth-first-search on a node subtree and locate the first\n * instance of a match.\n * @param node -\n * @param name -\n * @returns FormKitNode\n * @public\n */\nfunction bfs(tree, searchValue, searchGoal = 'name') {\n    const search = typeof searchGoal === 'string'\n        ? (n) => n[searchGoal] == searchValue // non-strict comparison is intentional\n        : searchGoal;\n    const stack = [tree];\n    while (stack.length) {\n        const node = stack.shift(); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        if (search(node, searchValue))\n            return node;\n        stack.push(...node.children);\n    }\n    return undefined;\n}\n/**\n * Get the root node of the tree.\n */\nfunction getRoot(n) {\n    let node = n;\n    while (node.parent) {\n        node = node.parent;\n    }\n    return node;\n}\n/**\n * Creates a new configuration option.\n * @param parent -\n * @param configOptions -\n * @returns FormKitConfig\n */\nfunction createConfig(target = {}, parent) {\n    let node = undefined;\n    return new Proxy(target, {\n        get(...args) {\n            const prop = args[1];\n            if (prop === '_t')\n                return target;\n            const localValue = Reflect.get(...args);\n            // Check our local values first\n            if (localValue !== undefined)\n                return localValue;\n            // Then check our parent values next\n            if (parent) {\n                const parentVal = parent.config[prop];\n                if (parentVal !== undefined)\n                    return parentVal;\n            }\n            if (target.rootConfig && typeof prop === 'string') {\n                const rootValue = target.rootConfig[prop];\n                if (rootValue !== undefined)\n                    return rootValue;\n            }\n            // The default delay value should be 20\n            if (prop === 'delay' && (node === null || node === void 0 ? void 0 : node.type) === 'input')\n                return 20;\n            // Finally check the default values\n            return defaultConfig[prop];\n        },\n        set(...args) {\n            const prop = args[1];\n            const value = args[2];\n            if (prop === '_n') {\n                node = value;\n                if (target.rootConfig)\n                    target.rootConfig._add(node);\n                return true;\n            }\n            if (prop === '_rmn') {\n                if (target.rootConfig)\n                    target.rootConfig._rm(node);\n                node = undefined;\n                return true;\n            }\n            if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.eq)(target[prop], value, false)) {\n                const didSet = Reflect.set(...args);\n                if (node) {\n                    node.emit(`config:${prop}`, value, false);\n                    configChange(node, prop, value);\n                    // Walk the node tree and notify of config/prop changes where relevant\n                    node.walk((n) => configChange(n, prop, value), true);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * Given a string of text, expose it for modification, translation, or full\n * replacement.\n * @param key - A message key, or generic string of text\n * @returns\n */\nfunction text(node, _context, key, type = 'ui') {\n    const fragment = typeof key === 'string' ? { key, value: key, type } : key;\n    const value = node.hook.text.dispatch(fragment);\n    node.emit('text', value, false);\n    return value.value;\n}\n/**\n * Submits the nearest ancestor that is a FormKit \"form\". It determines which\n * node is a form by locating an ancestor where node.props.isForm = true.\n * @param node - The node to initiate the submit\n */\nfunction submit(node) {\n    const name = node.name;\n    do {\n        if (node.props.isForm === true)\n            break;\n        if (!node.parent)\n            error(106, name);\n        node = node.parent;\n    } while (node);\n    if (node.props.id) {\n        submitForm(node.props.id);\n    }\n}\n/**\n * Reset to the original value.\n * @param node - The node to reset\n * @param _context - The context\n * @param value - The value to reset to\n */\nfunction resetValue(node, _context, value) {\n    return reset(node, value);\n}\n/**\n * Sets errors on the node and optionally its children.\n * @param node - The node to set errors on\n * @param _context - Not used\n * @param localErrors - An array of errors to set on this node\n * @param childErrors - An object of name to errors to set on children.\n */\nfunction setErrors$1(node, _context, localErrors, childErrors) {\n    const sourceKey = `${node.name}-set`;\n    createMessages(node, localErrors, childErrors).forEach((errors) => {\n        node.store.apply(errors, (message) => message.meta.source === sourceKey);\n    });\n    return node;\n}\n/**\n * Clears errors on the node and optionally its children.\n * @param node - The node to set errors on\n * @param _context - Not used\n * @param localErrors - An array of errors to set on this node\n * @param childErrors - An object of name to errors to set on children.\n */\nfunction clearErrors$1(node, context, clearChildErrors = true) {\n    setErrors$1(node, context, []);\n    if (clearChildErrors) {\n        const sourceKey = `${node.name}-set`;\n        node.walk((child) => {\n            child.store.filter((message) => {\n                return !(message.type === 'error' &&\n                    message.meta &&\n                    message.meta.source === sourceKey);\n            });\n        });\n    }\n    return node;\n}\n/**\n * Middleware to assign default prop values as issued by core.\n * @param node - The node being registered\n * @param next - Calls the next middleware.\n * @returns\n */\nfunction defaultProps(node) {\n    if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(node.props, 'id'))\n        node.props.id = `input_${idCount++}`;\n    return node;\n}\n/**\n * @param options -\n * @param config -\n */\nfunction createProps(initial) {\n    const props = {\n        initial: typeof initial === 'object' ? (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.cloneAny)(initial) : initial,\n    };\n    let node;\n    let isEmitting = true;\n    return new Proxy(props, {\n        get(...args) {\n            const [_t, prop] = args;\n            if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(props, prop))\n                return Reflect.get(...args);\n            if (node && typeof prop === 'string' && node.config[prop] !== undefined)\n                return node.config[prop];\n            return undefined;\n        },\n        set(target, property, originalValue, receiver) {\n            if (property === '_n') {\n                node = originalValue;\n                return true;\n            }\n            if (property === '_emit') {\n                isEmitting = originalValue;\n                return true;\n            }\n            const { prop, value } = node.hook.prop.dispatch({\n                prop: property,\n                value: originalValue,\n            });\n            // Typescript compiler cannot handle a symbol index, even though js can:\n            if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.eq)(props[prop], value, false) ||\n                typeof value === 'object') {\n                const didSet = Reflect.set(target, prop, value, receiver);\n                if (isEmitting) {\n                    node.emit('prop', { prop, value });\n                    if (typeof prop === 'string')\n                        node.emit(`prop:${prop}`, value);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * A cheap function that iterates over all plugins and stops once node.define\n * is called.\n * @param node - A formkit node\n * @param plugins - An array of plugins\n * @returns\n */\nfunction findDefinition(node, plugins) {\n    // If the definition is already there, force call to define.\n    if (node.props.definition)\n        return node.define(node.props.definition);\n    for (const plugin of plugins) {\n        if (node.props.definition)\n            return;\n        if (typeof plugin.library === 'function') {\n            plugin.library(node);\n        }\n    }\n}\n/**\n * Create a new context object for our a FormKit node, given default information\n * @param options - An options object to override the defaults.\n * @returns FormKitContext\n */\nfunction createContext(options) {\n    const value = createValue(options);\n    const config = createConfig(options.config || {}, options.parent);\n    return {\n        _d: 0,\n        _e: createEmitter(),\n        _resolve: false,\n        _tmo: false,\n        _value: value,\n        children: (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.dedupe)(options.children || []),\n        config,\n        hook: createHooks(),\n        isCreated: false,\n        isSettled: true,\n        ledger: createLedger(),\n        name: createName(options),\n        parent: options.parent || null,\n        plugins: new Set(),\n        props: createProps(value),\n        settled: Promise.resolve(value),\n        store: createStore(true),\n        traps: createTraps(),\n        type: options.type || 'input',\n        value,\n    };\n}\n/**\n * Initialize a node object's internal properties.\n * @param node - The node to initialize\n * @returns FormKitNode\n */\nfunction nodeInit(node, options) {\n    var _a;\n    // Set the internal node on the props, config, ledger and store\n    node.ledger.init((node.store._n = node.props._n = node.config._n = node));\n    // Apply given in options to the node.\n    node.props._emit = false;\n    if (options.props)\n        Object.assign(node.props, options.props);\n    node.props._emit = true;\n    // Attempt to find a definition from the pre-existing plugins.\n    findDefinition(node, new Set([\n        ...(options.plugins || []),\n        ...(node.parent ? node.parent.plugins : []),\n    ]));\n    // Then we apply each plugin's root code, we do this with an explicit loop\n    // for that ity-bitty performance bump.\n    if (options.plugins) {\n        for (const plugin of options.plugins) {\n            use(node, node._c, plugin, true, false);\n        }\n    }\n    // Initialize the default props\n    defaultProps(node);\n    // Apply the parent to each child.\n    node.each((child) => node.add(child));\n    // If the node has a parent, ensure it's properly nested bi-directionally.\n    if (node.parent)\n        node.parent.add(node, options.index);\n    // Inputs are leafs, and cannot have children\n    if (node.type === 'input' && node.children.length)\n        error(100, node);\n    // Apply the input hook to the initial value.\n    input(node, node._c, node._value, false);\n    // Release the store buffer\n    node.store.release();\n    // Register the node globally if someone explicitly gave it an id\n    if ((_a = options.props) === null || _a === void 0 ? void 0 : _a.id)\n        register(node);\n    // Our node is finally ready, emit it to the world\n    node.emit('created', node);\n    node.isCreated = true;\n    return node;\n}\n/**\n * Creates a new instance of a FormKit Node. Nodes are the atomic unit of\n * a FormKit graph.\n *\n * @param options - An object of options to define the node.\n * @returns FormKitNode\n * @public\n */\nfunction createNode(options) {\n    const ops = options || {};\n    const context = createContext(ops);\n    // Note: The typing for the proxy object cannot be fully modeled, thus we are\n    // force-typing to a FormKitNode. See:\n    // https://github.com/microsoft/TypeScript/issues/28067\n    const node = new Proxy(context, {\n        get(...args) {\n            const [, property] = args;\n            if (property === '__FKNode__')\n                return true;\n            const trap = context.traps.get(property);\n            if (trap && trap.get)\n                return trap.get(node, context);\n            return Reflect.get(...args);\n        },\n        set(...args) {\n            const [, property, value] = args;\n            const trap = context.traps.get(property);\n            if (trap && trap.set)\n                return trap.set(node, context, property, value);\n            return Reflect.set(...args);\n        },\n    });\n    return nodeInit(node, ops);\n}\n\n/**\n * Type narrow that a node is a DOM node.\n * @param node - A schema node to check\n * @returns\n * @public\n */\nfunction isDOM(node) {\n    return typeof node !== 'string' && (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(node, '$el');\n}\n/**\n * Type narrow that a node is a DOM node.\n * @param node - A schema node to check\n * @returns\n * @public\n */\nfunction isComponent(node) {\n    return typeof node !== 'string' && (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(node, '$cmp');\n}\n/**\n * Root declaration.\n * @param node - An object to check\n * @returns\n * @public\n */\nfunction isConditional(node) {\n    if (!node || typeof node === 'string')\n        return false;\n    return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(node, 'if') && (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(node, 'then');\n}\n/**\n * Determines if the node is syntactic sugar or not.\n * @param node - Node\n * @returns\n * @public\n */\nfunction isSugar(node) {\n    return typeof node !== 'string' && '$formkit' in node;\n}\n/**\n * Converts syntactic sugar nodes to standard nodes.\n * @param node - A node to covert\n * @returns\n * @public\n */\nfunction sugar(node) {\n    if (typeof node === 'string') {\n        return {\n            $el: 'text',\n            children: node,\n        };\n    }\n    if (isSugar(node)) {\n        const { $formkit: type, for: iterator, if: condition, children, key, bind, ...props } = node;\n        return Object.assign({\n            $cmp: 'FormKit',\n            props: { ...props, type },\n        }, condition ? { if: condition } : {}, iterator ? { for: iterator } : {}, children ? { children } : {}, key ? { key } : {}, bind ? { bind } : {});\n    }\n    return node;\n}\n\n/**\n * Compiles a logical string like \"a != z || b == c\" into a single function.\n * The return value is an object with a \"provide\" method that iterates over all\n * requirement tokens to use as replacements.\n * ```typescript\n * let name = {\n *   value: 'jon'\n * }\n * const condition = compile(\"$name == 'bob'\").provide((token) => {\n *  return () => name.value // must return a function!\n * })\n *\n * condition() // false\n * ```\n * @param expr - A string to compile\n * @returns\n * @public\n */\nfunction compile(expr) {\n    /**\n     * These tokens are replacements used in evaluating a given condition.\n     */\n    // const tokens: FormKitTokens = {}\n    /**\n     * The value of the provide() callback. Used for late binding.\n     */\n    let provideTokens;\n    /**\n     * These are token requirements like \"$name.value\" that are need to fulfill\n     * a given condition call.\n     */\n    const requirements = new Set();\n    /**\n     * Expands the current value if it is a function.\n     * @param operand - A left or right hand operand\n     * @returns\n     */\n    const x = function expand(operand, tokens) {\n        return typeof operand === 'function' ? operand(tokens) : operand;\n    };\n    /**\n     * Comprehensive list of operators. This list MUST be\n     * ordered by the length of the operator characters in descending order.\n     */\n    const operatorRegistry = [\n        {\n            '&&': (l, r, t) => x(l, t) && x(r, t),\n            '||': (l, r, t) => x(l, t) || x(r, t),\n        },\n        {\n            '===': (l, r, t) => !!(x(l, t) === x(r, t)),\n            '!==': (l, r, t) => !!(x(l, t) !== x(r, t)),\n            '==': (l, r, t) => !!(x(l, t) == x(r, t)),\n            '!=': (l, r, t) => !!(x(l, t) != x(r, t)),\n            '>=': (l, r, t) => !!(x(l, t) >= x(r, t)),\n            '<=': (l, r, t) => !!(x(l, t) <= x(r, t)),\n            '>': (l, r, t) => !!(x(l, t) > x(r, t)),\n            '<': (l, r, t) => !!(x(l, t) < x(r, t)),\n        },\n        {\n            '+': (l, r, t) => x(l, t) + x(r, t),\n            '-': (l, r, t) => x(l, t) - x(r, t),\n        },\n        {\n            '*': (l, r, t) => x(l, t) * x(r, t),\n            '/': (l, r, t) => x(l, t) / x(r, t),\n            '%': (l, r, t) => x(l, t) % x(r, t),\n        },\n    ];\n    /**\n     * A full list of all operator symbols.\n     */\n    const operatorSymbols = operatorRegistry.reduce((s, g) => {\n        return s.concat(Object.keys(g));\n    }, []);\n    /**\n     * An array of the first character of each operator.\n     */\n    const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)));\n    /**\n     * Determines if the current character is the start of an operator symbol, if it\n     * is, it returns that symbol.\n     * @param symbols - An array of symbols that are considered operators\n     * @param char - The current character being operated on\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @returns\n     */\n    function getOp(symbols, char, p, expression) {\n        const candidates = symbols.filter((s) => s.startsWith(char));\n        if (!candidates.length)\n            return false;\n        return candidates.find((symbol) => {\n            if (expression.length >= p + symbol.length) {\n                const nextChars = expression.substring(p, p + symbol.length);\n                if (nextChars === symbol)\n                    return symbol;\n            }\n            return false;\n        });\n    }\n    /**\n     * Determines the step number of the right or left hand operator.\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @param direction - 1 = right, 0 = left\n     */\n    function getStep(p, expression, direction = 1) {\n        let next = direction\n            ? expression.substring(p + 1).trim()\n            : expression.substring(0, p).trim();\n        if (!next.length)\n            return -1;\n        if (!direction) {\n            // left hand direction could include a function name we need to remove\n            const reversed = next.split('').reverse();\n            const start = reversed.findIndex((char) => operatorChars.has(char));\n            next = reversed.slice(start).join('');\n        }\n        const char = next[0];\n        return operatorRegistry.findIndex((operators) => {\n            const symbols = Object.keys(operators);\n            return !!getOp(symbols, char, 0, next);\n        });\n    }\n    /**\n     * Extracts a tail call. For example:\n     * ```\n     * $foo().bar(baz) + 7\n     * ```\n     * Would extract \"bar(baz)\" and return p of 15 (after the (baz)).\n     *\n     * @param p - The position of a closing parenthetical.\n     * @param expression - The full expression being parsed.\n     */\n    function getTail(pos, expression) {\n        let tail = '';\n        const length = expression.length;\n        let depth = 0;\n        for (let p = pos; p < length; p++) {\n            const char = expression.charAt(p);\n            if (char === '(') {\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n            }\n            else if (depth === 0 && char === ' ') {\n                continue;\n            }\n            if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {\n                return [tail, p - 1];\n            }\n            else {\n                tail += char;\n            }\n        }\n        return [tail, expression.length - 1];\n    }\n    /**\n     * Parse a string expression into a function that returns a boolean. This is\n     * the magic behind schema logic like $if.\n     * @param expression - A string expression to parse\n     * @returns\n     */\n    function parseLogicals(expression, step = 0) {\n        const operators = operatorRegistry[step];\n        const length = expression.length;\n        const symbols = Object.keys(operators);\n        let depth = 0;\n        let quote = false;\n        let op = null;\n        let operand = '';\n        let left = null;\n        let operation;\n        let lastChar = '';\n        let char = '';\n        let parenthetical = '';\n        let parenQuote = '';\n        let startP = 0;\n        const addTo = (depth, char) => {\n            depth ? (parenthetical += char) : (operand += char);\n        };\n        for (let p = 0; p < length; p++) {\n            lastChar = char;\n            char = expression.charAt(p);\n            if ((char === \"'\" || char === '\"') &&\n                lastChar !== '\\\\' &&\n                ((depth === 0 && !quote) || (depth && !parenQuote))) {\n                if (depth) {\n                    parenQuote = char;\n                }\n                else {\n                    quote = char;\n                }\n                addTo(depth, char);\n                continue;\n            }\n            else if ((quote && (char !== quote || lastChar === '\\\\')) ||\n                (parenQuote && (char !== parenQuote || lastChar === '\\\\'))) {\n                addTo(depth, char);\n                continue;\n            }\n            else if (quote === char) {\n                quote = false;\n                addTo(depth, char);\n                continue;\n            }\n            else if (parenQuote === char) {\n                parenQuote = false;\n                addTo(depth, char);\n                continue;\n            }\n            else if (char === ' ') {\n                continue;\n            }\n            else if (char === '(') {\n                if (depth === 0) {\n                    startP = p;\n                }\n                else {\n                    parenthetical += char;\n                }\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n                if (depth === 0) {\n                    // Parenthetical statements cannot be grouped up in the implicit order\n                    // of left/right statements based on which step they are on because\n                    // they are parsed on every step and then must be applied to the\n                    // operator. Example:\n                    //\n                    // 5 + (3) * 2\n                    //\n                    // This should yield 11 not 16. This order is normally implicit in the\n                    // sequence of operators being parsed, but with parenthesis the parse\n                    // happens each time. Instead we need to know if the resulting value\n                    // should be applied to the left or the right hand operator. The\n                    // general algorithm is:\n                    //\n                    // 1. Does this paren have an operator on the left or right side\n                    // 2. If not, it's unnecessarily wrapped (3 + 2)\n                    // 3. If it does, then which order of operation is highest?\n                    // 4. Wait for the highest order of operation to bind to an operator.\n                    // If the parenthetical has a preceding token like $fn(1 + 2) then we\n                    // need to subtract the existing operand length from the start\n                    // to determine if this is a left or right operation\n                    const fn = typeof operand === 'string' && operand.startsWith('$')\n                        ? operand\n                        : undefined;\n                    const hasTail = fn && expression.charAt(p + 1) === '.';\n                    // It's possible the function has a chained tail call:\n                    let tail = '';\n                    if (hasTail) {\n                        [tail, p] = getTail(p + 2, expression);\n                    }\n                    const lStep = op ? step : getStep(startP, expression, 0);\n                    const rStep = getStep(p, expression);\n                    if (lStep === -1 && rStep === -1) {\n                        // This parenthetical was unnecessarily wrapped at the root, or\n                        // these are args of a function call.\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {\n                        // has a left hand operator with a higher order of operation\n                        left = op.bind(null, evaluate(parenthetical, -1, fn, tail));\n                        op = null;\n                        operand = '';\n                    }\n                    else if (rStep > lStep && step === rStep) {\n                        // should be applied to the right hand operator when it gets one\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else {\n                        operand += `(${parenthetical})${hasTail ? `.${tail}` : ''}`;\n                    }\n                    parenthetical = '';\n                }\n                else {\n                    parenthetical += char;\n                }\n            }\n            else if (depth === 0 &&\n                (operation = getOp(symbols, char, p, expression))) {\n                if (p === 0) {\n                    error(103, [operation, expression]);\n                }\n                // We identified the operator by looking ahead in the string, so we need\n                // our position to move past the operator\n                p += operation.length - 1;\n                if (p === expression.length - 1) {\n                    error(104, [operation, expression]);\n                }\n                if (!op) {\n                    // Bind the left hand operand\n                    if (left) {\n                        // In this case we've already parsed the left hand operator\n                        op = operators[operation].bind(null, evaluate(left, step));\n                        left = null;\n                    }\n                    else {\n                        op = operators[operation].bind(null, evaluate(operand, step));\n                        operand = '';\n                    }\n                }\n                else if (operand) {\n                    // Bind the right hand operand, and return the resulting expression as a new left hand operator\n                    left = op.bind(null, evaluate(operand, step));\n                    op = operators[operation].bind(null, left);\n                    operand = '';\n                }\n                continue;\n            }\n            else {\n                addTo(depth, char);\n            }\n        }\n        if (operand && op) {\n            // If we were left with an operand after the loop, and an op, it should\n            // be the right hand assignment.\n            op = op.bind(null, evaluate(operand, step));\n        }\n        // If we don't have an op, but we do have a left hand assignment, then that\n        // is actually our operator, so just re-assign it to op\n        op = !op && left ? left : op;\n        if (!op && operand) {\n            // If we don't have any op but we do have an operand so there is no boolean\n            // logic to perform, but that operand still means something so we need to\n            // evaluate it and return it as a function\n            op = (v, t) => {\n                return typeof v === 'function' ? v(t) : v;\n            };\n            op = op.bind(null, evaluate(operand, step));\n        }\n        if (!op && !operand) {\n            error(105, expression);\n        }\n        return op;\n    }\n    /**\n     * Given a string like '$name==bobby' evaluate it to true or false\n     * @param operand - A left or right boolean operand — usually conditions\n     * @param step - The current order of operation\n     * @param fnToken - The token (string) representation of a function being called\n     * @returns\n     */\n    function evaluate(operand, step, fnToken, tail //eslint-disable-line\n    ) {\n        if (fnToken) {\n            const fn = evaluate(fnToken, operatorRegistry.length);\n            let userFuncReturn;\n            // \"Tail calls\" are dot accessors after a function $foo().value. We need\n            // to compile tail calls, and then provide the function result to the\n            // exposed tokens.\n            let tailCall = tail\n                ? compile(`$${tail}`)\n                : false;\n            if (typeof fn === 'function') {\n                const args = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.parseArgs)(String(operand)).map((arg) => evaluate(arg, -1));\n                return (tokens) => {\n                    const userFunc = fn(tokens);\n                    if (typeof userFunc !== 'function') {\n                        warn(150, fnToken);\n                        return userFunc;\n                    }\n                    userFuncReturn = userFunc(...args.map((arg) => typeof arg === 'function' ? arg(tokens) : arg));\n                    if (tailCall) {\n                        tailCall = tailCall.provide((subTokens) => {\n                            const rootTokens = provideTokens(subTokens);\n                            const t = subTokens.reduce((tokenSet, token) => {\n                                const isTail = token === tail || (tail === null || tail === void 0 ? void 0 : tail.startsWith(`${token}(`));\n                                if (isTail) {\n                                    const value = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.getAt)(userFuncReturn, token);\n                                    tokenSet[token] = () => value;\n                                }\n                                else {\n                                    tokenSet[token] = rootTokens[token];\n                                }\n                                return tokenSet;\n                            }, {});\n                            return t;\n                        });\n                    }\n                    return tailCall ? tailCall() : userFuncReturn;\n                };\n            }\n        }\n        else if (typeof operand === 'string') {\n            // the word true or false will never contain further operations\n            if (operand === 'true')\n                return true;\n            if (operand === 'false')\n                return false;\n            if (operand === 'undefined')\n                return undefined;\n            // Truly quotes strings cannot contain an operation, return the string\n            if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.isQuotedString)(operand))\n                return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.rmEscapes)(operand.substring(1, operand.length - 1));\n            // Actual numbers cannot be contain an operation\n            if (!isNaN(+operand))\n                return Number(operand);\n            if (step < operatorRegistry.length - 1) {\n                return parseLogicals(operand, step + 1);\n            }\n            else {\n                if (operand.startsWith('$')) {\n                    const cleaned = operand.substring(1);\n                    requirements.add(cleaned);\n                    return function getToken(tokens) {\n                        return cleaned in tokens ? tokens[cleaned]() : undefined;\n                    };\n                }\n                // In this case we are dealing with an unquoted string, just treat it\n                // as a plain string.\n                return operand;\n            }\n        }\n        return operand;\n    }\n    /**\n     * Compile the string.\n     */\n    const compiled = parseLogicals(expr.startsWith('$:') ? expr.substring(2) : expr);\n    /**\n     * Convert compiled requirements to an array.\n     */\n    const reqs = Array.from(requirements);\n    /**\n     * Provides token values via callback to compiled output.\n     * @param callback - A callback that needs to provide all token requirements\n     * @returns\n     */\n    function provide(callback) {\n        provideTokens = callback;\n        return Object.assign(compiled.bind(null, callback(reqs)), {\n            provide,\n        });\n    }\n    return Object.assign(compiled, {\n        provide,\n    });\n}\n\n/**\n * Function that produces a standardized object representation of CSS classes\n * @param propertyKey - section key\n * @param node - FormKit node\n * @param sectionClassList - Things to turn into classes\n * @returns\n * @public\n */\nfunction createClasses(propertyKey, node, sectionClassList) {\n    if (!sectionClassList)\n        return {};\n    if (typeof sectionClassList === 'string') {\n        const classKeys = sectionClassList.split(' ');\n        return classKeys.reduce((obj, key) => Object.assign(obj, { [key]: true }), {});\n    }\n    else if (typeof sectionClassList === 'function') {\n        return createClasses(propertyKey, node, sectionClassList(node, propertyKey));\n    }\n    return sectionClassList;\n}\n/**\n * Combines multiple class lists into a single list\n * @param node - the FormKit node being operated on\n * @param property - The property key to which the class list will be applied\n * @param args - CSS class list(s)\n * @returns\n * @public\n */\nfunction generateClassList(node, property, ...args) {\n    const combinedClassList = args.reduce((finalClassList, currentClassList) => {\n        if (!currentClassList)\n            return finalClassList;\n        const { $reset, ...classList } = currentClassList;\n        if ($reset) {\n            return classList;\n        }\n        return Object.assign(finalClassList, classList);\n    }, {});\n    return (Object.keys(node.hook.classes.dispatch({ property, classes: combinedClassList })\n        .classes)\n        .filter((key) => combinedClassList[key])\n        .join(' ') || null);\n}\n\n/**\n * Sets errors on a form, group, or input.\n * @param formId - The id of a form\n * @param localErrors - The errors to set on the form or the form’s inputs\n * @param childErrors - (optional) The errors to set on the form or the form’s inputs\n * @public\n */\nfunction setErrors(id, localErrors, childErrors) {\n    const node = getNode$1(id);\n    if (node) {\n        node.setErrors(localErrors, childErrors);\n    }\n    else {\n        warn(651, id);\n    }\n}\n/**\n * Clears child errors.\n * @param id - The id of the node you want to clear errors for\n * @param clearChildren - Determines if the the children of this node should have their errors cleared.\n * @public\n */\nfunction clearErrors(id, clearChildren = true) {\n    const node = getNode$1(id);\n    if (node) {\n        node.clearErrors(clearChildren);\n    }\n    else {\n        warn(652, id);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvY29yZS9kaXN0L2luZGV4Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWtpdC9jb3JlL2Rpc3QvaW5kZXgubWpzPzQ5MTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9rZW4sIHNsdWdpZnksIGhhcywgY2xvbmVBbnksIGluaXQsIGNsb25lLCBjYW1lbCwgdW5kZWZpbmUsIGVxLCBrZWJhYiwgZGVkdXBlLCBwYXJzZUFyZ3MsIGdldEF0LCBpc1F1b3RlZFN0cmluZywgcm1Fc2NhcGVzIH0gZnJvbSAnQGZvcm1raXQvdXRpbHMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZGlzcGF0Y2hlciB0aGF0IGFsbG93cyB0aGUgYWRkaXRpb24vcmVtb3ZhbCBvZiBtaWRkbGV3YXJlXG4gKiBmdW5jdGlvbnMsIGFuZCB0aGUgYWJpbGl0eSB0byBkaXNwYXRjaCBhIHBheWxvYWQgdG8gYWxsIG1pZGRsZXdhcmUuXG4gKiBAcmV0dXJucyBGb3JtS2l0RGlzcGF0Y2hlclxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaGVyKCkge1xuICAgIGNvbnN0IG1pZGRsZXdhcmUgPSBbXTtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBjb25zdCB1c2UgPSAoZGlzcGF0Y2hhYmxlKSA9PiBtaWRkbGV3YXJlLnB1c2goZGlzcGF0Y2hhYmxlKTtcbiAgICBjb25zdCBkaXNwYXRjaCA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGV3YXJlW2N1cnJlbnRJbmRleF07XG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQocGF5bG9hZCwgKGV4cGxpY2l0UGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaChleHBsaWNpdFBheWxvYWQgPT09IHVuZGVmaW5lZCA/IHBheWxvYWQgOiBleHBsaWNpdFBheWxvYWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbiAgICB1c2UuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICB1c2UudW5zaGlmdCA9IChkaXNwYXRjaGFibGUpID0+IG1pZGRsZXdhcmUudW5zaGlmdChkaXNwYXRjaGFibGUpO1xuICAgIHVzZS5yZW1vdmUgPSAoZGlzcGF0Y2hhYmxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbWlkZGxld2FyZS5pbmRleE9mKGRpc3BhdGNoYWJsZSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgbWlkZGxld2FyZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gICAgcmV0dXJuIHVzZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGV2ZW50IGVtaXR0ZXIsIGVhY2ggbm9kZSB1c2VzIG9uZSBvZiB0aGVzZSB0byBhbGxvdyBpdCB0byBlbWl0XG4gKiBldmVudHMgdG8gbG9jYWwgbGlzdGVuZXJzIGFuZCB0cmVlIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIEZvcm1LaXRFdmVudEVtaXR0ZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcmVjZWlwdHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBlbWl0dGVyID0gKG5vZGUsIGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZXZlbnQubmFtZSwgW25vZGUsIGV2ZW50XSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVycy5oYXMoZXZlbnQubmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBsaXN0ZW5lcnMuZ2V0KGV2ZW50Lm5hbWUpLmZvckVhY2goKHdyYXBwZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luID09PSBub2RlIHx8IHdyYXBwZXIubW9kaWZpZXJzLmluY2x1ZGVzKCdkZWVwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5saXN0ZW5lcihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmJ1YmJsZSkge1xuICAgICAgICAgICAgbm9kZS5idWJibGUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0b1xuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHN0cmluZ1xuICAgICAqL1xuICAgIGVtaXR0ZXIub24gPSAoZXZlbnROYW1lLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgICBjb25zdCBbZXZlbnQsIC4uLm1vZGlmaWVyc10gPSBldmVudE5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGxpc3RlbmVyLnJlY2VpcHQgfHwgdG9rZW4oKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHtcbiAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICByZWNlaXB0LFxuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG4gICAgICAgIGxpc3RlbmVycy5oYXMoZXZlbnQpXG4gICAgICAgICAgICA/IGxpc3RlbmVycy5nZXQoZXZlbnQpLnB1c2god3JhcHBlcilcbiAgICAgICAgICAgIDogbGlzdGVuZXJzLnNldChldmVudCwgW3dyYXBwZXJdKTtcbiAgICAgICAgcmVjZWlwdHMuaGFzKHJlY2VpcHQpXG4gICAgICAgICAgICA/IHJlY2VpcHRzLmdldChyZWNlaXB0KS5wdXNoKGV2ZW50KVxuICAgICAgICAgICAgOiByZWNlaXB0cy5zZXQocmVjZWlwdCwgW2V2ZW50XSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAqL1xuICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lck9yUmVjZWlwdCAtIEVpdGhlciBhIHJlY2VpcHQgb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGVtaXR0ZXIub2ZmID0gKHJlY2VpcHQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocmVjZWlwdHMuaGFzKHJlY2VpcHQpKSB7XG4gICAgICAgICAgICAoX2EgPSByZWNlaXB0cy5nZXQocmVjZWlwdCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzLmdldChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnRMaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnQsIGV2ZW50TGlzdGVuZXJzLmZpbHRlcigod3JhcHBlcikgPT4gd3JhcHBlci5yZWNlaXB0ICE9PSByZWNlaXB0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWNlaXB0cy5kZWxldGUocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhdXNlIGVtaXR0aW5nIHZhbHVlcy4gQW55IGV2ZW50cyBlbWl0dGVkIHdoaWxlIHBhdXNlZCB3aWxsIG5vdCBiZSBlbWl0dGVkXG4gICAgICogYnV0IHJhdGhlciBcInN0b3JlZFwiIOKAlMKgYW5kIHdoaWNoZXZlciBldmVudHMgYXJlIGVtaXR0ZWQgbGFzdCB3aWxsIGJlIG91dHB1dC5cbiAgICAgKiBGb3IgZXhhbXBsZTpcbiAgICAgKiBwYXVzZSgpXG4gICAgICogZW1pdCgnZm9vJywgMSlcbiAgICAgKiBlbWl0KCdmb28nLCAyKVxuICAgICAqIGVtaXQoJ2JhcicsIDMpXG4gICAgICogZW1pdCgnYmFyJywgNClcbiAgICAgKiBwbGF5KClcbiAgICAgKiAvLyB3b3VsZCByZXN1bHQgaW5cbiAgICAgKiBlbWl0KCdmb28nLCAyKVxuICAgICAqIGVtaXQoJ2JhcicsIDQpXG4gICAgICogT3B0aW9uYWxseSBwYXVzZXMgYWxsIGNoaWxkcmVuIGFzIHdlbGwuXG4gICAgICogQHBhcmFtIG5vZGUgLSBBIG5vZGUgdG8gcGF1c2UgYWxsIGNoaWxkcmVuIG9uLlxuICAgICAqL1xuICAgIGVtaXR0ZXIucGF1c2UgPSAobm9kZSkgPT4ge1xuICAgICAgICBpZiAoIWJ1ZmZlcilcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUud2FsaygoY2hpbGQpID0+IGNoaWxkLl9lLnBhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSBjdXJyZW50IGV2ZW50IGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gbm9kZSAtIEEgbm9kZSB0byB1bnBhdXNlIGFsbCBjaGlsZHJlbiBvbi5cbiAgICAgKi9cbiAgICBlbWl0dGVyLnBsYXkgPSAobm9kZSkgPT4ge1xuICAgICAgICBpZiAoIWJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gYnVmZmVyO1xuICAgICAgICBidWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKChbbm9kZSwgZXZlbnRdKSA9PiBlbWl0dGVyKG5vZGUsIGV2ZW50KSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLndhbGsoKGNoaWxkKSA9PiBjaGlsZC5fZS5wbGF5KCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZW1pdHRlcjtcbn1cbi8qKlxuICogRW1pdCBhbiBldmVudCBmcm9tIHRoaXMgbm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdGhhdCBpcyBlbWl0dGluZ1xuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCBvZiB0aGF0IG5vZGVcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkIHRvIGVtaXRcbiAqIEByZXR1cm5zIEZvcm1LaXROb2RlXG4gKi9cbmZ1bmN0aW9uIGVtaXQkMShub2RlLCBjb250ZXh0LCBuYW1lLCBwYXlsb2FkLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXMsXG5idWJibGUgPSB0cnVlKSB7XG4gICAgY29udGV4dC5fZShub2RlLCB7XG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGJ1YmJsZSxcbiAgICAgICAgb3JpZ2luOiBub2RlLFxuICAgIH0pO1xuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBTZW5kIGFuIGV2ZW50IGZyb20gdGhlIGdpdmVuIG5vZGUgdXAgaXQncyBhbmNlc3RvciB0cmVlLlxuICogQHBhcmFtIG5vZGUgLVxuICogQHBhcmFtIF9jb250ZXh0IC1cbiAqIEBwYXJhbSBldmVudCAtXG4gKi9cbmZ1bmN0aW9uIGJ1YmJsZShub2RlLCBfY29udGV4dCwgZXZlbnQpIHtcbiAgICBpZiAoaXNOb2RlKG5vZGUucGFyZW50KSkge1xuICAgICAgICBub2RlLnBhcmVudC5fZShub2RlLnBhcmVudCwgZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbm9kZSBmb3IgYSBzcGVjaWZpYyBldmVudC4gVGhlIGV2ZW50IG5hbWUgaXMgYVxuICogc2ltcGxlIHN0cmluZyBtYXRjaGluZyB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvLiBJdCBjYW4gb3B0aW9uYWxseVxuICogaW5jbHVkZSBtb2RpZmllcnMgbGlrZSBldmVudE5hbWUuZGVlcFxuICogQHBhcmFtIG5vZGUgLVxuICogQHBhcmFtIGNvbnRleHQgLVxuICogQHBhcmFtIG5hbWUgLVxuICogQHBhcmFtIGxpc3RlbmVyIC1cbiAqIEByZXR1cm5zIEZvcm1LaXROb2RlXG4gKi9cbmZ1bmN0aW9uIG9uKF9ub2RlLCBjb250ZXh0LCBuYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBjb250ZXh0Ll9lLm9uKG5hbWUsIGxpc3RlbmVyKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGEgbm9kZSBieSB0aGUgcmV0dXJuZWQgcmVjZWlwdCBmcm9tIC5vbigpLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byByZW1vdGUgdGhlIGxpc3RlbmVyIGZyb21cbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gcmVjZWlwdCAtIFRoZSByZWNlaXB0IHJldHVybmVkIGJ5IC5vbigpXG4gKiBAcmV0dXJucyBGb3JtS2l0Tm9kZVxuICovXG5mdW5jdGlvbiBvZmYobm9kZSwgY29udGV4dCwgcmVjZWlwdCkge1xuICAgIGNvbnRleHQuX2Uub2ZmKHJlY2VpcHQpO1xuICAgIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZvcm1LaXQncyBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZXJyb3JIYW5kbGVyID0gY3JlYXRlRGlzcGF0Y2hlcigpO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGp1c3Qgc2V0cyB0aGUgZXJyb3IgYXMgdGhlIG1lc3NhZ2UuXG4gKi9cbmVycm9ySGFuZGxlcigoZXJyb3IsIG5leHQpID0+IHtcbiAgICBpZiAoIWVycm9yLm1lc3NhZ2UpXG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSBTdHJpbmcoYEUke2Vycm9yLmNvZGV9YCk7XG4gICAgcmV0dXJuIG5leHQoZXJyb3IpO1xufSk7XG4vKipcbiAqIEZvcm1LaXQncyBnbG9iYWwgd2FybmluZyBoYW5kbGVyLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB3YXJuaW5nSGFuZGxlciA9IGNyZWF0ZURpc3BhdGNoZXIoKTtcbndhcm5pbmdIYW5kbGVyKCh3YXJuaW5nLCBuZXh0KSA9PiB7XG4gICAgaWYgKCF3YXJuaW5nLm1lc3NhZ2UpXG4gICAgICAgIHdhcm5pbmcubWVzc2FnZSA9IFN0cmluZyhgVyR7d2FybmluZy5jb2RlfWApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5leHQod2FybmluZyk7XG4gICAgaWYgKGNvbnNvbGUgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgY29uc29sZS53YXJuKHJlc3VsdC5tZXNzYWdlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSk7XG4vKipcbiAqIEdsb2JhbGx5IGVtaXRzIGEgd2FybmluZy5cbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGludGVnZXIgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSBkYXRhIC0gVXN1YWxseSBhbiBvYmplY3Qgb2YgaW5mb3JtYXRpb24gdG8gaW5jbHVkZS5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gd2Fybihjb2RlLCBkYXRhID0ge30pIHtcbiAgICB3YXJuaW5nSGFuZGxlci5kaXNwYXRjaCh7IGNvZGUsIGRhdGEgfSk7XG59XG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLCBnZW5lcmFsbHkgc2hvdWxkIHJlc3VsdCBpbiBhbiBleGNlcHRpb24uXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBpbnRlZ2VyIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0gZGF0YSAtIFVzdWFsbHkgYW4gb2JqZWN0IG9mIGluZm9ybWF0aW9uIHRvIGluY2x1ZGUuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVycm9yKGNvZGUsIGRhdGEgPSB7fSkge1xuICAgIHRocm93IEVycm9yKGVycm9ySGFuZGxlci5kaXNwYXRjaCh7IGNvZGUsIGRhdGEgfSkubWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBGb3JtS2l0TWVzc2FnZSBvYmplY3QuXG4gKiBAcGFyYW0gY29uZiAtIFRoZSBtZXNzYWdlIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIEZvcm1LaXRNZXNzYWdlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2UoY29uZiwgbm9kZSkge1xuICAgIGNvbnN0IG0gPSB7XG4gICAgICAgIGJsb2NraW5nOiBmYWxzZSxcbiAgICAgICAga2V5OiB0b2tlbigpLFxuICAgICAgICBtZXRhOiB7fSxcbiAgICAgICAgdHlwZTogJ3N0YXRlJyxcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgLi4uY29uZixcbiAgICB9O1xuICAgIGlmIChub2RlICYmIG0udmFsdWUgJiYgbS5tZXRhLmxvY2FsaXplICE9PSBmYWxzZSkge1xuICAgICAgICBtLnZhbHVlID0gbm9kZS50KG0pO1xuICAgICAgICBtLm1ldGEubG9jYWxlID0gbm9kZS5jb25maWcubG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbn1cbi8qKlxuICogVGhlIGF2YWlsYWJsZSB0cmFwcyBvbiB0aGUgbm9kZSdzIHN0b3JlLlxuICovXG5jb25zdCBzdG9yZVRyYXBzID0ge1xuICAgIGFwcGx5OiBhcHBseU1lc3NhZ2VzLFxuICAgIHNldDogc2V0TWVzc2FnZSxcbiAgICByZW1vdmU6IHJlbW92ZU1lc3NhZ2UsXG4gICAgZmlsdGVyOiBmaWx0ZXJNZXNzYWdlcyxcbiAgICByZWR1Y2U6IHJlZHVjZU1lc3NhZ2VzLFxuICAgIHJlbGVhc2U6IHJlbGVhc2VCdWZmZXIsXG4gICAgdG91Y2g6IHRvdWNoTWVzc2FnZXMsXG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEZvcm1LaXQgbWVzc2FnZSBzdG9yZS5cbiAqIEByZXR1cm5zIEZvcm1LaXRTdG9yZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShfYnVmZmVyID0gZmFsc2UpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IHt9O1xuICAgIGxldCBub2RlO1xuICAgIGxldCBidWZmZXIgPSBfYnVmZmVyO1xuICAgIGxldCBfYiA9IFtdO1xuICAgIGNvbnN0IF9tID0gbmV3IE1hcCgpO1xuICAgIGxldCBfciA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzdG9yZSA9IG5ldyBQcm94eShtZXNzYWdlcywge1xuICAgICAgICBnZXQoLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgW190YXJnZXQsIHByb3BlcnR5XSA9IGFyZ3M7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICdidWZmZXInKVxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICdfYicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9iO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnX20nKVxuICAgICAgICAgICAgICAgIHJldHVybiBfbTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ19yJylcbiAgICAgICAgICAgICAgICByZXR1cm4gX3I7XG4gICAgICAgICAgICBpZiAoaGFzKHN0b3JlVHJhcHMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZVRyYXBzW3Byb3BlcnR5XS5iaW5kKG51bGwsIG1lc3NhZ2VzLCBzdG9yZSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfdCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnX24nKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChfciA9PT0gJ19fbicpXG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VNaXNzZWQobm9kZSwgc3RvcmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ19iJykge1xuICAgICAgICAgICAgICAgIF9iID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wID09PSAnYnVmZmVyJykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ19yJykge1xuICAgICAgICAgICAgICAgIF9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcigxMDEsIG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBzdG9yZTtcbn1cbi8qKlxuICogQWRkcyBhIG5ldyB2YWx1ZSB0byBhIEZvcm1LaXQgbWVzc2FnZSBiYWcuXG4gKiBAcGFyYW0gc3RvcmUgLSBUaGUgc3RvcmUgaXRzZWxmXG4gKiBAcGFyYW0gc3RvcmUgLSBUaGUgc3RvcmUgaW50ZXJmYWNlXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRoaXMgc3RvcmUgYmVsb25ncyB0b1xuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvYmplY3RcbiAqIEByZXR1cm5zIEZvcm1LaXRTdG9yZVxuICovXG5mdW5jdGlvbiBzZXRNZXNzYWdlKG1lc3NhZ2VTdG9yZSwgc3RvcmUsIG5vZGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoc3RvcmUuYnVmZmVyKSB7XG4gICAgICAgIHN0b3JlLl9iLnB1c2goW1ttZXNzYWdlXV0pO1xuICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlU3RvcmVbbWVzc2FnZS5rZXldICE9PSBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS52YWx1ZSA9PT0gJ3N0cmluZycgJiYgbWVzc2FnZS5tZXRhLmxvY2FsaXplICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gRXhwb3NlIHRoZSB2YWx1ZSB0byB0cmFuc2xhdGlvblxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IG5vZGUudChtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9PSBwcmV2aW91cykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YS5sb2NhbGUgPSBub2RlLnByb3BzLmxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlID0gYG1lc3NhZ2UtJHtoYXMobWVzc2FnZVN0b3JlLCBtZXNzYWdlLmtleSkgPyAndXBkYXRlZCcgOiAnYWRkZWQnfWA7XG4gICAgICAgIG1lc3NhZ2VTdG9yZVttZXNzYWdlLmtleV0gPSBPYmplY3QuZnJlZXplKG5vZGUuaG9vay5tZXNzYWdlLmRpc3BhdGNoKG1lc3NhZ2UpKTtcbiAgICAgICAgbm9kZS5lbWl0KGUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmU7XG59XG4vKipcbiAqIFJ1biB0aHJvdWdoIGVhY2ggbWVzc2FnZSBpbiB0aGUgc3RvcmUsIGFuZCBlbnN1cmUgaXQgaGFzIGJlZW4gdHJhbnNsYXRlZFxuICogdG8gdGhlIHByb3BlciBsYW5ndWFnZS4gVGhpcyBtb3N0IGZyZXF1ZW50bHkgaGFwcGVucyBhZnRlciBhIGxvY2FsZSBjaGFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHRvdWNoTWVzc2FnZXMobWVzc2FnZVN0b3JlLCBzdG9yZSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1lc3NhZ2VTdG9yZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0geyAuLi5tZXNzYWdlU3RvcmVba2V5XSB9O1xuICAgICAgICBzdG9yZS5zZXQobWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmUgYSBtZXNzYWdlIGZyb20gdGhlIHN0b3JlLlxuICogQHBhcmFtIHN0b3JlIC0gVGhlIHN0b3JlIGl0c2VsZlxuICogQHBhcmFtIHN0b3JlIC0gVGhlIHN0b3JlIGludGVyZmFjZVxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0aGlzIHN0b3JlIGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBrZXkgLSBUaGUgbWVzc2FnZSBrZXlcbiAqIEByZXR1cm5zIEZvcm1LaXRTdG9yZVxuICovXG5mdW5jdGlvbiByZW1vdmVNZXNzYWdlKG1lc3NhZ2VTdG9yZSwgc3RvcmUsIG5vZGUsIGtleSkge1xuICAgIGlmIChoYXMobWVzc2FnZVN0b3JlLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlU3RvcmVba2V5XTtcbiAgICAgICAgZGVsZXRlIG1lc3NhZ2VTdG9yZVtrZXldO1xuICAgICAgICBub2RlLmVtaXQoJ21lc3NhZ2UtcmVtb3ZlZCcsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuYnVmZmVyID09PSB0cnVlKSB7XG4gICAgICAgIHN0b3JlLl9iID0gc3RvcmUuX2IuZmlsdGVyKChidWZmZXJlZCkgPT4ge1xuICAgICAgICAgICAgYnVmZmVyZWRbMF0gPSBidWZmZXJlZFswXS5maWx0ZXIoKG0pID0+IG0ua2V5ICE9PSBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcmVkWzFdIHx8IGJ1ZmZlcmVkWzBdLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZTtcbn1cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBhbGwgbWVzc2FnZXMgcmVtb3ZpbmcgdGhvc2UgdGhhdCBhcmUgbm8gbG9uZ2VyIHdhbnRlZC5cbiAqIEBwYXJhbSBtZXNzYWdlU3RvcmUgLSBUaGUgc3RvcmUgaXRzZWxmXG4gKiBAcGFyYW0gc3RvcmUgLSBUaGUgc3RvcmUgaW50ZXJmYWNlXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGZpbHRlciBmb3JcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgYWNjZXB0aW5nIGEgbWVzc2FnZSBhbmQgcmV0dXJuaW5nIGEgYm9vbGVhblxuICogQHBhcmFtIHR5cGUgLSBQcmUgZmlsdGVyZWQgYnkgYSBnaXZlbiBtZXNzYWdlIHR5cGVcbiAqL1xuZnVuY3Rpb24gZmlsdGVyTWVzc2FnZXMobWVzc2FnZVN0b3JlLCBzdG9yZSwgbm9kZSwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXNzYWdlU3RvcmUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VTdG9yZVtrZXldO1xuICAgICAgICBpZiAoKCF0eXBlIHx8IG1lc3NhZ2UudHlwZSA9PT0gdHlwZSkgJiYgIWNhbGxiYWNrKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICByZW1vdmVNZXNzYWdlKG1lc3NhZ2VTdG9yZSwgc3RvcmUsIG5vZGUsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJlZHVjZSB0aGUgbWVzc2FnZSBzdG9yZSB0byBzb21lIG90aGVyIGdlbmVyaWMgdmFsdWUuXG4gKiBAcGFyYW0gbWVzc2FnZVN0b3JlIC0gVGhlIHN0b3JlIGl0c2VsZlxuICogQHBhcmFtIF9zdG9yZSAtIFVudXNlZCBidXQgY3VycmllZCDigJQgdGhlIHN0b3JlIGludGVyZmFjZSBpdHNlbGZcbiAqIEBwYXJhbSBfbm9kZSAtIFRoZSBub2RlIG93bmVyIG9mIHRoaXMgc3RvcmVcbiAqIEBwYXJhbSByZWR1Y2VyIC0gVGhlIGNhbGxiYWNrIHRoYXQgcGVyZm9ybXMgdGhlIHJlZHVjdGlvblxuICogQHBhcmFtIGFjY3VtdWxhdG9yIC0gVGhlIGluaXRpYWwgdmFsdWVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZU1lc3NhZ2VzKG1lc3NhZ2VTdG9yZSwgX3N0b3JlLCBfbm9kZSwgcmVkdWNlciwgYWNjdW11bGF0b3IpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXNzYWdlU3RvcmUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VTdG9yZVtrZXldO1xuICAgICAgICBhY2N1bXVsYXRvciA9IHJlZHVjZXIoYWNjdW11bGF0b3IsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZVN0b3JlIC0gVGhlIHN0b3JlIGl0c2VsZlxuICogQHBhcmFtIF9zdG9yZSAtIFVudXNlZCBidXQgY3VycmllZCDigJQgdGhlIHN0b3JlIGludGVyZmFjZSBpdHNlbGZcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgb3duZXIgb2YgdGhpcyBzdG9yZVxuICogQHBhcmFtIG1lc3NhZ2VzIC0gQW4gYXJyYXkgb2YgRm9ybUtpdE1lc3NhZ2VzIHRvIGFwcGx5IHRvIHRoaXMgaW5wdXQsIG9yIGFuIG9iamVjdCBvZiBtZXNzYWdlcyB0byBhcHBseSB0byBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gYXBwbHlNZXNzYWdlcyhfbWVzc2FnZVN0b3JlLCBzdG9yZSwgbm9kZSwgbWVzc2FnZXMsIGNsZWFyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXMpKSB7XG4gICAgICAgIGlmIChzdG9yZS5idWZmZXIpIHtcbiAgICAgICAgICAgIHN0b3JlLl9iLnB1c2goW21lc3NhZ2VzLCBjbGVhcl0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBhcmUgYXBwbHlpbmcgbWVzc2FnZXMgdG8gdGhpcyBub2Rl4oCZcyBzdG9yZS5cbiAgICAgICAgY29uc3QgYXBwbGllZCA9IG5ldyBTZXQobWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5zZXQobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5rZXk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBtZXNzYWdlcyB0aGF0IHdlcmUgbm90IHBhcnQgb2YgdGhlIGluaXRpYWwgYXBwbHk6XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdG9yZS5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2UudHlwZSAhPT0gY2xlYXIgfHwgYXBwbGllZC5oYXMobWVzc2FnZS5rZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2xlYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0b3JlLmZpbHRlcigobWVzc2FnZSkgPT4gIWNsZWFyKG1lc3NhZ2UpIHx8IGFwcGxpZWQuaGFzKG1lc3NhZ2Uua2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBpbiBtZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmF0KGFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuc3RvcmUuYXBwbHkobWVzc2FnZXNbYWRkcmVzc10sIGNsZWFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pc3NlZChub2RlLCBzdG9yZSwgYWRkcmVzcywgbWVzc2FnZXNbYWRkcmVzc10sIGNsZWFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBtZXNzYWdlIGFycmF5cyBmcm9tIHN0cmluZ3MuXG4gKiBAcGFyYW0gZXJyb3JzIC0gQXJyYXlzIG9yIG9iamVjdHMgb2YgZm9ybSBlcnJvcnMgb3IgaW5wdXQgZXJyb3JzXG4gKiBAcmV0dXJuc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VzKG5vZGUsIC4uLmVycm9ycykge1xuICAgIGNvbnN0IHNvdXJjZUtleSA9IGAke25vZGUubmFtZX0tc2V0YDtcbiAgICBjb25zdCBtYWtlID0gKGVycm9yKSA9PiBjcmVhdGVNZXNzYWdlKHtcbiAgICAgICAga2V5OiBzbHVnaWZ5KGVycm9yKSxcbiAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgdmFsdWU6IGVycm9yLFxuICAgICAgICBtZXRhOiB7IHNvdXJjZTogc291cmNlS2V5LCBhdXRvQ2xlYXI6IHRydWUgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICEhbSlcbiAgICAgICAgLm1hcCgoZXJyb3JTZXQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvclNldCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICBlcnJvclNldCA9IFtlcnJvclNldF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9yU2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yU2V0Lm1hcCgoZXJyb3IpID0+IG1ha2UoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZXJyb3JTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlcnJvclNldFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnNba2V5XSA9IGVycm9yU2V0W2tleV0ubWFwKChlcnJvcikgPT4gbWFrZShlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzW2tleV0gPSBbbWFrZShlcnJvclNldFtrZXldKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHN0b3JlIC0gVGhlIHN0b3JlIHRvIGFwcGx5IHRoaXMgbWlzc2VkIGFwcGxpY2F0aW9ucy5cbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdGhhdCB3YXMgbWlzc2VkIChhIG5vZGUgcGF0aCB0aGF0IGRpZG4ndCB5ZXQgZXhpc3QpXG4gKiBAcGFyYW0gbWVzc2FnZXMgLSBUaGUgbWVzc2FnZXMgdGhhdCBzaG91bGQgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gKiBAcGFyYW0gY2xlYXIgLSBUaGUgY2xlYXJpbmcgZnVuY3Rpb24gKGlmIGFueSlcbiAqL1xuZnVuY3Rpb24gbWlzc2VkKG5vZGUsIHN0b3JlLCBhZGRyZXNzLCBtZXNzYWdlcywgY2xlYXIpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWlzc2VzID0gc3RvcmUuX207XG4gICAgaWYgKCFtaXNzZXMuaGFzKGFkZHJlc3MpKVxuICAgICAgICBtaXNzZXMuc2V0KGFkZHJlc3MsIFtdKTtcbiAgICAvLyBUaGUgY3JlYXRlZCByZWNlaXB0XG4gICAgaWYgKCFzdG9yZS5fcilcbiAgICAgICAgc3RvcmUuX3IgPSByZWxlYXNlTWlzc2VkKG5vZGUsIHN0b3JlKTtcbiAgICAoX2EgPSBtaXNzZXMuZ2V0KGFkZHJlc3MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChbbWVzc2FnZXMsIGNsZWFyXSk7XG59XG4vKipcbiAqIFJlbGVhc2VzIG1lc3NhZ2VzIHRoYXQgd2VyZSBhcHBsaWVkIHRvIGEgY2hpbGQgdmlhIHBhcmVudCwgYnV0IHRoZSBjaGlsZCBkaWRcbiAqIG5vdCBleGlzdC4gT25jZSB0aGUgY2hpbGQgZG9lcyBleGlzdCwgdGhlIGNyZWF0ZWQgZXZlbnQgZm9yIHRoYXQgY2hpbGQgd2lsbFxuICogYnViYmxlIHRvIHRoaXMgcG9pbnQsIGFuZCBhbnkgc3RvcmVkIGFwcGxpY2F0aW9ucyB3aWxsIGJlIGFwcGxpZWQgc2VyaWFsbHkuXG4gKiBAcGFyYW0gc3RvcmUgLSBUaGUgc3RvcmUgb2JqZWN0LlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcmVsZWFzZU1pc3NlZChub2RlLCBzdG9yZSkge1xuICAgIHJldHVybiBub2RlLm9uKCdjaGlsZC5kZWVwJywgKHsgcGF5bG9hZDogY2hpbGQgfSkgPT4ge1xuICAgICAgICBzdG9yZS5fbS5mb3JFYWNoKChtaXNzZXMsIGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLmF0KGFkZHJlc3MpID09PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgIG1pc3Nlcy5mb3JFYWNoKChbbWVzc2FnZXMsIGNsZWFyXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zdG9yZS5hcHBseShtZXNzYWdlcywgY2xlYXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0b3JlLl9tLmRlbGV0ZShhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIGFsbCB0aGUgc3RvcmVkIG1pc3NlcyB3ZXJlIGFwcGxpZWQsIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAgICAgIGlmIChzdG9yZS5fbS5zaXplID09PSAwICYmIHN0b3JlLl9yKSB7XG4gICAgICAgICAgICBub2RlLm9mZihzdG9yZS5fcik7XG4gICAgICAgICAgICBzdG9yZS5fciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGFsbCBidWZmZXJlZCBtZXNzYWdlcyBhbmQgYXBwbGllcyB0aGVtIGluIHNlcXVlbmNlLlxuICogQHBhcmFtIG1lc3NhZ2VTdG9yZSAtIFRoZSBzdG9yZSBpdHNlbGZcbiAqIEBwYXJhbSBzdG9yZSAtIFRoZSBzdG9yZSBpbnRlcmZhY2VcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gZmlsdGVyIGZvclxuICovXG5mdW5jdGlvbiByZWxlYXNlQnVmZmVyKF9tZXNzYWdlU3RvcmUsIHN0b3JlKSB7XG4gICAgc3RvcmUuYnVmZmVyID0gZmFsc2U7XG4gICAgc3RvcmUuX2IuZm9yRWFjaCgoW21lc3NhZ2VzLCBjbGVhcl0pID0+IHN0b3JlLmFwcGx5KG1lc3NhZ2VzLCBjbGVhcikpO1xuICAgIHN0b3JlLl9iID0gW107XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsZWRnZXIgZm9yIHVzZSBvbiBhIHNpbmdsZSBub2RlJ3MgY29udGV4dC5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxlZGdlcigpIHtcbiAgICBjb25zdCBsZWRnZXIgPSB7fTtcbiAgICBsZXQgbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb3VudDogKC4uLmFyZ3MpID0+IGNyZWF0ZUNvdW50ZXIobiwgbGVkZ2VyLCAuLi5hcmdzKSxcbiAgICAgICAgaW5pdChub2RlKSB7XG4gICAgICAgICAgICBuID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUub24oJ21lc3NhZ2UtYWRkZWQuZGVlcCcsIGFkZChsZWRnZXIsIDEpKTtcbiAgICAgICAgICAgIG5vZGUub24oJ21lc3NhZ2UtcmVtb3ZlZC5kZWVwJywgYWRkKGxlZGdlciwgLTEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVyZ2U6IChjaGlsZCkgPT4gbWVyZ2UobiwgbGVkZ2VyLCBjaGlsZCksXG4gICAgICAgIHNldHRsZWQoY291bnRlck5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXMobGVkZ2VyLCBjb3VudGVyTmFtZSlcbiAgICAgICAgICAgICAgICA/IGxlZGdlcltjb3VudGVyTmFtZV0ucHJvbWlzZVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVubWVyZ2U6IChjaGlsZCkgPT4gbWVyZ2UobiwgbGVkZ2VyLCBjaGlsZCwgdHJ1ZSksXG4gICAgICAgIHZhbHVlKGNvdW50ZXJOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzKGxlZGdlciwgY291bnRlck5hbWUpID8gbGVkZ2VyW2NvdW50ZXJOYW1lXS5jb3VudCA6IDA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjb3VudGVyIG9iamVjdCBpbiB0aGUgY291bnRpbmcgbGVkZ2VyLlxuICogQHBhcmFtIGxlZGdlciAtIFRoZSBhY3R1YWwgbGVkZ2VyIHN0b3JhZ2Ugb2JqZWN0XG4gKiBAcGFyYW0gY291bnRlck5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY291bnRlciwgY2FuIGJlIGFyYml0cmFyeVxuICogQHBhcmFtIGNvbmRpdGlvbiAtIFRoZSBjb25kaXRpb24gZnVuY3Rpb24gKG9yIHN0cmluZykgdGhhdCBmaWx0ZXJzIG1lc3NhZ2VzXG4gKiBAcGFyYW0gaW5pdGlhbFZhbHVlIC0gVGhlIGluaXRpYWwgY291bnRlciB2YWx1ZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ291bnRlcihub2RlLCBsZWRnZXIsIGNvdW50ZXJOYW1lLCBjb25kaXRpb24sIGluY3JlbWVudCA9IDApIHtcbiAgICBjb25kaXRpb24gPSBwYXJzZUNvbmRpdGlvbihjb25kaXRpb24gfHwgY291bnRlck5hbWUpO1xuICAgIGlmICghaGFzKGxlZGdlciwgY291bnRlck5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSB7XG4gICAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIG5hbWU6IGNvdW50ZXJOYW1lLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgICAgICAgcmVzb2x2ZTogKCkgPT4geyB9LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgICAgICB9O1xuICAgICAgICBsZWRnZXJbY291bnRlck5hbWVdID0gY291bnRlcjtcbiAgICAgICAgaW5jcmVtZW50ID0gbm9kZS5zdG9yZS5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgY291bnRlci5jb25kaXRpb24obSkgKiAxLCBpbmNyZW1lbnQpO1xuICAgICAgICBub2RlLmVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBjaGlsZC5sZWRnZXIuY291bnQoY291bnRlci5uYW1lLCBjb3VudGVyLmNvbmRpdGlvbik7XG4gICAgICAgICAgICBpbmNyZW1lbnQgKz0gY2hpbGQubGVkZ2VyLnZhbHVlKGNvdW50ZXIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQobGVkZ2VyW2NvdW50ZXJOYW1lXSwgaW5jcmVtZW50KS5wcm9taXNlO1xufVxuLyoqXG4gKiBXZSBwYXJzZSB0aGUgY29uZGl0aW9uIHRvIGFsbG93IGZsZXhpYmlsaXR5IGluIGhvdyBjb3VudGVycyBhcmUgc3BlY2lmaWVkLlxuICogQHBhcmFtIGNvbmRpdGlvbiAtIFRoZSBjb25kaXRpb24gdGhhdCwgaWYgdHJ1ZSwgYWxsb3dzIGEgbWVzc2FnZSB0byBjaGFuZ2UgYSBjb3VudGVyJ3MgdmFsdWVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uKGNvbmRpdGlvbikge1xuICAgIGlmICh0eXBlb2YgY29uZGl0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjb25kaXRpb247XG4gICAgfVxuICAgIHJldHVybiAobSkgPT4gbS50eXBlID09PSBjb25kaXRpb247XG59XG4vKipcbiAqIFBlcmZvcm0gYSBjb3VudGluZyBhY3Rpb24gb24gdGhlIGEgZ2l2ZW4gY291bnRlciBvYmplY3Qgb2YgdGhlIGxlZGdlci5cbiAqIEBwYXJhbSBjb3VudGVyIC0gQSBjb3VudGVyIG9iamVjdFxuICogQHBhcmFtIGluY3JlbWVudCAtIFRoZSBhbW91bnQgYnkgd2hpY2ggd2UgYXJlIGNoYW5naW5nIHRoZSBjb3VudCB2YWx1ZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gY291bnQoY291bnRlciwgaW5jcmVtZW50KSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IGNvdW50ZXIuY291bnQ7XG4gICAgY29uc3QgcG9zdCA9IGNvdW50ZXIuY291bnQgKyBpbmNyZW1lbnQ7XG4gICAgY291bnRlci5jb3VudCA9IHBvc3Q7XG4gICAgaWYgKGluaXRpYWwgPT09IDAgJiYgcG9zdCAhPT0gMCkge1xuICAgICAgICBjb3VudGVyLm5vZGUuZW1pdChgdW5zZXR0bGVkOiR7Y291bnRlci5uYW1lfWAsIGNvdW50ZXIuY291bnQsIGZhbHNlKTtcbiAgICAgICAgY291bnRlci5wcm9taXNlID0gbmV3IFByb21pc2UoKHIpID0+IChjb3VudGVyLnJlc29sdmUgPSByKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGluaXRpYWwgIT09IDAgJiYgcG9zdCA9PT0gMCkge1xuICAgICAgICBjb3VudGVyLm5vZGUuZW1pdChgc2V0dGxlZDoke2NvdW50ZXIubmFtZX1gLCBjb3VudGVyLmNvdW50LCBmYWxzZSk7XG4gICAgICAgIGNvdW50ZXIucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb3VudGVyLm5vZGUuZW1pdChgY291bnQ6JHtjb3VudGVyLm5hbWV9YCwgY291bnRlci5jb3VudCwgZmFsc2UpO1xuICAgIHJldHVybiBjb3VudGVyO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBhcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgbWVzc2FnZSBldmVudHMuXG4gKiBAcGFyYW0gbGVkZ2VyIC0gQSBsZWRnZXIgdG8gb3BlcmF0ZSBvblxuICogQHBhcmFtIGRlbHRhIC0gVGhlIGFtb3VudCB0byBhZGQgb3Igc3VidHJhY3RcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGFkZChsZWRnZXIsIGRlbHRhKSB7XG4gICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBsZWRnZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXIgPSBsZWRnZXJbbmFtZV07XG4gICAgICAgICAgICBpZiAoY291bnRlci5jb25kaXRpb24oZS5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIGNvdW50KGNvdW50ZXIsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEdpdmVuIGEgY2hpbGQgbm9kZSwgYWRkIHRoZSBwYXJlbnQgbm9kZSdzIGNvdW50ZXJzIHRvIHRoZSBjaGlsZCBhbmQgdGhlblxuICogcmVjdGlmeSB0aGUgdXBzdHJlYW0gbGVkZ2VyIGNvdW50cy4gR2VuZXJhbGx5IHVzZWQgd2hlbiBhdHRhY2hpbmcgYSBjaGlsZFxuICogdG8gYW4gYWxyZWFkeSBjb3VudGVkIHRyZWUuXG4gKiBAcGFyYW0gcGFyZW50IC0gVGhlIHBhcmVudCB0aGF0IGlzIFwicmVjZWl2aW5nXCIgdGhlIGNoaWxkXG4gKiBAcGFyYW0gbGVkZ2VyIC0gVGhlIGxlZGdlciBvYmplY3RcbiAqIEBwYXJhbSBjaGlsZCAtIFRoZSBjaGlsZCAoY2FuIGJlIGEgc3VidHJlZSkgdGhhdCBpcyBiZWluZyBhdHRhY2hlZFxuICovXG5mdW5jdGlvbiBtZXJnZShwYXJlbnQsIGxlZGdlciwgY2hpbGQsIHJlbW92ZSA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbGVkZ2VyKSB7XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGxlZGdlcltrZXldLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKCFyZW1vdmUpXG4gICAgICAgICAgICBjaGlsZC5sZWRnZXIuY291bnQoa2V5LCBjb25kaXRpb24pO1xuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBjaGlsZC5sZWRnZXIudmFsdWUoa2V5KSAqIChyZW1vdmUgPyAtMSA6IDEpO1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwYXJlbnQubGVkZ2VyLmNvdW50KGtleSwgY29uZGl0aW9uLCBpbmNyZW1lbnQpO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfSB3aGlsZSAocGFyZW50KTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBnbG9iYWwgcmVnaXN0cnkgb2Ygbm9kZXMgYnkgdGhlaXIgYWxpYXMgb3IgbmFtZSAoaWYgcm9vdCkuXG4gKi9cbmNvbnN0IHJlZ2lzdHJ5ID0gbmV3IE1hcCgpO1xuY29uc3QgcmVmbGVjdGVkID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBBbiBldmVudCBlbWl0dGVyIGZvciByZWdpc3RlcmVkL3NldC91bnNldCBub2Rlc1xuICovXG5jb25zdCBlbWl0ID0gY3JlYXRlRW1pdHRlcigpO1xuLyoqXG4gKiBSZWNlaXB0cyBvZiBsaXN0ZW5lcnMuXG4gKi9cbmNvbnN0IHJlY2VpcHRzID0gW107XG4vKipcbiAqIFJlZ2lzdGVycyBhIG5vZGUgdG8gdGhlIHJlZ2lzdHJ5IF9pZl8gdGhlIG5vZGUgaXMgYSByb290IG5vZGUsIF9vcl8gaWYgdGhlXG4gKiBub2RlIGhhcyBhbiBleHBsaWNpdCBub2RlLnByb3BzLmFsaWFzLiBJZiB0aGVzZSB0d28gdGhpbmdzIGFyZSBub3QgdHJ1ZVxuICogdGhlbiBubyBub2RlIGlzIHJlZ2lzdGVyZWQgKGlkZW1wb3RlbnQpLlxuICpcbiAqIEBwYXJhbSBub2RlIC0gQSBub2RlIHRvIHJlZ2lzdGVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUpIHtcbiAgICBpZiAobm9kZS5wcm9wcy5pZCkge1xuICAgICAgICByZWdpc3RyeS5zZXQobm9kZS5wcm9wcy5pZCwgbm9kZSk7XG4gICAgICAgIHJlZmxlY3RlZC5zZXQobm9kZSwgbm9kZS5wcm9wcy5pZCk7XG4gICAgICAgIGVtaXQobm9kZSwge1xuICAgICAgICAgICAgcGF5bG9hZDogbm9kZSxcbiAgICAgICAgICAgIG5hbWU6IG5vZGUucHJvcHMuaWQsXG4gICAgICAgICAgICBidWJibGU6IGZhbHNlLFxuICAgICAgICAgICAgb3JpZ2luOiBub2RlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIERlcmVnaXN0ZXIgYSBub2RlIGZyb20gdGhlIHJlZ2lzdHJ5LlxuICogQHBhcmFtIG5vZGUgLSBBIG5vZGUgdG8gcmVtb3ZlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSkge1xuICAgIGlmIChyZWZsZWN0ZWQuaGFzKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGlkID0gcmVmbGVjdGVkLmdldChub2RlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHJlZmxlY3RlZC5kZWxldGUobm9kZSk7XG4gICAgICAgIHJlZ2lzdHJ5LmRlbGV0ZShpZCk7XG4gICAgICAgIGVtaXQobm9kZSwge1xuICAgICAgICAgICAgcGF5bG9hZDogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IGlkLFxuICAgICAgICAgICAgYnViYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIG9yaWdpbjogbm9kZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBHZXQgYSBub2RlIGJ5IGEgcGFydGljdWxhciBpZC5cbiAqIEBwYXJhbSBub2RlIC0gR2V0IGEgbm9kZSBieSBhIGdpdmVuIGlkXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGUkMShpZCkge1xuICAgIHJldHVybiByZWdpc3RyeS5nZXQoaWQpO1xufVxuLyoqXG4gKiBSZXNldCB0aGUgZW50aXJlIHJlZ2lzdHJ5LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiByZXNldFJlZ2lzdHJ5KCkge1xuICAgIHJlZ2lzdHJ5LmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgZGVyZWdpc3Rlcihub2RlKTtcbiAgICB9KTtcbiAgICByZWNlaXB0cy5mb3JFYWNoKChyZWNlaXB0KSA9PiBlbWl0Lm9mZihyZWNlaXB0KSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gaWQgLSBBbiBpZCB0byB3YXRjaFxuICogQHBhcmFtIGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBub3RpZnkgd2hlbiB0aGUgbm9kZSBpcyBzZXQgb3IgcmVtb3ZlZC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gd2F0Y2hSZWdpc3RyeShpZCwgY2FsbGJhY2spIHtcbiAgICAvLyByZWdpc3RlciBhIGxpc3RlbmVyXG4gICAgcmVjZWlwdHMucHVzaChlbWl0Lm9uKGlkLCBjYWxsYmFjaykpO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgYSBnaXZlbiBjb25maWcgY2hhbmdlIHRvIHRoZSBub2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBjaGVjayBmb3IgY29uZmlnIGNoYW5nZVxuICogQHBhcmFtIHByb3AgLSBDaGVja3MgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgaW4gdGhlIGxvY2FsIGNvbmZpZyBvciBwcm9wc1xuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ0NoYW5nZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIC8vIFdoZW4gd2UgcmV0dXJuIGZhbHNlLCBub2RlLndhbGsgd2lsbCBub3QgY29udGludWUgaW50byB0aGF0IGNoaWxkLlxuICAgIGxldCB1c2luZ0ZhbGxiYWNrID0gdHJ1ZTtcbiAgICAhKHByb3AgaW4gbm9kZS5jb25maWcuX3QpXG4gICAgICAgID8gbm9kZS5lbWl0KGBjb25maWc6JHtwcm9wfWAsIHZhbHVlLCBmYWxzZSlcbiAgICAgICAgOiAodXNpbmdGYWxsYmFjayA9IGZhbHNlKTtcbiAgICBpZiAoIShwcm9wIGluIG5vZGUucHJvcHMpKSB7XG4gICAgICAgIG5vZGUuZW1pdCgncHJvcCcsIHsgcHJvcCwgdmFsdWUgfSk7XG4gICAgICAgIG5vZGUuZW1pdChgcHJvcDoke3Byb3B9YCwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdXNpbmdGYWxsYmFjaztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIGdsb2JhbCBjb25maWd1cmF0aW9uIG9wdGlvbi4gVGhpcyBvYmplY3QgaXNcbiAqIGVzc2VudGlhbGx5IGp1c3QgYSBGb3JtS2l0T3B0aW9uIG9iamVjdCwgYnV0IGl0IGNhbiBiZSB1c2VkIGFzIHRoZSByb290IGZvclxuICogRm9ybUtpdENvbmZpZydzIHByb3h5IGFuZCByZXRhaW4gZXZlbnQgXCJlbWl0dGluZ1wiLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gRm9ybUtpdCBub2RlIG9wdGlvbnMgdG8gYmUgdXNlZCBnbG9iYWxseS5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29uZmlnJDEob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgbm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdGFyZ2V0ID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi57XG4gICAgICAgICAgICBfYWRkOiAobm9kZSkgPT4gbm9kZXMuYWRkKG5vZGUpLFxuICAgICAgICAgICAgX3JtOiAobm9kZSkgPT4gbm9kZS5yZW1vdmUobm9kZSksXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCByb290Q29uZmlnID0gbmV3IFByb3h5KHRhcmdldCwge1xuICAgICAgICBzZXQodCwgcHJvcCwgdmFsdWUsIHIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiBjb25maWdDaGFuZ2Uobm9kZSwgcHJvcCwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0LCBwcm9wLCB2YWx1ZSwgcik7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJvb3RDb25maWc7XG59XG5cbi8qKlxuICogU3VibWl0cyBhIEZvcm1LaXQgZm9ybSBwcm9ncmFtbWF0aWNhbGx5LlxuICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBmb3JtXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHN1Ym1pdEZvcm0oaWQpIHtcbiAgICBjb25zdCBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICBpZiAoZm9ybUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ3N1Ym1pdCcsIHsgY2FuY2VsYWJsZTogdHJ1ZSwgYnViYmxlczogdHJ1ZSB9KTtcbiAgICAgICAgZm9ybUVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybigxNTEsIGlkKTtcbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgc3RhdGUgYW5kIGVycm9yIG1lc3NhZ2VzLlxuICovXG5mdW5jdGlvbiBjbGVhclN0YXRlKG5vZGUpIHtcbiAgICBjb25zdCBjbGVhciA9IChuKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG4uc3RvcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuLnN0b3JlW2tleV07XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAnZXJyb3InIHx8XG4gICAgICAgICAgICAgICAgKG1lc3NhZ2UudHlwZSA9PT0gJ3VpJyAmJiBrZXkgPT09ICdpbmNvbXBsZXRlJykpIHtcbiAgICAgICAgICAgICAgICBuLnN0b3JlLnJlbW92ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSAnc3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgbi5zdG9yZS5zZXQoeyAuLi5tZXNzYWdlLCB2YWx1ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNsZWFyKG5vZGUpO1xuICAgIG5vZGUud2FsayhjbGVhcik7XG59XG4vKipcbiAqIFJlc2V0cyBhbiBpbnB1dCB0byBpdOKAmXMgXCJpbml0aWFsXCIgdmFsdWUg4oCUIGlmIHRoZSBpbnB1dCBpcyBhIGdyb3VwIG9yIGxpc3QgaXRcbiAqIHJlc2V0cyBhbGwgdGhlIGNoaWxkcmVuIGFzIHdlbGwuXG4gKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgYW4gaW5wdXQgdG8gcmVzZXRcbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHJlc2V0KGlkLCByZXNldFRvKSB7XG4gICAgY29uc3Qgbm9kZSA9IHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBnZXROb2RlJDEoaWQpIDogaWQ7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbCA9IChuKSA9PiBjbG9uZUFueShuLnByb3BzLmluaXRpYWwpIHx8XG4gICAgICAgICAgICAobi50eXBlID09PSAnZ3JvdXAnID8ge30gOiBuLnR5cGUgPT09ICdsaXN0JyA/IFtdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgLy8gcGF1c2UgYWxsIGV2ZW50cyBpbiB0aGlzIHRyZWUuXG4gICAgICAgIG5vZGUuX2UucGF1c2Uobm9kZSk7XG4gICAgICAgIC8vIFNldCBpdCBiYWNrIHRvIGJhc2ljc1xuICAgICAgICBub2RlLmlucHV0KGNsb25lQW55KHJlc2V0VG8pIHx8IGluaXRpYWwobm9kZSksIGZhbHNlKTtcbiAgICAgICAgLy8gU2V0IGNoaWxkcmVuIGJhY2sgdG8gYmFzaWNzIGluIGNhc2UgdGhleSB3ZXJlIGFkZGl0aXZlIChoYWQgdGhlaXIgb3duIHZhbHVlIGZvciBleGFtcGxlKVxuICAgICAgICBub2RlLndhbGsoKGNoaWxkKSA9PiBjaGlsZC5pbnB1dChpbml0aWFsKGNoaWxkKSwgZmFsc2UpKTtcbiAgICAgICAgLy8gRmluYWxseSB3ZSBuZWVkIHRvIGxheSBhbnkgdmFsdWVzIGJhY2sgb24gdG9wIChpZiBpdCBpcyBhIGdyb3VwL2xpc3QpIHNpbmNlIGdyb3VwIHZhbHVlc1xuICAgICAgICAvLyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBjaGlsZCB2YWx1ZXMuXG4gICAgICAgIGNvbnN0IGZpbmFsSW5pdCA9IGluaXRpYWwobm9kZSk7XG4gICAgICAgIG5vZGUuaW5wdXQodHlwZW9mIGZpbmFsSW5pdCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gY2xvbmVBbnkocmVzZXRUbykgfHwgaW5pdChmaW5hbEluaXQpXG4gICAgICAgICAgICA6IGZpbmFsSW5pdCwgZmFsc2UpO1xuICAgICAgICAvLyByZWxlYXNlIHRoZSBldmVudHMuXG4gICAgICAgIG5vZGUuX2UucGxheShub2RlKTtcbiAgICAgICAgY2xlYXJTdGF0ZShub2RlKTtcbiAgICAgICAgbm9kZS5lbWl0KCdyZXNldCcsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgd2FybigxNTIsIGlkKTtcbiAgICByZXR1cm47XG59XG5cbi8qKlxuICogRGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgZGVsaW1pdGVyOiAnLicsXG4gICAgZGVsYXk6IDAsXG4gICAgbG9jYWxlOiAnZW4nLFxuICAgIHJvb3RDbGFzc2VzOiAoa2V5KSA9PiAoeyBbYGZvcm1raXQtJHtrZWJhYihrZXkpfWBdOiB0cnVlIH0pLFxufTtcbi8qKlxuICogSWYgYSBub2Rl4oCZcyBuYW1lIGlzIHNldCB0byB1c2VJbmRleCwgaXQgcmVwbGFjZXMgdGhlIG5vZGXigJlzIG5hbWUgd2l0aCB0aGVcbiAqIGluZGV4IG9mIHRoZSBub2RlIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnTigJlzIGNoaWxkcmVuLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB1c2VJbmRleCA9IFN5bWJvbCgnaW5kZXgnKTtcbi8qKlxuICogV2hlbiBwcm9wYWdhdGluZyB2YWx1ZXMgdXAgYSB0cmVlLCB0aGlzIHZhbHVlIGluZGljYXRlcyB0aGUgY2hpbGQgc2hvdWxkIGJlXG4gKiByZW1vdmVkLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB2YWx1ZVJlbW92ZWQgPSBTeW1ib2woJ3JlbW92ZWQnKTtcbi8qKlxuICogV2hlbiBwcm9wYWdhdGluZyB2YWx1ZXMgdXAgYSB0cmVlLCB0aGlzIHZhbHVlIGluZGljYXRlcyB0aGUgY2hpbGQgc2hvdWxkIGJlXG4gKiBtb3ZlZC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsdWVNb3ZlZCA9IFN5bWJvbCgnbW92ZWQnKTtcbi8qKlxuICogV2hlbiBjcmVhdGluZyBhIG5ldyBub2RlIGFuZCBoYXZpbmcgaXRzIHZhbHVlIGluamVjdGVkIGRpcmVjdGx5IGF0IGEgc3BlY2lmaWNcbiAqIGxvY2F0aW9uLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB2YWx1ZUluc2VydGVkID0gU3ltYm9sKCdpbnNlcnRlZCcpO1xuLyoqXG4gKiBBIHNpbXBsZSB0eXBlIGd1YXJkIHRvIGRldGVybWluZSBpZiB0aGUgY29udGV4dCBiZWluZyBldmFsdWF0ZWQgaXMgYSBsaXN0XG4gKiB0eXBlLlxuICogQHBhcmFtIGFyZyAtXG4gKiBAcmV0dXJucyBhcmcgaXMgRm9ybUtpdExpc3RDb250ZXh0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzTGlzdChhcmcpIHtcbiAgICByZXR1cm4gYXJnLnR5cGUgPT09ICdsaXN0JyAmJiBBcnJheS5pc0FycmF5KGFyZy5fdmFsdWUpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBnaXZlbiBvYmplY3QgaXMgYSBub2RlXG4gKiBAcHVibGljXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlLl9fRktOb2RlX18gPT09IHRydWU7XG59XG4vKipcbiAqIFRoZSBzZXR0ZXIgeW91IGFyZSB0cnlpbmcgdG8gYWNjZXNzIGlzIGludmFsaWQuXG4gKi9cbmNvbnN0IGludmFsaWRTZXR0ZXIgPSAobm9kZSwgX2NvbnRleHQsIHByb3BlcnR5KSA9PiB7XG4gICAgZXJyb3IoMTAyLCBbbm9kZSwgcHJvcGVydHldKTtcbn07XG5jb25zdCB0cmFwcyA9IHtcbiAgICBfYzogdHJhcChnZXRDb250ZXh0LCBpbnZhbGlkU2V0dGVyLCBmYWxzZSksXG4gICAgYWRkOiB0cmFwKGFkZENoaWxkKSxcbiAgICBhZGRQcm9wczogdHJhcChhZGRQcm9wcyksXG4gICAgYWRkcmVzczogdHJhcChnZXRBZGRyZXNzLCBpbnZhbGlkU2V0dGVyLCBmYWxzZSksXG4gICAgYXQ6IHRyYXAoZ2V0Tm9kZSksXG4gICAgYnViYmxlOiB0cmFwKGJ1YmJsZSksXG4gICAgY2xlYXJFcnJvcnM6IHRyYXAoY2xlYXJFcnJvcnMkMSksXG4gICAgY2FsbTogdHJhcChjYWxtKSxcbiAgICBjb25maWc6IHRyYXAoZmFsc2UpLFxuICAgIGRlZmluZTogdHJhcChkZWZpbmUpLFxuICAgIGRpc3R1cmI6IHRyYXAoZGlzdHVyYiksXG4gICAgZGVzdHJveTogdHJhcChkZXN0cm95KSxcbiAgICBoeWRyYXRlOiB0cmFwKGh5ZHJhdGUpLFxuICAgIGluZGV4OiB0cmFwKGdldEluZGV4LCBzZXRJbmRleCwgZmFsc2UpLFxuICAgIGlucHV0OiB0cmFwKGlucHV0KSxcbiAgICBlYWNoOiB0cmFwKGVhY2hDaGlsZCksXG4gICAgZW1pdDogdHJhcChlbWl0JDEpLFxuICAgIGZpbmQ6IHRyYXAoZmluZCksXG4gICAgb246IHRyYXAob24pLFxuICAgIG9mZjogdHJhcChvZmYpLFxuICAgIHBhcmVudDogdHJhcChmYWxzZSwgc2V0UGFyZW50KSxcbiAgICBwbHVnaW5zOiB0cmFwKGZhbHNlKSxcbiAgICByZW1vdmU6IHRyYXAocmVtb3ZlQ2hpbGQpLFxuICAgIHJvb3Q6IHRyYXAoZ2V0Um9vdCwgaW52YWxpZFNldHRlciwgZmFsc2UpLFxuICAgIHJlc2V0OiB0cmFwKHJlc2V0VmFsdWUpLFxuICAgIHJlc2V0Q29uZmlnOiB0cmFwKHJlc2V0Q29uZmlnKSxcbiAgICBzZXRFcnJvcnM6IHRyYXAoc2V0RXJyb3JzJDEpLFxuICAgIHN1Ym1pdDogdHJhcChzdWJtaXQpLFxuICAgIHQ6IHRyYXAodGV4dCksXG4gICAgdXNlOiB0cmFwKHVzZSksXG4gICAgbmFtZTogdHJhcChnZXROYW1lLCBmYWxzZSwgZmFsc2UpLFxuICAgIHdhbGs6IHRyYXAod2Fsa1RyZWUpLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgYXZhaWxhYmxlIFwidHJhcHNcIiBmb3IgYSBnaXZlbiBub2RlLiBZb3UgY2FuIHRoaW5rIG9mIHRoZXNlXG4gKiBhIGxpdHRsZSBiaXQgbGlrZSBtZXRob2RzLCBidXQgdGhleSBhcmUgcmVhbGx5IFByb3h5IGludGVyY2VwdG9ycy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhcHMoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmVudHJpZXModHJhcHMpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGdldHRlci9zZXR0ZXIgdHJhcCBhbmQgY3VycmllcyB0aGUgY29udGV4dC9ub2RlIHBhaXJcbiAqIEBwYXJhbSBnZXR0ZXIgLSBUaGUgZ2V0dGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gc2V0dGVyIC0gVGhlIHNldHRlciBmdW5jdGlvblxuICogQHBhcmFtIGN1cnJ5R2V0dGVyIC0gSW5kaWNhdGVzIGlmIHRoZSBnZXR0ZXIgc2hvdWxkIGJlIGN1cnJpZWQgb3Igbm90XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0cmFwKGdldHRlciwgc2V0dGVyLCBjdXJyeUdldHRlciA9IHRydWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGdldHRlclxuICAgICAgICAgICAgPyAobm9kZSwgY29udGV4dCkgPT4gY3VycnlHZXR0ZXJcbiAgICAgICAgICAgICAgICA/ICguLi5hcmdzKSA9PiBnZXR0ZXIobm9kZSwgY29udGV4dCwgLi4uYXJncylcbiAgICAgICAgICAgICAgICA6IGdldHRlcihub2RlLCBjb250ZXh0KVxuICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgc2V0OiBzZXR0ZXIgIT09IHVuZGVmaW5lZCA/IHNldHRlciA6IGludmFsaWRTZXR0ZXIuYmluZChudWxsKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYWxsIG9mIHRoZSBub2RlJ3MgaG9vayBkaXNwYXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSG9va3MoKSB7XG4gICAgY29uc3QgaG9va3MgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIG5ldyBQcm94eShob29rcywge1xuICAgICAgICBnZXQoXywgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmICghaG9va3MuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGhvb2tzLnNldChwcm9wZXJ0eSwgY3JlYXRlRGlzcGF0Y2hlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob29rcy5nZXQocHJvcGVydHkpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGlzIGlzIGEgc2ltcGxlIGludGVnZXIgY291bnRlciBvZiBldmVyeSBjcmVhdGVOYW1lKCkgd2hlcmUgdGhlIG5hbWUgbmVlZHNcbiAqIHRvIGJlIGdlbmVyYXRlZC5cbiAqL1xubGV0IG5hbWVDb3VudCA9IDA7XG4vKipcbiAqIFRoaXMgaXMgYSBzaW1wbGUgaW50ZWdlciBjb3VudGVyIG9mIGV2ZXJ5IGRlZmF1bHQgaWQgY3JlYXRlZC5cbiAqL1xubGV0IGlkQ291bnQgPSAwO1xuLyoqXG4gKiBSZXBvcnRzIHRoZSBnbG9iYWwgbnVtYmVyIG9mIG5vZGUgcmVnaXN0cmF0aW9ucywgdXNlZnVsIGZvciBkZXRlcm1pbmlzdGljXG4gKiBub2RlIG5hbWluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcmVzZXRDb3VudCgpIHtcbiAgICBuYW1lQ291bnQgPSAwO1xuICAgIGlkQ291bnQgPSAwO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuYW1lIGJhc2VkIGRpY3Rpb25hcnkgb2YgYWxsIGNoaWxkcmVuIGluIGFuIGFycmF5LlxuICogQHBhcmFtIGNoaWxkcmVuIC1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbmFtZXMoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKChuYW1lZCwgY2hpbGQpID0+IE9iamVjdC5hc3NpZ24obmFtZWQsIHsgW2NoaWxkLm5hbWVdOiBjaGlsZCB9KSwge30pO1xufVxuLyoqXG4gKiBUaGlzIG5vZGUgaXMgcmVzcG9uc2libGUgZm9yIGRldGVybWluaXN0aWNhbGx5IGdlbmVyYXRpbmcgYW4gaWQgZm9yIHRoaXNcbiAqIG5vZGUuIFRoaXMgY2Fubm90IGp1c3QgYmUgYSByYW5kb20gaWQsIGl0IF9tdXN0XyBiZSBkZXRlcm1pbmlzdGljIHRvIGVuc3VyZVxuICogcmUtaHlkcmF0aW9uIG9mIHRoZSBmb3JtIChsaWtlIHBvc3QtU1NSKSBwcm9kdWNlcyB0aGUgc2FtZSBuYW1lcy9pZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLVxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5hbWUob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCgoX2EgPSBvcHRpb25zLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnbGlzdCcpXG4gICAgICAgIHJldHVybiB1c2VJbmRleDtcbiAgICByZXR1cm4gb3B0aW9ucy5uYW1lIHx8IGAkeygoX2IgPSBvcHRpb25zLnByb3BzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHlwZSkgfHwgJ2lucHV0J31fJHsrK25hbWVDb3VudH1gO1xufVxuLyoqXG4gKiBDcmVhdGVzIHRoZSBpbml0aWFsIHZhbHVlIGZvciBhIG5vZGUgYmFzZWQgb24gdGhlIG9wdGlvbnMgcGFzc2VkIGluIGFuZCB0aGVcbiAqIHR5cGUgb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIG9wdGlvbnMgLVxuICogQHBhcmFtIHR5cGUgLVxuICogQHJldHVybnNcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjcmVhdGVWYWx1ZShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICByZXR1cm4gaW5pdChvcHRpb25zLnZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy52YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KG9wdGlvbnMudmFsdWUpXG4gICAgICAgICAgICA/IG9wdGlvbnMudmFsdWVcbiAgICAgICAgICAgIDoge30pO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICByZXR1cm4gaW5pdChBcnJheS5pc0FycmF5KG9wdGlvbnMudmFsdWUpID8gb3B0aW9ucy52YWx1ZSA6IFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMudmFsdWUgPT09IG51bGwgPyAnJyA6IG9wdGlvbnMudmFsdWU7XG59XG4vKipcbiAqIFNldHMgdGhlIGludGVybmFsIHZhbHVlIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIG5vZGUgLVxuICogQHBhcmFtIGNvbnRleHQgLVxuICogQHBhcmFtIHZhbHVlIC1cbiAqIEByZXR1cm5zIFRcbiAqL1xuZnVuY3Rpb24gaW5wdXQobm9kZSwgY29udGV4dCwgdmFsdWUsIGFzeW5jID0gdHJ1ZSkge1xuICAgIGNvbnRleHQuX3ZhbHVlID0gdmFsaWRhdGVJbnB1dChub2RlLCBub2RlLmhvb2suaW5wdXQuZGlzcGF0Y2godmFsdWUpKTtcbiAgICBub2RlLmVtaXQoJ2lucHV0JywgY29udGV4dC5fdmFsdWUpO1xuICAgIGlmIChjb250ZXh0LmlzU2V0dGxlZClcbiAgICAgICAgbm9kZS5kaXN0dXJiKCk7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICAgIGlmIChjb250ZXh0Ll90bW8pXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdG1vKTtcbiAgICAgICAgY29udGV4dC5fdG1vID0gc2V0VGltZW91dChjb21taXQsIG5vZGUucHJvcHMuZGVsYXksIG5vZGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29tbWl0KG5vZGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dC5zZXR0bGVkO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBjdXJyZW50IGlucHV0IGlzIGFsbG93ZWQuXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIG5vZGUgKGlucHV0LCBsaXN0LCBncm91cClcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0aGF0IGlzIGJlaW5nIHNldFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUlucHV0KG5vZGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgLy8gSW5wdXRzIGFyZSBhbGxvd2VkIHRvIGhhdmUgYW55IHR5cGVcbiAgICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2dyb3VwJzpcbiAgICAgICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICBlcnJvcigxMDcsIFtub2RlLCB2YWx1ZV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICBlcnJvcigxMDgsIFtub2RlLCB2YWx1ZV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQ29tbWl0cyB0aGUgd29ya2luZyB2YWx1ZSB0byB0aGUgbm9kZSBncmFwaCBhcyB0aGUgdmFsdWUgb2YgdGhpcyBub2RlLlxuICogQHBhcmFtIG5vZGUgLVxuICogQHBhcmFtIGNvbnRleHQgLVxuICogQHBhcmFtIGNhbG0gLVxuICogQHBhcmFtIGh5ZHJhdGUgLVxuICovXG5mdW5jdGlvbiBjb21taXQobm9kZSwgY29udGV4dCwgY2FsbSA9IHRydWUsIGh5ZHJhdGUgPSB0cnVlKSB7XG4gICAgY29udGV4dC5fdmFsdWUgPSBjb250ZXh0LnZhbHVlID0gbm9kZS5ob29rLmNvbW1pdC5kaXNwYXRjaChjb250ZXh0Ll92YWx1ZSk7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gJ2lucHV0JyAmJiBoeWRyYXRlKVxuICAgICAgICBub2RlLmh5ZHJhdGUoKTtcbiAgICBub2RlLmVtaXQoJ2NvbW1pdCcsIGNvbnRleHQudmFsdWUpO1xuICAgIGlmIChjYWxtKVxuICAgICAgICBub2RlLmNhbG0oKTtcbn1cbi8qKlxuICogUGVyZm9ybSBhIG1vZGlmaWNhdGlvbiB0byBhIHNpbmdsZSBlbGVtZW50IG9mIGEgcGFyZW50IGFnZ3JlZ2F0ZSB2YWx1ZS4gVGhpc1xuICogaXMgb25seSBwZXJmb3JtZWQgb24gdGhlIHByZS1jb21taXR0ZWQgdmFsdWUgKF92YWx1ZSksIGFsdGhvdWdoIHR5cGljYWxseVxuICogdGhlIHZhbHVlIGFuZCBfdmFsdWUgYXJlIGJvdGggbGlua2VkIGluIG1lbW9yeS5cbiAqIEBwYXJhbSBjb250ZXh0IC1cbiAqIEBwYXJhbSBuYW1lIC1cbiAqIEBwYXJhbSB2YWx1ZSAtXG4gKi9cbmZ1bmN0aW9uIHBhcnRpYWwoY29udGV4dCwgeyBuYW1lLCB2YWx1ZSwgZnJvbSB9KSB7XG4gICAgaWYgKE9iamVjdC5pc0Zyb3plbihjb250ZXh0Ll92YWx1ZSkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoaXNMaXN0KGNvbnRleHQpKSB7XG4gICAgICAgIGNvbnN0IGluc2VydCA9IHZhbHVlID09PSB2YWx1ZVJlbW92ZWRcbiAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgIDogdmFsdWUgPT09IHZhbHVlTW92ZWQgJiYgdHlwZW9mIGZyb20gPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgPyBjb250ZXh0Ll92YWx1ZS5zcGxpY2UoZnJvbSwgMSlcbiAgICAgICAgICAgICAgICA6IFt2YWx1ZV07XG4gICAgICAgIGNvbnRleHQuX3ZhbHVlLnNwbGljZShuYW1lLCB2YWx1ZSA9PT0gdmFsdWVNb3ZlZCB8fCBmcm9tID09PSB2YWx1ZUluc2VydGVkID8gMCA6IDEsIC4uLmluc2VydCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSW4gdGhpcyBjYXNlIHdlIGtub3cgZm9yIHN1cmUgd2UncmUgZGVhbGluZyB3aXRoIGEgZ3JvdXAsIFRTIGRvZXNuJ3RcbiAgICAvLyBrbm93IHRoYXQgaG93ZXZlciwgc28gd2UgdXNlIHNvbWUgdW5wbGVhc2FudCBjYXN0aW5nIGhlcmVcbiAgICBpZiAodmFsdWUgIT09IHZhbHVlUmVtb3ZlZCkge1xuICAgICAgICBjb250ZXh0Ll92YWx1ZVtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGNvbnRleHQuX3ZhbHVlW25hbWVdO1xuICAgIH1cbn1cbi8qKlxuICogUGFzcyB2YWx1ZXMgZG93biB0byBjaGlsZHJlbiBieSBjYWxsaW5nIGh5ZHJhdGUgb24gdGhlbS5cbiAqIEBwYXJhbSBwYXJlbnQgLVxuICogQHBhcmFtIGNoaWxkIC1cbiAqL1xuZnVuY3Rpb24gaHlkcmF0ZShub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgX3ZhbHVlID0gY29udGV4dC5fdmFsdWU7XG4gICAgY29udGV4dC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIF92YWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGlmIChoYXMoY29udGV4dC5fdmFsdWUgYXMgRm9ybUtpdEdyb3VwVmFsdWUsIGNoaWxkLm5hbWUpKSB7XG4gICAgICAgIGlmIChjaGlsZC5uYW1lIGluIF92YWx1ZSkge1xuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgcGFyZW50IGhhcyBhIHZhbHVlIHRvIGdpdmUgdG8gdGhlIGNoaWxkLCBzbyB3ZVxuICAgICAgICAgICAgLy8gcGVyZm9ybSBhIGRvd24tdHJlZSBzeW5jaHJvbm91cyBpbnB1dCB3aGljaCB3aWxsIGNhc2NhZGUgdmFsdWVzIGRvd25cbiAgICAgICAgICAgIC8vIGFuZCB0aGVuIHVsdGltYXRlbHkgYmFjayB1cC5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBjaGlsZC50eXBlICE9PSAnaW5wdXQnIHx8XG4gICAgICAgICAgICAgICAgKF92YWx1ZVtjaGlsZC5uYW1lXSAmJiB0eXBlb2YgX3ZhbHVlW2NoaWxkLm5hbWVdID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICA/IGluaXQoX3ZhbHVlW2NoaWxkLm5hbWVdKVxuICAgICAgICAgICAgICAgIDogX3ZhbHVlW2NoaWxkLm5hbWVdO1xuICAgICAgICAgICAgY2hpbGQuaW5wdXQoY2hpbGRWYWx1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ2xpc3QnIHx8IHR5cGVvZiBjaGlsZC5uYW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIHBhcmVudOKAmXMgdmFsdWVzIGhhdmUgbm8ga25vd2xlZGdlIG9mIHRoZSBjaGlsZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlIOKAlCB0aGlzIHR5cGljYWxseSBvY2N1cnMgb24gdGhlIGNvbW1pdCBhdCB0aGUgZW5kIG9mIGFkZENoaWxkKClcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHZhbHVlIHJlc2VydmF0aW9uIGZvciB0aGlzIG5vZGXigJlzIG5hbWUuIFRoaXMgaXNcbiAgICAgICAgICAgICAgICAvLyBlc3BlY2lhbGx5IGltcG9ydGFudCB3aGVuIGRlYWxpbmcgd2l0aCBsaXN0cyB3aGVyZSBpbmRleCBtYXR0ZXJzLlxuICAgICAgICAgICAgICAgIHBhcnRpYWwoY29udGV4dCwgeyBuYW1lOiBjaGlsZC5uYW1lLCB2YWx1ZTogY2hpbGQudmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV92YWx1ZS5fX2luaXQpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHNvbWVvbmUgaGFzIGV4cGxpY2l0bHkgc2V0IHRoZSB2YWx1ZSB0byBhbiBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyB3aXRoIG5vZGUuaW5wdXQoe30pIHNvIHdlIGRvIG5vdCBkZWZpbmUgdGhlIF9faW5pdCBwcm9wZXJ0eTpcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2dyb3VwJylcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaW5wdXQoe30sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAnbGlzdCcpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmlucHV0KFtdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5pbnB1dCh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBEaXN0dXJicyB0aGUgc3RhdGUgb2YgYSBub2RlIGZyb20gc2V0dGxlZCB0byB1bnNldHRsZWTCoOKAlCBjcmVhdGluZyBhcHByb3ByaWF0ZVxuICogcHJvbWlzZXMgYW5kIHJlc29sdXRpb25zLlxuICogQHBhcmFtIG5vZGUgLVxuICogQHBhcmFtIGNvbnRleHQgLVxuICovXG5mdW5jdGlvbiBkaXN0dXJiKG5vZGUsIGNvbnRleHQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGNvbnRleHQuX2QgPD0gMCkge1xuICAgICAgICBjb250ZXh0LmlzU2V0dGxlZCA9IGZhbHNlO1xuICAgICAgICBub2RlLmVtaXQoJ3NldHRsZWQnLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBjb250ZXh0LnNldHRsZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29udGV4dC5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQpXG4gICAgICAgICAgICAoX2EgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3R1cmIoKTtcbiAgICB9XG4gICAgY29udGV4dC5fZCsrO1xuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBDYWxtcyB0aGUgZ2l2ZW4gbm9kZSdzIGRpc3R1cmJlZCBzdGF0ZSBieSBvbmUuXG4gKiBAcGFyYW0gbm9kZSAtXG4gKiBAcGFyYW0gY29udGV4dCAtXG4gKi9cbmZ1bmN0aW9uIGNhbG0obm9kZSwgY29udGV4dCwgdmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgbm9kZS50eXBlICE9PSAnaW5wdXQnKSB7XG4gICAgICAgIHBhcnRpYWwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgICAvLyBDb21taXQgdGhlIHZhbHVlIHVwLCBidXQgZG8gbm90IGh5ZHJhdGUgYmFjayBkb3duXG4gICAgICAgIHJldHVybiBjb21taXQobm9kZSwgY29udGV4dCwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5fZCA+IDApXG4gICAgICAgIGNvbnRleHQuX2QtLTtcbiAgICBpZiAoY29udGV4dC5fZCA9PT0gMCkge1xuICAgICAgICBjb250ZXh0LmlzU2V0dGxlZCA9IHRydWU7XG4gICAgICAgIG5vZGUuZW1pdCgnc2V0dGxlZCcsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KVxuICAgICAgICAgICAgKF9hID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxtKHsgbmFtZTogbm9kZS5uYW1lLCB2YWx1ZTogY29udGV4dC52YWx1ZSB9KTtcbiAgICAgICAgaWYgKGNvbnRleHQuX3Jlc29sdmUpXG4gICAgICAgICAgICBjb250ZXh0Ll9yZXNvbHZlKGNvbnRleHQudmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBub2RlIGlzIGJlaW5nIHJlbW92ZWQgYW5kIG5lZWRzIHRvIGJlIGNsZWFuZWQgdXAuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIHNodXQgZG93blxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB0byBjbGVhbiB1cFxuICovXG5mdW5jdGlvbiBkZXN0cm95KG5vZGUsIGNvbnRleHQpIHtcbiAgICBub2RlLmVtaXQoJ2Rlc3Ryb3lpbmcnLCBub2RlKTtcbiAgICAvLyBmbHVzaCBhbGwgbWVzc2FnZXMgb3V0XG4gICAgbm9kZS5zdG9yZS5maWx0ZXIoKCkgPT4gZmFsc2UpO1xuICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICBub2RlLnBhcmVudC5yZW1vdmUobm9kZSk7XG4gICAgfVxuICAgIGRlcmVnaXN0ZXIobm9kZSk7XG4gICAgY29udGV4dC5fdmFsdWUgPSBjb250ZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgIG5vZGUuZW1pdCgnZGVzdHJveWVkJywgbm9kZSk7XG59XG4vKipcbiAqIERlZmluZXMgdGhlIGN1cnJlbnQgaW5wdXQgdHlwZSBjb25jcmV0ZWx5LlxuICogQHBhcmFtIGRlZmluaXRpb24gLSBUaGUgZGVmaW5pdGlvbiBvZiB0aGUgY3VycmVudCBpbnB1dCB0eXBlLlxuICovXG5mdW5jdGlvbiBkZWZpbmUobm9kZSwgY29udGV4dCwgZGVmaW5pdGlvbikge1xuICAgIC8vIEFzc2lnbiB0aGUgdHlwZVxuICAgIGNvbnRleHQudHlwZSA9IGRlZmluaXRpb24udHlwZTtcbiAgICAvLyBBc3NpZ24gdGhlIGRlZmluaXRpb25cbiAgICBjb250ZXh0LnByb3BzLmRlZmluaXRpb24gPSBjbG9uZShkZWZpbml0aW9uKTtcbiAgICAvLyBFbnN1cmUgdGhlIHR5cGUgaXMgc2VlZGVkIHdpdGggdGhlIGBfX2luaXRgIHZhbHVlLlxuICAgIGNvbnRleHQudmFsdWUgPSBjb250ZXh0Ll92YWx1ZSA9IGNyZWF0ZVZhbHVlKHtcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICB2YWx1ZTogY29udGV4dC52YWx1ZSxcbiAgICB9KTtcbiAgICAvLyBBcHBseSBhbnkgaW5wdXQgZmVhdHVyZXMgYmVmb3JlIHJlc2V0dGluZyB0aGUgcHJvcHMuXG4gICAgaWYgKGRlZmluaXRpb24uZmVhdHVyZXMpIHtcbiAgICAgICAgZGVmaW5pdGlvbi5mZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiBmZWF0dXJlKG5vZGUpKTtcbiAgICB9XG4gICAgLy8gSXRzIHBvc3NpYmxlIHRoYXQgaW5wdXQtZGVmaW5lZCBcInByb3BzXCIgaGF2ZSBlbmRlZCB1cCBpbiB0aGUgY29udGV4dCBhdHRyc1xuICAgIC8vIHRoZXNlIHNob3VsZCBiZSBtb3ZlZCBiYWNrIG91dCBvZiB0aGUgYXR0cnMgb2JqZWN0LlxuICAgIGlmIChkZWZpbml0aW9uLnByb3BzKSB7XG4gICAgICAgIG5vZGUuYWRkUHJvcHMoZGVmaW5pdGlvbi5wcm9wcyk7XG4gICAgfVxuICAgIG5vZGUuZW1pdCgnZGVmaW5lZCcsIGRlZmluaXRpb24pO1xufVxuLyoqXG4gKiBBZGRzIHByb3BzIHRvIGEgZ2l2ZW4gbm9kZSBieSBzdHJpcHBpbmcgdGhlbSBvdXQgb2YgdGhlIG5vZGUucHJvcHMuYXR0cnMgYW5kXG4gKiB0aGVuIGFkZGluZyB0aGVtIHRvIHRoZSBub2Rlcy5cbiAqXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGFkZCBwcm9wcyB0b1xuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgaW50ZXJuYWwgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSBwcm9wcyAtIEFuIGFycmF5IG9mIHByb3Agc3RyaW5ncyAoaW4gY2FtZWxDYXNlISlcbiAqL1xuZnVuY3Rpb24gYWRkUHJvcHMobm9kZSwgY29udGV4dCwgcHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG5vZGUucHJvcHMuYXR0cnMpIHtcbiAgICAgICAgY29uc3QgYXR0cnMgPSB7IC4uLm5vZGUucHJvcHMuYXR0cnMgfTtcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZSBwcm9wIGVtaXRzXG4gICAgICAgIG5vZGUucHJvcHMuX2VtaXQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJzKSB7XG4gICAgICAgICAgICBjb25zdCBjYW1lbE5hbWUgPSBjYW1lbChhdHRyKTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5pbmNsdWRlcyhjYW1lbE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wc1tjYW1lbE5hbWVdID0gYXR0cnNbYXR0cl07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRpYWwgPSBjbG9uZUFueShjb250ZXh0Ll92YWx1ZSk7XG4gICAgICAgIG5vZGUucHJvcHMuaW5pdGlhbCA9XG4gICAgICAgICAgICBub2RlLnR5cGUgIT09ICdpbnB1dCcgPyBpbml0KGluaXRpYWwpIDogaW5pdGlhbDtcbiAgICAgICAgLy8gUmUtZW5hYmxlIHByb3AgZW1pdHNcbiAgICAgICAgbm9kZS5wcm9wcy5fZW1pdCA9IHRydWU7XG4gICAgICAgIG5vZGUucHJvcHMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgaWYgKG5vZGUucHJvcHMuZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgbm9kZS5wcm9wcy5kZWZpbml0aW9uLnByb3BzID0gW1xuICAgICAgICAgICAgICAgIC4uLigoKF9hID0gbm9kZS5wcm9wcy5kZWZpbml0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcHMpIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5lbWl0KCdhZGRlZC1wcm9wcycsIHByb3BzKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogKG5vZGUuYWRkKSBBZGRzIGEgY2hpbGQgdG8gdGhlIG5vZGUuXG4gKiBAcGFyYW0gY29udGV4dCAtXG4gKiBAcGFyYW0gbm9kZSAtXG4gKiBAcGFyYW0gY2hpbGQgLVxuICovXG5mdW5jdGlvbiBhZGRDaGlsZChwYXJlbnQsIHBhcmVudENvbnRleHQsIGNoaWxkLCBsaXN0SW5kZXgpIHtcbiAgICBpZiAocGFyZW50LnR5cGUgPT09ICdpbnB1dCcpXG4gICAgICAgIGVycm9yKDEwMCwgcGFyZW50KTtcbiAgICBpZiAoY2hpbGQucGFyZW50ICYmIGNoaWxkLnBhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICAgIH1cbiAgICAvLyBTeW5jaHJvbm91c2x5IHNldCB0aGUgaW5pdGlhbCB2YWx1ZSBvbiB0aGUgcGFyZW50XG4gICAgaWYgKCFwYXJlbnRDb250ZXh0LmNoaWxkcmVuLmluY2x1ZGVzKGNoaWxkKSkge1xuICAgICAgICBpZiAobGlzdEluZGV4ICE9PSB1bmRlZmluZWQgJiYgcGFyZW50LnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgLy8gSW5qZWN0IHRoZSBjaGlsZDpcbiAgICAgICAgICAgIHBhcmVudENvbnRleHQuY2hpbGRyZW4uc3BsaWNlKGxpc3RJbmRleCwgMCwgY2hpbGQpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyZW50LnZhbHVlKSAmJlxuICAgICAgICAgICAgICAgIHBhcmVudC52YWx1ZS5sZW5ndGggPCBwYXJlbnRDb250ZXh0LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gYWRkaW5nIGFuIG5vZGUgb3IgdmFsdWUgdG8gYSBsaXN0IGl0IGlzIGFic29sdXRlbHkgY3JpdGljYWwgdG9cbiAgICAgICAgICAgICAgICAvLyBrbm93IGlmLCBhdCB0aGUgbW9tZW50IG9mIGluamVjdGlvbiwgdGhlIHBhcmVudOKAmXMgdmFsdWUgb3IgdGhlIG5vZGVcbiAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiBhcmUgdGhlIHNvdXJjZSBvZiB0cnV0aC4gRm9yIGV4YW1wbGUsIGlmIGEgdXNlciBwdXNoZXMgb3JcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2VzIGEgbmV3IHZhbHVlIG9udG8gdGhlIGxpc3Rz4oCZcyBhcnJheSB0aGVuIHdlIHdhbnQgdG8gdXNlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBhcyB0aGUgdmFsdWUgb2YgdGhlIG5ldyBub2RlLCBidXQgaWYgYSB1c2VyIGFkZHMgYSBub2RlIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxpc3QgdGhlbiB3ZSB3YW50IHRoZSBub2Rl4oCZcyB2YWx1ZS4gSW4gdGhpcyBzcGVjaWZpYyBjYXNlLCB3ZVxuICAgICAgICAgICAgICAgIC8vIGFzc3VtZSAoZHVlIHRvIGxlbmd0aCkgdGhhdCBhIG5ldyBub2RlIHdhcyBpbmplY3RlZCBpbnRvIHRoZSBsaXN0LCBzb1xuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdGhhdCBuZXcgbm9kZeKAmXMgdmFsdWUgaW5qZWN0ZWQgaW50byB0aGUgcGFyZW50IGxpc3QgdmFsdWUuXG4gICAgICAgICAgICAgICAgcGFyZW50LmRpc3R1cmIoKS5jYWxtKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbGlzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2hpbGQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHZhbHVlSW5zZXJ0ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRDb250ZXh0LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGQuaXNTZXR0bGVkKVxuICAgICAgICAgICAgcGFyZW50LmRpc3R1cmIoKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgLy8gSW4gdGhpcyBlZGdlIGNhc2UgbWlkZGxld2FyZSBjaGFuZ2VkIHRoZSBwYXJlbnQgYXNzaWdubWVudCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHJlLWFkZCB0aGUgY2hpbGRcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiBhIHBhcmVudCBpcyBwcm9wZXJseSBhc3NpZ25lZCwgd2UgaW5qZWN0IHRoZSBwYXJlbnQncyBwbHVnaW5zIG9uIHRoZVxuICAgICAgICAvLyBjaGlsZC5cbiAgICAgICAgY2hpbGQudXNlKHBhcmVudC5wbHVnaW5zKTtcbiAgICB9XG4gICAgLy8gRmluYWxseSB3ZSBjYWxsIGNvbW1pdCBoZXJlLCB3aGljaCBzdWItY2FsbHMgaHlkcmF0ZSgpLCBoeWRyYXRlKCkgd2lsbFxuICAgIC8vIHJlc29sdmUgYW55IGNvbmZsaWN0IGJldHdlZW4gdGhlIHBhcmVudCBhbmQgY2hpbGQgdmFsdWVzLCBhbmQgYWxzbyBlbnN1cmVcbiAgICAvLyBwcm9wZXIgXCJwbGFjZWhvbGRlcnNcIiBhcmUgbWFkZSBvbiB0aGUgcGFyZW50LlxuICAgIGNvbW1pdChwYXJlbnQsIHBhcmVudENvbnRleHQsIGZhbHNlKTtcbiAgICBwYXJlbnQubGVkZ2VyLm1lcmdlKGNoaWxkKTtcbiAgICBwYXJlbnQuZW1pdCgnY2hpbGQnLCBjaGlsZCk7XG4gICAgcmV0dXJuIHBhcmVudDtcbn1cbi8qKlxuICogVGhlIHNldHRlciBmb3Igbm9kZS5wYXJlbnQgPSBGb3JtS2l0Tm9kZVxuICogQHBhcmFtIF9jb250ZXh0IC1cbiAqIEBwYXJhbSBub2RlIC1cbiAqIEBwYXJhbSBfcHJvcGVydHkgLVxuICogQHBhcmFtIHBhcmVudCAtXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIHNldFBhcmVudChjaGlsZCwgY29udGV4dCwgX3Byb3BlcnR5LCBwYXJlbnQpIHtcbiAgICBpZiAoaXNOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCAmJiBjaGlsZC5wYXJlbnQgIT09IHBhcmVudCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGNoaWxkLnJlc2V0Q29uZmlnKCk7XG4gICAgICAgICFwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMoY2hpbGQpXG4gICAgICAgICAgICA/IHBhcmVudC5hZGQoY2hpbGQpXG4gICAgICAgICAgICA6IGNoaWxkLnVzZShwYXJlbnQucGx1Z2lucyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRleHQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogKG5vZGUucmVtb3ZlKSBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgbm9kZS5cbiAqIEBwYXJhbSBjb250ZXh0IC1cbiAqIEBwYXJhbSBub2RlIC1cbiAqIEBwYXJhbSBjaGlsZCAtXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKG5vZGUsIGNvbnRleHQsIGNoaWxkKSB7XG4gICAgY29uc3QgY2hpbGRJbmRleCA9IGNvbnRleHQuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGlmIChjaGlsZC5pc1NldHRsZWQpXG4gICAgICAgICAgICBub2RlLmRpc3R1cmIoKTtcbiAgICAgICAgY29udGV4dC5jaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMSk7XG4gICAgICAgIC8vIElmIGFuIGFuY2VzdG9yIHVzZXMgdGhlIHByZXNlcnZlIHByb3AsIHRoZW4gd2UgYXJlIGV4cGVjdGVkIHRvIG5vdCByZW1vdmVcbiAgICAgICAgLy8gb3VyIHZhbHVlcyBvbiB0aGlzIG5vZGUgZWl0aGVyLCBzZWUgIzUzXG4gICAgICAgIGxldCBwcmVzZXJ2ZSA9IHVuZGVmaW5lKGNoaWxkLnByb3BzLnByZXNlcnZlKTtcbiAgICAgICAgbGV0IHBhcmVudCA9IGNoaWxkLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKHByZXNlcnZlID09PSB1bmRlZmluZWQgJiYgcGFyZW50KSB7XG4gICAgICAgICAgICBwcmVzZXJ2ZSA9IHVuZGVmaW5lKHBhcmVudC5wcm9wcy5wcmVzZXJ2ZSk7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICAgIG5vZGUuY2FsbSh7XG4gICAgICAgICAgICAgICAgbmFtZTogbm9kZS50eXBlID09PSAnbGlzdCcgPyBjaGlsZEluZGV4IDogY2hpbGQubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVSZW1vdmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmNhbG0oKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGNoaWxkIGZyb20gdGhlIGNvbmZpZy4gSXMgdGhpcyB3ZWlyZD8gWWVzLiBJcyBpdCBvaz8gWWVzLlxuICAgICAgICBjaGlsZC5jb25maWcuX3JtbiA9IGNoaWxkO1xuICAgIH1cbiAgICBub2RlLmxlZGdlci51bm1lcmdlKGNoaWxkKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggaW1tZWRpYXRlIGNoaWxkIGFuZCBwZXJmb3JtIGEgY2FsbGJhY2suXG4gKiBAcGFyYW0gY29udGV4dCAtXG4gKiBAcGFyYW0gX25vZGUgLVxuICogQHBhcmFtIGNhbGxiYWNrIC1cbiAqL1xuZnVuY3Rpb24gZWFjaENoaWxkKF9ub2RlLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgIGNvbnRleHQuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IGNhbGxiYWNrKGNoaWxkKSk7XG59XG4vKipcbiAqIFdhbGsgYWxsIG5vZGVzIGJlbG93IHRoaXMgb25lIGFuZCBleGVjdXRlIGEgY2FsbGJhY2suXG4gKiBAcGFyYW0gX25vZGUgLVxuICogQHBhcmFtIGNvbnRleHQgLVxuICogQHBhcmFtIGNhbGxiYWNrIC1cbiAqL1xuZnVuY3Rpb24gd2Fsa1RyZWUoX25vZGUsIGNvbnRleHQsIGNhbGxiYWNrLCBzdG9wSWZGYWxzZSA9IGZhbHNlKSB7XG4gICAgY29udGV4dC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGJhY2soY2hpbGQpICE9PSBmYWxzZSB8fCAhc3RvcElmRmFsc2UpIHtcbiAgICAgICAgICAgIGNoaWxkLndhbGsoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFNldCB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBub2RlIGFuZCBpdCdzIHN1YnRyZWUuXG4gKiBAcGFyYW0gbm9kZSAtXG4gKiBAcGFyYW0gY29udGV4dCAtXG4gKiBAcGFyYW0gX3Byb3BlcnR5IC1cbiAqIEBwYXJhbSBjb25maWcgLVxuICovXG5mdW5jdGlvbiByZXNldENvbmZpZyhub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnQgfHwgdW5kZWZpbmVkO1xuICAgIGNvbnRleHQuY29uZmlnID0gY3JlYXRlQ29uZmlnKG5vZGUuY29uZmlnLl90LCBwYXJlbnQpO1xuICAgIG5vZGUud2FsaygobikgPT4gbi5yZXNldENvbmZpZygpKTtcbn1cbi8qKlxuICogQWRkcyBhIHBsdWdpbiB0byB0aGUgbm9kZSwgaXTigJlzIGNoaWxkcmVuLCBhbmQgZXhlY3V0ZXMgaXQuXG4gKiBAcGFyYW0gY29udGV4dCAtXG4gKiBAcGFyYW0gbm9kZSAtXG4gKiBAcGFyYW0gcGx1Z2luIC1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlKG5vZGUsIGNvbnRleHQsIHBsdWdpbiwgcnVuID0gdHJ1ZSwgbGlicmFyeSA9IHRydWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW4pIHx8IHBsdWdpbiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBwbHVnaW4uZm9yRWFjaCgocCkgPT4gdXNlKG5vZGUsIGNvbnRleHQsIHApKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlmICghY29udGV4dC5wbHVnaW5zLmhhcyhwbHVnaW4pKSB7XG4gICAgICAgIGlmIChsaWJyYXJ5ICYmIHR5cGVvZiBwbHVnaW4ubGlicmFyeSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHBsdWdpbi5saWJyYXJ5KG5vZGUpO1xuICAgICAgICAvLyBXaGVuIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCB0aGV5IGFyZSBuZXZlciBhZGRlZCBhcyB0byB0aGUgcGx1Z2lucyBTZXRcbiAgICAgICAgLy8gbWVhbmluZyB0aGV5IG9ubHkgZXZlciBoYXZlIGFjY2VzcyB0byB0aGUgc2luZ2xlIG5vZGUgdGhleSB3ZXJlIGFkZGVkIG9uLlxuICAgICAgICBpZiAocnVuICYmIHBsdWdpbihub2RlKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRleHQucGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnVzZShwbHVnaW4pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogTW92ZXMgYSBub2RlIGluIHRoZSBwYXJlbnTigJlzIGNoaWxkcmVuIHRvIHRoZSBnaXZlbiBpbmRleC5cbiAqIEBwYXJhbSBub2RlIC1cbiAqIEBwYXJhbSBfY29udGV4dCAtXG4gKiBAcGFyYW0gX3Byb3BlcnR5IC1cbiAqIEBwYXJhbSBzZXRJbmRleCAtXG4gKi9cbmZ1bmN0aW9uIHNldEluZGV4KG5vZGUsIF9jb250ZXh0LCBfcHJvcGVydHksIHNldEluZGV4KSB7XG4gICAgaWYgKGlzTm9kZShub2RlLnBhcmVudCkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLnBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzZXRJbmRleCA+PSBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgID8gY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgICAgICAgICAgOiBzZXRJbmRleCA8IDBcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IHNldEluZGV4O1xuICAgICAgICBjb25zdCBvbGRJbmRleCA9IGNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG4gICAgICAgIGlmIChvbGRJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShvbGRJbmRleCwgMSk7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgbm9kZSk7XG4gICAgICAgIG5vZGUucGFyZW50LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAnbGlzdCcpXG4gICAgICAgICAgICBub2RlLnBhcmVudFxuICAgICAgICAgICAgICAgIC5kaXN0dXJiKClcbiAgICAgICAgICAgICAgICAuY2FsbSh7IG5hbWU6IGluZGV4LCB2YWx1ZTogdmFsdWVNb3ZlZCwgZnJvbTogb2xkSW5kZXggfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgaW5kZXggb2YgYSBub2RlIGZyb20gdGhlIHBhcmVudOKAmXMgY2hpbGRyZW4uXG4gKiBAcGFyYW0gbm9kZSAtXG4gKi9cbmZ1bmN0aW9uIGdldEluZGV4KG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBbLi4ubm9kZS5wYXJlbnQuY2hpbGRyZW5dLmluZGV4T2Yobm9kZSk7XG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBpcyBjdXJyZW50bHkgLTEgdGhlbiB0aGUgbm9kZSBpc250IGZpbmlzaGVkIGJvb3RpbmcsIHNvIGl0XG4gICAgICAgIC8vIG11c3QgYmUgdGhlIG5leHQgbm9kZS5cbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG5vZGUucGFyZW50LmNoaWxkcmVuLmxlbmd0aCA6IGluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGV4dCBvYmplY3Qgb2YgYSBnaXZlbiBub2RlLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGFcbiAqIHByaXZhdGUgdHJhcCBhbmQgc2hvdWxkIGFic29sdXRlbHkgbm90IGJlIHVzZWQgaW4gcGx1Z2lucyBvciB1c2VyLWxhbmQgY29kZS5cbiAqIEBwYXJhbSBfbm9kZSAtXG4gKiBAcGFyYW0gY29udGV4dCAtXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRleHQoX25vZGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG5vZGUsIGFsbG93aW5nIGZvciBzbGlnaHQgbXV0YXRpb25zLlxuICogQHBhcmFtIG5vZGUgLVxuICogQHBhcmFtIGNvbnRleHQgLVxuICovXG5mdW5jdGlvbiBnZXROYW1lKG5vZGUsIGNvbnRleHQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCgoX2EgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnbGlzdCcpXG4gICAgICAgIHJldHVybiBub2RlLmluZGV4O1xuICAgIHJldHVybiBjb250ZXh0Lm5hbWUgIT09IHVzZUluZGV4ID8gY29udGV4dC5uYW1lIDogbm9kZS5pbmRleDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgYWRkcmVzcyBvZiB0aGUgY3VycmVudCBub2RlLlxuICogQHBhcmFtIG5vZGUgLVxuICogQHBhcmFtIGNvbnRleHQgLVxuICovXG5mdW5jdGlvbiBnZXRBZGRyZXNzKG5vZGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dC5wYXJlbnRcbiAgICAgICAgPyBjb250ZXh0LnBhcmVudC5hZGRyZXNzLmNvbmNhdChbbm9kZS5uYW1lXSlcbiAgICAgICAgOiBbbm9kZS5uYW1lXTtcbn1cbi8qKlxuICogRmV0Y2hlcyBhIG5vZGUgZnJvbSB0aGUgdHJlZSBieSBpdHMgYWRkcmVzcy5cbiAqIEBwYXJhbSBjb250ZXh0IC1cbiAqIEBwYXJhbSBub2RlIC1cbiAqIEBwYXJhbSBsb2NhdGlvbiAtXG4gKiBAcmV0dXJucyBGb3JtS2l0Tm9kZVxuICovXG5mdW5jdGlvbiBnZXROb2RlKG5vZGUsIF9jb250ZXh0LCBsb2NhdG9yKSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHR5cGVvZiBsb2NhdG9yID09PSAnc3RyaW5nJyA/IGxvY2F0b3Iuc3BsaXQobm9kZS5jb25maWcuZGVsaW1pdGVyKSA6IGxvY2F0b3I7XG4gICAgaWYgKCFhZGRyZXNzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBmaXJzdCA9IGFkZHJlc3NbMF07XG4gICAgbGV0IHBvaW50ZXIgPSBub2RlLnBhcmVudDtcbiAgICBpZiAoIXBvaW50ZXIpIHtcbiAgICAgICAgLy8gVGhpcyBhZGRyZXNzIG5hbWVzIHRoZSByb290IG5vZGUsIHJlbW92ZSBpdCB0byBnZXQgY2hpbGQgbmFtZTpcbiAgICAgICAgaWYgKFN0cmluZyhhZGRyZXNzWzBdKSA9PT0gU3RyaW5nKG5vZGUubmFtZSkpXG4gICAgICAgICAgICBhZGRyZXNzLnNoaWZ0KCk7XG4gICAgICAgIC8vIEFsbCByb290IG5vZGVzIHN0YXJ0IGF0IHRoZW1zZWx2ZXMgdWx0aW1hdGVseTpcbiAgICAgICAgcG9pbnRlciA9IG5vZGU7XG4gICAgfVxuICAgIC8vIEFueSBhZGRyZXNzZXMgc3RhcnRpbmcgd2l0aCAkcGFyZW50IHNob3VsZCBkaXNjYXJkIGl0XG4gICAgaWYgKGZpcnN0ID09PSAnJHBhcmVudCcpXG4gICAgICAgIGFkZHJlc3Muc2hpZnQoKTtcbiAgICB3aGlsZSAocG9pbnRlciAmJiBhZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBuYW1lID0gYWRkcmVzcy5zaGlmdCgpO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJyRyb290JzpcbiAgICAgICAgICAgICAgICBwb2ludGVyID0gbm9kZS5yb290O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJHBhcmVudCc6XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIucGFyZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJHNlbGYnOlxuICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwb2ludGVyID1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5jaGlsZHJlbi5maW5kKChjKSA9PiBTdHJpbmcoYy5uYW1lKSA9PT0gU3RyaW5nKG5hbWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0KHBvaW50ZXIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb2ludGVyIHx8IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUGVyZm9ybSBzZWxlY3Rpb25zIG9uIGEgc3VidHJlZSB1c2luZyB0aGUgYWRkcmVzcyBcInNlbGVjdG9yXCIgbWV0aG9kcy5cbiAqIEBwYXJhbSBub2RlIC1cbiAqIEBwYXJhbSBzZWxlY3RvciAtXG4gKiBAcmV0dXJucyBGb3JtS2l0Tm9kZSB8IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBzZWxlY3Qobm9kZSwgc2VsZWN0b3IpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gU3RyaW5nKHNlbGVjdG9yKS5tYXRjaCgvXihmaW5kKVxcKCguKilcXCkkLyk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgWywgYWN0aW9uLCBhcmdTdHJdID0gbWF0Y2hlcztcbiAgICAgICAgY29uc3QgYXJncyA9IGFyZ1N0ci5zcGxpdCgnLCcpLm1hcCgoYXJnKSA9PiBhcmcudHJpbSgpKTtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUGVyZm9ybSBhIGJyZWFkdGggZmlyc3Qgc2VhcmNoIGFuZCByZXR1cm4gdGhlIGZpcnN0IGluc3RhbmNlIG9mIGEgbm9kZSB0aGF0XG4gKiBpcyBmb3VuZCBpbiB0aGUgc3VidHJlZSBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2ggb24vdW5kZXJcbiAqIEBwYXJhbSBfY29udGV4dCAtIFRoZSBjb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHNlYXJjaFRlcm0gLSBUaGUgdGVybSB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogQHBhcmFtIHNlYXJjaGVyIC0gRWl0aGVyIGEga2V5IHRvIHNlYXJjaCBvbiwgb3IgYSBmdW5jdGlvblxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZmluZChub2RlLCBfY29udGV4dCwgc2VhcmNoVGVybSwgc2VhcmNoZXIpIHtcbiAgICByZXR1cm4gYmZzKG5vZGUsIHNlYXJjaFRlcm0sIHNlYXJjaGVyKTtcbn1cbi8qKlxuICogUGVyZm9ybSBhIGJyZWFkdGgtZmlyc3Qtc2VhcmNoIG9uIGEgbm9kZSBzdWJ0cmVlIGFuZCBsb2NhdGUgdGhlIGZpcnN0XG4gKiBpbnN0YW5jZSBvZiBhIG1hdGNoLlxuICogQHBhcmFtIG5vZGUgLVxuICogQHBhcmFtIG5hbWUgLVxuICogQHJldHVybnMgRm9ybUtpdE5vZGVcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gYmZzKHRyZWUsIHNlYXJjaFZhbHVlLCBzZWFyY2hHb2FsID0gJ25hbWUnKSB7XG4gICAgY29uc3Qgc2VhcmNoID0gdHlwZW9mIHNlYXJjaEdvYWwgPT09ICdzdHJpbmcnXG4gICAgICAgID8gKG4pID0+IG5bc2VhcmNoR29hbF0gPT0gc2VhcmNoVmFsdWUgLy8gbm9uLXN0cmljdCBjb21wYXJpc29uIGlzIGludGVudGlvbmFsXG4gICAgICAgIDogc2VhcmNoR29hbDtcbiAgICBjb25zdCBzdGFjayA9IFt0cmVlXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzdGFjay5zaGlmdCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgaWYgKHNlYXJjaChub2RlLCBzZWFyY2hWYWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgc3RhY2sucHVzaCguLi5ub2RlLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogR2V0IHRoZSByb290IG5vZGUgb2YgdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobikge1xuICAgIGxldCBub2RlID0gbjtcbiAgICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjb25maWd1cmF0aW9uIG9wdGlvbi5cbiAqIEBwYXJhbSBwYXJlbnQgLVxuICogQHBhcmFtIGNvbmZpZ09wdGlvbnMgLVxuICogQHJldHVybnMgRm9ybUtpdENvbmZpZ1xuICovXG5mdW5jdGlvbiBjcmVhdGVDb25maWcodGFyZ2V0ID0ge30sIHBhcmVudCkge1xuICAgIGxldCBub2RlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgICAgIGdldCguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnX3QnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhbHVlID0gUmVmbGVjdC5nZXQoLi4uYXJncyk7XG4gICAgICAgICAgICAvLyBDaGVjayBvdXIgbG9jYWwgdmFsdWVzIGZpcnN0XG4gICAgICAgICAgICBpZiAobG9jYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFZhbHVlO1xuICAgICAgICAgICAgLy8gVGhlbiBjaGVjayBvdXIgcGFyZW50IHZhbHVlcyBuZXh0XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50VmFsID0gcGFyZW50LmNvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0LnJvb3RDb25maWcgJiYgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdFZhbHVlID0gdGFyZ2V0LnJvb3RDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RWYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgZGVsYXkgdmFsdWUgc2hvdWxkIGJlIDIwXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2RlbGF5JyAmJiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnR5cGUpID09PSAnaW5wdXQnKVxuICAgICAgICAgICAgICAgIHJldHVybiAyMDtcbiAgICAgICAgICAgIC8vIEZpbmFsbHkgY2hlY2sgdGhlIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdENvbmZpZ1twcm9wXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSBhcmdzWzFdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzJdO1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdfbicpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5yb290Q29uZmlnKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucm9vdENvbmZpZy5fYWRkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdfcm1uJykge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQucm9vdENvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnJvb3RDb25maWcuX3JtKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVxKHRhcmdldFtwcm9wXSwgdmFsdWUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZFNldCA9IFJlZmxlY3Quc2V0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZW1pdChgY29uZmlnOiR7cHJvcH1gLCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25maWdDaGFuZ2Uobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXYWxrIHRoZSBub2RlIHRyZWUgYW5kIG5vdGlmeSBvZiBjb25maWcvcHJvcCBjaGFuZ2VzIHdoZXJlIHJlbGV2YW50XG4gICAgICAgICAgICAgICAgICAgIG5vZGUud2FsaygobikgPT4gY29uZmlnQ2hhbmdlKG4sIHByb3AsIHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkaWRTZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogR2l2ZW4gYSBzdHJpbmcgb2YgdGV4dCwgZXhwb3NlIGl0IGZvciBtb2RpZmljYXRpb24sIHRyYW5zbGF0aW9uLCBvciBmdWxsXG4gKiByZXBsYWNlbWVudC5cbiAqIEBwYXJhbSBrZXkgLSBBIG1lc3NhZ2Uga2V5LCBvciBnZW5lcmljIHN0cmluZyBvZiB0ZXh0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0ZXh0KG5vZGUsIF9jb250ZXh0LCBrZXksIHR5cGUgPSAndWknKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHsga2V5LCB2YWx1ZToga2V5LCB0eXBlIH0gOiBrZXk7XG4gICAgY29uc3QgdmFsdWUgPSBub2RlLmhvb2sudGV4dC5kaXNwYXRjaChmcmFnbWVudCk7XG4gICAgbm9kZS5lbWl0KCd0ZXh0JywgdmFsdWUsIGZhbHNlKTtcbiAgICByZXR1cm4gdmFsdWUudmFsdWU7XG59XG4vKipcbiAqIFN1Ym1pdHMgdGhlIG5lYXJlc3QgYW5jZXN0b3IgdGhhdCBpcyBhIEZvcm1LaXQgXCJmb3JtXCIuIEl0IGRldGVybWluZXMgd2hpY2hcbiAqIG5vZGUgaXMgYSBmb3JtIGJ5IGxvY2F0aW5nIGFuIGFuY2VzdG9yIHdoZXJlIG5vZGUucHJvcHMuaXNGb3JtID0gdHJ1ZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gaW5pdGlhdGUgdGhlIHN1Ym1pdFxuICovXG5mdW5jdGlvbiBzdWJtaXQobm9kZSkge1xuICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgZG8ge1xuICAgICAgICBpZiAobm9kZS5wcm9wcy5pc0Zvcm0gPT09IHRydWUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKCFub2RlLnBhcmVudClcbiAgICAgICAgICAgIGVycm9yKDEwNiwgbmFtZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9IHdoaWxlIChub2RlKTtcbiAgICBpZiAobm9kZS5wcm9wcy5pZCkge1xuICAgICAgICBzdWJtaXRGb3JtKG5vZGUucHJvcHMuaWQpO1xuICAgIH1cbn1cbi8qKlxuICogUmVzZXQgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byByZXNldFxuICogQHBhcmFtIF9jb250ZXh0IC0gVGhlIGNvbnRleHRcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXNldCB0b1xuICovXG5mdW5jdGlvbiByZXNldFZhbHVlKG5vZGUsIF9jb250ZXh0LCB2YWx1ZSkge1xuICAgIHJldHVybiByZXNldChub2RlLCB2YWx1ZSk7XG59XG4vKipcbiAqIFNldHMgZXJyb3JzIG9uIHRoZSBub2RlIGFuZCBvcHRpb25hbGx5IGl0cyBjaGlsZHJlbi5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gc2V0IGVycm9ycyBvblxuICogQHBhcmFtIF9jb250ZXh0IC0gTm90IHVzZWRcbiAqIEBwYXJhbSBsb2NhbEVycm9ycyAtIEFuIGFycmF5IG9mIGVycm9ycyB0byBzZXQgb24gdGhpcyBub2RlXG4gKiBAcGFyYW0gY2hpbGRFcnJvcnMgLSBBbiBvYmplY3Qgb2YgbmFtZSB0byBlcnJvcnMgdG8gc2V0IG9uIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBzZXRFcnJvcnMkMShub2RlLCBfY29udGV4dCwgbG9jYWxFcnJvcnMsIGNoaWxkRXJyb3JzKSB7XG4gICAgY29uc3Qgc291cmNlS2V5ID0gYCR7bm9kZS5uYW1lfS1zZXRgO1xuICAgIGNyZWF0ZU1lc3NhZ2VzKG5vZGUsIGxvY2FsRXJyb3JzLCBjaGlsZEVycm9ycykuZm9yRWFjaCgoZXJyb3JzKSA9PiB7XG4gICAgICAgIG5vZGUuc3RvcmUuYXBwbHkoZXJyb3JzLCAobWVzc2FnZSkgPT4gbWVzc2FnZS5tZXRhLnNvdXJjZSA9PT0gc291cmNlS2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogQ2xlYXJzIGVycm9ycyBvbiB0aGUgbm9kZSBhbmQgb3B0aW9uYWxseSBpdHMgY2hpbGRyZW4uXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIHNldCBlcnJvcnMgb25cbiAqIEBwYXJhbSBfY29udGV4dCAtIE5vdCB1c2VkXG4gKiBAcGFyYW0gbG9jYWxFcnJvcnMgLSBBbiBhcnJheSBvZiBlcnJvcnMgdG8gc2V0IG9uIHRoaXMgbm9kZVxuICogQHBhcmFtIGNoaWxkRXJyb3JzIC0gQW4gb2JqZWN0IG9mIG5hbWUgdG8gZXJyb3JzIHRvIHNldCBvbiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY2xlYXJFcnJvcnMkMShub2RlLCBjb250ZXh0LCBjbGVhckNoaWxkRXJyb3JzID0gdHJ1ZSkge1xuICAgIHNldEVycm9ycyQxKG5vZGUsIGNvbnRleHQsIFtdKTtcbiAgICBpZiAoY2xlYXJDaGlsZEVycm9ycykge1xuICAgICAgICBjb25zdCBzb3VyY2VLZXkgPSBgJHtub2RlLm5hbWV9LXNldGA7XG4gICAgICAgIG5vZGUud2FsaygoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGNoaWxkLnN0b3JlLmZpbHRlcigobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhKG1lc3NhZ2UudHlwZSA9PT0gJ2Vycm9yJyAmJlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1ldGEgJiZcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXRhLnNvdXJjZSA9PT0gc291cmNlS2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vKipcbiAqIE1pZGRsZXdhcmUgdG8gYXNzaWduIGRlZmF1bHQgcHJvcCB2YWx1ZXMgYXMgaXNzdWVkIGJ5IGNvcmUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIGJlaW5nIHJlZ2lzdGVyZWRcbiAqIEBwYXJhbSBuZXh0IC0gQ2FsbHMgdGhlIG5leHQgbWlkZGxld2FyZS5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRQcm9wcyhub2RlKSB7XG4gICAgaWYgKCFoYXMobm9kZS5wcm9wcywgJ2lkJykpXG4gICAgICAgIG5vZGUucHJvcHMuaWQgPSBgaW5wdXRfJHtpZENvdW50Kyt9YDtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogQHBhcmFtIG9wdGlvbnMgLVxuICogQHBhcmFtIGNvbmZpZyAtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3BzKGluaXRpYWwpIHtcbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgaW5pdGlhbDogdHlwZW9mIGluaXRpYWwgPT09ICdvYmplY3QnID8gY2xvbmVBbnkoaW5pdGlhbCkgOiBpbml0aWFsLFxuICAgIH07XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGlzRW1pdHRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgUHJveHkocHJvcHMsIHtcbiAgICAgICAgZ2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfdCwgcHJvcF0gPSBhcmdzO1xuICAgICAgICAgICAgaWYgKGhhcyhwcm9wcywgcHJvcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmIG5vZGUuY29uZmlnW3Byb3BdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHRhcmdldCwgcHJvcGVydHksIG9yaWdpbmFsVmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICdfbicpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gb3JpZ2luYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ19lbWl0Jykge1xuICAgICAgICAgICAgICAgIGlzRW1pdHRpbmcgPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBwcm9wLCB2YWx1ZSB9ID0gbm9kZS5ob29rLnByb3AuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHByb3A6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbFZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUeXBlc2NyaXB0IGNvbXBpbGVyIGNhbm5vdCBoYW5kbGUgYSBzeW1ib2wgaW5kZXgsIGV2ZW4gdGhvdWdoIGpzIGNhbjpcbiAgICAgICAgICAgIGlmICghZXEocHJvcHNbcHJvcF0sIHZhbHVlLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlkU2V0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpc0VtaXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZW1pdCgncHJvcCcsIHsgcHJvcCwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmVtaXQoYHByb3A6JHtwcm9wfWAsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZFNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBBIGNoZWFwIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBhbGwgcGx1Z2lucyBhbmQgc3RvcHMgb25jZSBub2RlLmRlZmluZVxuICogaXMgY2FsbGVkLlxuICogQHBhcmFtIG5vZGUgLSBBIGZvcm1raXQgbm9kZVxuICogQHBhcmFtIHBsdWdpbnMgLSBBbiBhcnJheSBvZiBwbHVnaW5zXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBmaW5kRGVmaW5pdGlvbihub2RlLCBwbHVnaW5zKSB7XG4gICAgLy8gSWYgdGhlIGRlZmluaXRpb24gaXMgYWxyZWFkeSB0aGVyZSwgZm9yY2UgY2FsbCB0byBkZWZpbmUuXG4gICAgaWYgKG5vZGUucHJvcHMuZGVmaW5pdGlvbilcbiAgICAgICAgcmV0dXJuIG5vZGUuZGVmaW5lKG5vZGUucHJvcHMuZGVmaW5pdGlvbik7XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICBpZiAobm9kZS5wcm9wcy5kZWZpbml0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIHBsdWdpbi5saWJyYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwbHVnaW4ubGlicmFyeShub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvbnRleHQgb2JqZWN0IGZvciBvdXIgYSBGb3JtS2l0IG5vZGUsIGdpdmVuIGRlZmF1bHQgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICogQHJldHVybnMgRm9ybUtpdENvbnRleHRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChvcHRpb25zKSB7XG4gICAgY29uc3QgdmFsdWUgPSBjcmVhdGVWYWx1ZShvcHRpb25zKTtcbiAgICBjb25zdCBjb25maWcgPSBjcmVhdGVDb25maWcob3B0aW9ucy5jb25maWcgfHwge30sIG9wdGlvbnMucGFyZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBfZDogMCxcbiAgICAgICAgX2U6IGNyZWF0ZUVtaXR0ZXIoKSxcbiAgICAgICAgX3Jlc29sdmU6IGZhbHNlLFxuICAgICAgICBfdG1vOiBmYWxzZSxcbiAgICAgICAgX3ZhbHVlOiB2YWx1ZSxcbiAgICAgICAgY2hpbGRyZW46IGRlZHVwZShvcHRpb25zLmNoaWxkcmVuIHx8IFtdKSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBob29rOiBjcmVhdGVIb29rcygpLFxuICAgICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1NldHRsZWQ6IHRydWUsXG4gICAgICAgIGxlZGdlcjogY3JlYXRlTGVkZ2VyKCksXG4gICAgICAgIG5hbWU6IGNyZWF0ZU5hbWUob3B0aW9ucyksXG4gICAgICAgIHBhcmVudDogb3B0aW9ucy5wYXJlbnQgfHwgbnVsbCxcbiAgICAgICAgcGx1Z2luczogbmV3IFNldCgpLFxuICAgICAgICBwcm9wczogY3JlYXRlUHJvcHModmFsdWUpLFxuICAgICAgICBzZXR0bGVkOiBQcm9taXNlLnJlc29sdmUodmFsdWUpLFxuICAgICAgICBzdG9yZTogY3JlYXRlU3RvcmUodHJ1ZSksXG4gICAgICAgIHRyYXBzOiBjcmVhdGVUcmFwcygpLFxuICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUgfHwgJ2lucHV0JyxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5vZGUgb2JqZWN0J3MgaW50ZXJuYWwgcHJvcGVydGllcy5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gaW5pdGlhbGl6ZVxuICogQHJldHVybnMgRm9ybUtpdE5vZGVcbiAqL1xuZnVuY3Rpb24gbm9kZUluaXQobm9kZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICAvLyBTZXQgdGhlIGludGVybmFsIG5vZGUgb24gdGhlIHByb3BzLCBjb25maWcsIGxlZGdlciBhbmQgc3RvcmVcbiAgICBub2RlLmxlZGdlci5pbml0KChub2RlLnN0b3JlLl9uID0gbm9kZS5wcm9wcy5fbiA9IG5vZGUuY29uZmlnLl9uID0gbm9kZSkpO1xuICAgIC8vIEFwcGx5IGdpdmVuIGluIG9wdGlvbnMgdG8gdGhlIG5vZGUuXG4gICAgbm9kZS5wcm9wcy5fZW1pdCA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnByb3BzKVxuICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUucHJvcHMsIG9wdGlvbnMucHJvcHMpO1xuICAgIG5vZGUucHJvcHMuX2VtaXQgPSB0cnVlO1xuICAgIC8vIEF0dGVtcHQgdG8gZmluZCBhIGRlZmluaXRpb24gZnJvbSB0aGUgcHJlLWV4aXN0aW5nIHBsdWdpbnMuXG4gICAgZmluZERlZmluaXRpb24obm9kZSwgbmV3IFNldChbXG4gICAgICAgIC4uLihvcHRpb25zLnBsdWdpbnMgfHwgW10pLFxuICAgICAgICAuLi4obm9kZS5wYXJlbnQgPyBub2RlLnBhcmVudC5wbHVnaW5zIDogW10pLFxuICAgIF0pKTtcbiAgICAvLyBUaGVuIHdlIGFwcGx5IGVhY2ggcGx1Z2luJ3Mgcm9vdCBjb2RlLCB3ZSBkbyB0aGlzIHdpdGggYW4gZXhwbGljaXQgbG9vcFxuICAgIC8vIGZvciB0aGF0IGl0eS1iaXR0eSBwZXJmb3JtYW5jZSBidW1wLlxuICAgIGlmIChvcHRpb25zLnBsdWdpbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2Ygb3B0aW9ucy5wbHVnaW5zKSB7XG4gICAgICAgICAgICB1c2Uobm9kZSwgbm9kZS5fYywgcGx1Z2luLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBwcm9wc1xuICAgIGRlZmF1bHRQcm9wcyhub2RlKTtcbiAgICAvLyBBcHBseSB0aGUgcGFyZW50IHRvIGVhY2ggY2hpbGQuXG4gICAgbm9kZS5lYWNoKChjaGlsZCkgPT4gbm9kZS5hZGQoY2hpbGQpKTtcbiAgICAvLyBJZiB0aGUgbm9kZSBoYXMgYSBwYXJlbnQsIGVuc3VyZSBpdCdzIHByb3Blcmx5IG5lc3RlZCBiaS1kaXJlY3Rpb25hbGx5LlxuICAgIGlmIChub2RlLnBhcmVudClcbiAgICAgICAgbm9kZS5wYXJlbnQuYWRkKG5vZGUsIG9wdGlvbnMuaW5kZXgpO1xuICAgIC8vIElucHV0cyBhcmUgbGVhZnMsIGFuZCBjYW5ub3QgaGF2ZSBjaGlsZHJlblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdpbnB1dCcgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgIGVycm9yKDEwMCwgbm9kZSk7XG4gICAgLy8gQXBwbHkgdGhlIGlucHV0IGhvb2sgdG8gdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgaW5wdXQobm9kZSwgbm9kZS5fYywgbm9kZS5fdmFsdWUsIGZhbHNlKTtcbiAgICAvLyBSZWxlYXNlIHRoZSBzdG9yZSBidWZmZXJcbiAgICBub2RlLnN0b3JlLnJlbGVhc2UoKTtcbiAgICAvLyBSZWdpc3RlciB0aGUgbm9kZSBnbG9iYWxseSBpZiBzb21lb25lIGV4cGxpY2l0bHkgZ2F2ZSBpdCBhbiBpZFxuICAgIGlmICgoX2EgPSBvcHRpb25zLnByb3BzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpXG4gICAgICAgIHJlZ2lzdGVyKG5vZGUpO1xuICAgIC8vIE91ciBub2RlIGlzIGZpbmFsbHkgcmVhZHksIGVtaXQgaXQgdG8gdGhlIHdvcmxkXG4gICAgbm9kZS5lbWl0KCdjcmVhdGVkJywgbm9kZSk7XG4gICAgbm9kZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgRm9ybUtpdCBOb2RlLiBOb2RlcyBhcmUgdGhlIGF0b21pYyB1bml0IG9mXG4gKiBhIEZvcm1LaXQgZ3JhcGguXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgb2Ygb3B0aW9ucyB0byBkZWZpbmUgdGhlIG5vZGUuXG4gKiBAcmV0dXJucyBGb3JtS2l0Tm9kZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVOb2RlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG9wcyk7XG4gICAgLy8gTm90ZTogVGhlIHR5cGluZyBmb3IgdGhlIHByb3h5IG9iamVjdCBjYW5ub3QgYmUgZnVsbHkgbW9kZWxlZCwgdGh1cyB3ZSBhcmVcbiAgICAvLyBmb3JjZS10eXBpbmcgdG8gYSBGb3JtS2l0Tm9kZS4gU2VlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjgwNjdcbiAgICBjb25zdCBub2RlID0gbmV3IFByb3h5KGNvbnRleHQsIHtcbiAgICAgICAgZ2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IFssIHByb3BlcnR5XSA9IGFyZ3M7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICdfX0ZLTm9kZV9fJylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRyYXAgPSBjb250ZXh0LnRyYXBzLmdldChwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAodHJhcCAmJiB0cmFwLmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhcC5nZXQobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBbLCBwcm9wZXJ0eSwgdmFsdWVdID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IHRyYXAgPSBjb250ZXh0LnRyYXBzLmdldChwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAodHJhcCAmJiB0cmFwLnNldClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhcC5zZXQobm9kZSwgY29udGV4dCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCguLi5hcmdzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZUluaXQobm9kZSwgb3BzKTtcbn1cblxuLyoqXG4gKiBUeXBlIG5hcnJvdyB0aGF0IGEgbm9kZSBpcyBhIERPTSBub2RlLlxuICogQHBhcmFtIG5vZGUgLSBBIHNjaGVtYSBub2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc0RPTShub2RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBub2RlICE9PSAnc3RyaW5nJyAmJiBoYXMobm9kZSwgJyRlbCcpO1xufVxuLyoqXG4gKiBUeXBlIG5hcnJvdyB0aGF0IGEgbm9kZSBpcyBhIERPTSBub2RlLlxuICogQHBhcmFtIG5vZGUgLSBBIHNjaGVtYSBub2RlIHRvIGNoZWNrXG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc0NvbXBvbmVudChub2RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBub2RlICE9PSAnc3RyaW5nJyAmJiBoYXMobm9kZSwgJyRjbXAnKTtcbn1cbi8qKlxuICogUm9vdCBkZWNsYXJhdGlvbi5cbiAqIEBwYXJhbSBub2RlIC0gQW4gb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc0NvbmRpdGlvbmFsKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGhhcyhub2RlLCAnaWYnKSAmJiBoYXMobm9kZSwgJ3RoZW4nKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgbm9kZSBpcyBzeW50YWN0aWMgc3VnYXIgb3Igbm90LlxuICogQHBhcmFtIG5vZGUgLSBOb2RlXG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1N1Z2FyKG5vZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5vZGUgIT09ICdzdHJpbmcnICYmICckZm9ybWtpdCcgaW4gbm9kZTtcbn1cbi8qKlxuICogQ29udmVydHMgc3ludGFjdGljIHN1Z2FyIG5vZGVzIHRvIHN0YW5kYXJkIG5vZGVzLlxuICogQHBhcmFtIG5vZGUgLSBBIG5vZGUgdG8gY292ZXJ0XG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzdWdhcihub2RlKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGVsOiAndGV4dCcsXG4gICAgICAgICAgICBjaGlsZHJlbjogbm9kZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzU3VnYXIobm9kZSkpIHtcbiAgICAgICAgY29uc3QgeyAkZm9ybWtpdDogdHlwZSwgZm9yOiBpdGVyYXRvciwgaWY6IGNvbmRpdGlvbiwgY2hpbGRyZW4sIGtleSwgYmluZCwgLi4ucHJvcHMgfSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICRjbXA6ICdGb3JtS2l0JyxcbiAgICAgICAgICAgIHByb3BzOiB7IC4uLnByb3BzLCB0eXBlIH0sXG4gICAgICAgIH0sIGNvbmRpdGlvbiA/IHsgaWY6IGNvbmRpdGlvbiB9IDoge30sIGl0ZXJhdG9yID8geyBmb3I6IGl0ZXJhdG9yIH0gOiB7fSwgY2hpbGRyZW4gPyB7IGNoaWxkcmVuIH0gOiB7fSwga2V5ID8geyBrZXkgfSA6IHt9LCBiaW5kID8geyBiaW5kIH0gOiB7fSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIENvbXBpbGVzIGEgbG9naWNhbCBzdHJpbmcgbGlrZSBcImEgIT0geiB8fCBiID09IGNcIiBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhIFwicHJvdmlkZVwiIG1ldGhvZCB0aGF0IGl0ZXJhdGVzIG92ZXIgYWxsXG4gKiByZXF1aXJlbWVudCB0b2tlbnMgdG8gdXNlIGFzIHJlcGxhY2VtZW50cy5cbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGxldCBuYW1lID0ge1xuICogICB2YWx1ZTogJ2pvbidcbiAqIH1cbiAqIGNvbnN0IGNvbmRpdGlvbiA9IGNvbXBpbGUoXCIkbmFtZSA9PSAnYm9iJ1wiKS5wcm92aWRlKCh0b2tlbikgPT4ge1xuICogIHJldHVybiAoKSA9PiBuYW1lLnZhbHVlIC8vIG11c3QgcmV0dXJuIGEgZnVuY3Rpb24hXG4gKiB9KVxuICpcbiAqIGNvbmRpdGlvbigpIC8vIGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSBleHByIC0gQSBzdHJpbmcgdG8gY29tcGlsZVxuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY29tcGlsZShleHByKSB7XG4gICAgLyoqXG4gICAgICogVGhlc2UgdG9rZW5zIGFyZSByZXBsYWNlbWVudHMgdXNlZCBpbiBldmFsdWF0aW5nIGEgZ2l2ZW4gY29uZGl0aW9uLlxuICAgICAqL1xuICAgIC8vIGNvbnN0IHRva2VuczogRm9ybUtpdFRva2VucyA9IHt9XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlKCkgY2FsbGJhY2suIFVzZWQgZm9yIGxhdGUgYmluZGluZy5cbiAgICAgKi9cbiAgICBsZXQgcHJvdmlkZVRva2VucztcbiAgICAvKipcbiAgICAgKiBUaGVzZSBhcmUgdG9rZW4gcmVxdWlyZW1lbnRzIGxpa2UgXCIkbmFtZS52YWx1ZVwiIHRoYXQgYXJlIG5lZWQgdG8gZnVsZmlsbFxuICAgICAqIGEgZ2l2ZW4gY29uZGl0aW9uIGNhbGwuXG4gICAgICovXG4gICAgY29uc3QgcmVxdWlyZW1lbnRzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIGN1cnJlbnQgdmFsdWUgaWYgaXQgaXMgYSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3BlcmFuZCAtIEEgbGVmdCBvciByaWdodCBoYW5kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNvbnN0IHggPSBmdW5jdGlvbiBleHBhbmQob3BlcmFuZCwgdG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3BlcmFuZCA9PT0gJ2Z1bmN0aW9uJyA/IG9wZXJhbmQodG9rZW5zKSA6IG9wZXJhbmQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wcmVoZW5zaXZlIGxpc3Qgb2Ygb3BlcmF0b3JzLiBUaGlzIGxpc3QgTVVTVCBiZVxuICAgICAqIG9yZGVyZWQgYnkgdGhlIGxlbmd0aCBvZiB0aGUgb3BlcmF0b3IgY2hhcmFjdGVycyBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqL1xuICAgIGNvbnN0IG9wZXJhdG9yUmVnaXN0cnkgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgICcmJic6IChsLCByLCB0KSA9PiB4KGwsIHQpICYmIHgociwgdCksXG4gICAgICAgICAgICAnfHwnOiAobCwgciwgdCkgPT4geChsLCB0KSB8fCB4KHIsIHQpLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAnPT09JzogKGwsIHIsIHQpID0+ICEhKHgobCwgdCkgPT09IHgociwgdCkpLFxuICAgICAgICAgICAgJyE9PSc6IChsLCByLCB0KSA9PiAhISh4KGwsIHQpICE9PSB4KHIsIHQpKSxcbiAgICAgICAgICAgICc9PSc6IChsLCByLCB0KSA9PiAhISh4KGwsIHQpID09IHgociwgdCkpLFxuICAgICAgICAgICAgJyE9JzogKGwsIHIsIHQpID0+ICEhKHgobCwgdCkgIT0geChyLCB0KSksXG4gICAgICAgICAgICAnPj0nOiAobCwgciwgdCkgPT4gISEoeChsLCB0KSA+PSB4KHIsIHQpKSxcbiAgICAgICAgICAgICc8PSc6IChsLCByLCB0KSA9PiAhISh4KGwsIHQpIDw9IHgociwgdCkpLFxuICAgICAgICAgICAgJz4nOiAobCwgciwgdCkgPT4gISEoeChsLCB0KSA+IHgociwgdCkpLFxuICAgICAgICAgICAgJzwnOiAobCwgciwgdCkgPT4gISEoeChsLCB0KSA8IHgociwgdCkpLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAnKyc6IChsLCByLCB0KSA9PiB4KGwsIHQpICsgeChyLCB0KSxcbiAgICAgICAgICAgICctJzogKGwsIHIsIHQpID0+IHgobCwgdCkgLSB4KHIsIHQpLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAnKic6IChsLCByLCB0KSA9PiB4KGwsIHQpICogeChyLCB0KSxcbiAgICAgICAgICAgICcvJzogKGwsIHIsIHQpID0+IHgobCwgdCkgLyB4KHIsIHQpLFxuICAgICAgICAgICAgJyUnOiAobCwgciwgdCkgPT4geChsLCB0KSAlIHgociwgdCksXG4gICAgICAgIH0sXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bGwgbGlzdCBvZiBhbGwgb3BlcmF0b3Igc3ltYm9scy5cbiAgICAgKi9cbiAgICBjb25zdCBvcGVyYXRvclN5bWJvbHMgPSBvcGVyYXRvclJlZ2lzdHJ5LnJlZHVjZSgocywgZykgPT4ge1xuICAgICAgICByZXR1cm4gcy5jb25jYXQoT2JqZWN0LmtleXMoZykpO1xuICAgIH0sIFtdKTtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGVhY2ggb3BlcmF0b3IuXG4gICAgICovXG4gICAgY29uc3Qgb3BlcmF0b3JDaGFycyA9IG5ldyBTZXQob3BlcmF0b3JTeW1ib2xzLm1hcCgoa2V5KSA9PiBrZXkuY2hhckF0KDApKSk7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgdGhlIHN0YXJ0IG9mIGFuIG9wZXJhdG9yIHN5bWJvbCwgaWYgaXRcbiAgICAgKiBpcywgaXQgcmV0dXJucyB0aGF0IHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gc3ltYm9scyAtIEFuIGFycmF5IG9mIHN5bWJvbHMgdGhhdCBhcmUgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAgKiBAcGFyYW0gY2hhciAtIFRoZSBjdXJyZW50IGNoYXJhY3RlciBiZWluZyBvcGVyYXRlZCBvblxuICAgICAqIEBwYXJhbSBwIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyXG4gICAgICogQHBhcmFtIGV4cHJlc3Npb24gLSBUaGUgZnVsbCBzdHJpbmcgZXhwcmVzc2lvblxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T3Aoc3ltYm9scywgY2hhciwgcCwgZXhwcmVzc2lvbikge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gc3ltYm9scy5maWx0ZXIoKHMpID0+IHMuc3RhcnRzV2l0aChjaGFyKSk7XG4gICAgICAgIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVzLmZpbmQoKHN5bWJvbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID49IHAgKyBzeW1ib2wubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXJzID0gZXhwcmVzc2lvbi5zdWJzdHJpbmcocCwgcCArIHN5bWJvbC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhcnMgPT09IHN5bWJvbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIHN0ZXAgbnVtYmVyIG9mIHRoZSByaWdodCBvciBsZWZ0IGhhbmQgb3BlcmF0b3IuXG4gICAgICogQHBhcmFtIHAgLSBUaGUgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXJcbiAgICAgKiBAcGFyYW0gZXhwcmVzc2lvbiAtIFRoZSBmdWxsIHN0cmluZyBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiAtIDEgPSByaWdodCwgMCA9IGxlZnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdGVwKHAsIGV4cHJlc3Npb24sIGRpcmVjdGlvbiA9IDEpIHtcbiAgICAgICAgbGV0IG5leHQgPSBkaXJlY3Rpb25cbiAgICAgICAgICAgID8gZXhwcmVzc2lvbi5zdWJzdHJpbmcocCArIDEpLnRyaW0oKVxuICAgICAgICAgICAgOiBleHByZXNzaW9uLnN1YnN0cmluZygwLCBwKS50cmltKCk7XG4gICAgICAgIGlmICghbmV4dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBsZWZ0IGhhbmQgZGlyZWN0aW9uIGNvdWxkIGluY2x1ZGUgYSBmdW5jdGlvbiBuYW1lIHdlIG5lZWQgdG8gcmVtb3ZlXG4gICAgICAgICAgICBjb25zdCByZXZlcnNlZCA9IG5leHQuc3BsaXQoJycpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcmV2ZXJzZWQuZmluZEluZGV4KChjaGFyKSA9PiBvcGVyYXRvckNoYXJzLmhhcyhjaGFyKSk7XG4gICAgICAgICAgICBuZXh0ID0gcmV2ZXJzZWQuc2xpY2Uoc3RhcnQpLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYXIgPSBuZXh0WzBdO1xuICAgICAgICByZXR1cm4gb3BlcmF0b3JSZWdpc3RyeS5maW5kSW5kZXgoKG9wZXJhdG9ycykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5rZXlzKG9wZXJhdG9ycyk7XG4gICAgICAgICAgICByZXR1cm4gISFnZXRPcChzeW1ib2xzLCBjaGFyLCAwLCBuZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGEgdGFpbCBjYWxsLiBGb3IgZXhhbXBsZTpcbiAgICAgKiBgYGBcbiAgICAgKiAkZm9vKCkuYmFyKGJheikgKyA3XG4gICAgICogYGBgXG4gICAgICogV291bGQgZXh0cmFjdCBcImJhcihiYXopXCIgYW5kIHJldHVybiBwIG9mIDE1IChhZnRlciB0aGUgKGJheikpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHAgLSBUaGUgcG9zaXRpb24gb2YgYSBjbG9zaW5nIHBhcmVudGhldGljYWwuXG4gICAgICogQHBhcmFtIGV4cHJlc3Npb24gLSBUaGUgZnVsbCBleHByZXNzaW9uIGJlaW5nIHBhcnNlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRUYWlsKHBvcywgZXhwcmVzc2lvbikge1xuICAgICAgICBsZXQgdGFpbCA9ICcnO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHByZXNzaW9uLmxlbmd0aDtcbiAgICAgICAgbGV0IGRlcHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgcCA9IHBvczsgcCA8IGxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gZXhwcmVzc2lvbi5jaGFyQXQocCk7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PT0gMCAmJiBjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCAmJiBnZXRPcChvcGVyYXRvclN5bWJvbHMsIGNoYXIsIHAsIGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0YWlsLCBwIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWlsICs9IGNoYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0YWlsLCBleHByZXNzaW9uLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIHN0cmluZyBleHByZXNzaW9uIGludG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBib29sZWFuLiBUaGlzIGlzXG4gICAgICogdGhlIG1hZ2ljIGJlaGluZCBzY2hlbWEgbG9naWMgbGlrZSAkaWYuXG4gICAgICogQHBhcmFtIGV4cHJlc3Npb24gLSBBIHN0cmluZyBleHByZXNzaW9uIHRvIHBhcnNlXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUxvZ2ljYWxzKGV4cHJlc3Npb24sIHN0ZXAgPSAwKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdG9ycyA9IG9wZXJhdG9yUmVnaXN0cnlbc3RlcF07XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGV4cHJlc3Npb24ubGVuZ3RoO1xuICAgICAgICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmtleXMob3BlcmF0b3JzKTtcbiAgICAgICAgbGV0IGRlcHRoID0gMDtcbiAgICAgICAgbGV0IHF1b3RlID0gZmFsc2U7XG4gICAgICAgIGxldCBvcCA9IG51bGw7XG4gICAgICAgIGxldCBvcGVyYW5kID0gJyc7XG4gICAgICAgIGxldCBsZWZ0ID0gbnVsbDtcbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgbGV0IGxhc3RDaGFyID0gJyc7XG4gICAgICAgIGxldCBjaGFyID0gJyc7XG4gICAgICAgIGxldCBwYXJlbnRoZXRpY2FsID0gJyc7XG4gICAgICAgIGxldCBwYXJlblF1b3RlID0gJyc7XG4gICAgICAgIGxldCBzdGFydFAgPSAwO1xuICAgICAgICBjb25zdCBhZGRUbyA9IChkZXB0aCwgY2hhcikgPT4ge1xuICAgICAgICAgICAgZGVwdGggPyAocGFyZW50aGV0aWNhbCArPSBjaGFyKSA6IChvcGVyYW5kICs9IGNoYXIpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsYXN0Q2hhciA9IGNoYXI7XG4gICAgICAgICAgICBjaGFyID0gZXhwcmVzc2lvbi5jaGFyQXQocCk7XG4gICAgICAgICAgICBpZiAoKGNoYXIgPT09IFwiJ1wiIHx8IGNoYXIgPT09ICdcIicpICYmXG4gICAgICAgICAgICAgICAgbGFzdENoYXIgIT09ICdcXFxcJyAmJlxuICAgICAgICAgICAgICAgICgoZGVwdGggPT09IDAgJiYgIXF1b3RlKSB8fCAoZGVwdGggJiYgIXBhcmVuUXVvdGUpKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlblF1b3RlID0gY2hhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gY2hhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVG8oZGVwdGgsIGNoYXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHF1b3RlICYmIChjaGFyICE9PSBxdW90ZSB8fCBsYXN0Q2hhciA9PT0gJ1xcXFwnKSkgfHxcbiAgICAgICAgICAgICAgICAocGFyZW5RdW90ZSAmJiAoY2hhciAhPT0gcGFyZW5RdW90ZSB8fCBsYXN0Q2hhciA9PT0gJ1xcXFwnKSkpIHtcbiAgICAgICAgICAgICAgICBhZGRUbyhkZXB0aCwgY2hhcik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChxdW90ZSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWRkVG8oZGVwdGgsIGNoYXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW5RdW90ZSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgIHBhcmVuUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhZGRUbyhkZXB0aCwgY2hhcik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFAgPSBwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50aGV0aWNhbCArPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyZW50aGV0aWNhbCBzdGF0ZW1lbnRzIGNhbm5vdCBiZSBncm91cGVkIHVwIGluIHRoZSBpbXBsaWNpdCBvcmRlclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBsZWZ0L3JpZ2h0IHN0YXRlbWVudHMgYmFzZWQgb24gd2hpY2ggc3RlcCB0aGV5IGFyZSBvbiBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXkgYXJlIHBhcnNlZCBvbiBldmVyeSBzdGVwIGFuZCB0aGVuIG11c3QgYmUgYXBwbGllZCB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmF0b3IuIEV4YW1wbGU6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIDUgKyAoMykgKiAyXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIHlpZWxkIDExIG5vdCAxNi4gVGhpcyBvcmRlciBpcyBub3JtYWxseSBpbXBsaWNpdCBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VxdWVuY2Ugb2Ygb3BlcmF0b3JzIGJlaW5nIHBhcnNlZCwgYnV0IHdpdGggcGFyZW50aGVzaXMgdGhlIHBhcnNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcHBlbnMgZWFjaCB0aW1lLiBJbnN0ZWFkIHdlIG5lZWQgdG8ga25vdyBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBsZWZ0IG9yIHRoZSByaWdodCBoYW5kIG9wZXJhdG9yLiBUaGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2VuZXJhbCBhbGdvcml0aG0gaXM6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIERvZXMgdGhpcyBwYXJlbiBoYXZlIGFuIG9wZXJhdG9yIG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gSWYgbm90LCBpdCdzIHVubmVjZXNzYXJpbHkgd3JhcHBlZCAoMyArIDIpXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIElmIGl0IGRvZXMsIHRoZW4gd2hpY2ggb3JkZXIgb2Ygb3BlcmF0aW9uIGlzIGhpZ2hlc3Q/XG4gICAgICAgICAgICAgICAgICAgIC8vIDQuIFdhaXQgZm9yIHRoZSBoaWdoZXN0IG9yZGVyIG9mIG9wZXJhdGlvbiB0byBiaW5kIHRvIGFuIG9wZXJhdG9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyZW50aGV0aWNhbCBoYXMgYSBwcmVjZWRpbmcgdG9rZW4gbGlrZSAkZm4oMSArIDIpIHRoZW4gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBzdWJ0cmFjdCB0aGUgZXhpc3Rpbmcgb3BlcmFuZCBsZW5ndGggZnJvbSB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBsZWZ0IG9yIHJpZ2h0IG9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbiA9IHR5cGVvZiBvcGVyYW5kID09PSAnc3RyaW5nJyAmJiBvcGVyYW5kLnN0YXJ0c1dpdGgoJyQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBvcGVyYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzVGFpbCA9IGZuICYmIGV4cHJlc3Npb24uY2hhckF0KHAgKyAxKSA9PT0gJy4nO1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoZSBmdW5jdGlvbiBoYXMgYSBjaGFpbmVkIHRhaWwgY2FsbDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhaWwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1RhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0YWlsLCBwXSA9IGdldFRhaWwocCArIDIsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxTdGVwID0gb3AgPyBzdGVwIDogZ2V0U3RlcChzdGFydFAsIGV4cHJlc3Npb24sIDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByU3RlcCA9IGdldFN0ZXAocCwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsU3RlcCA9PT0gLTEgJiYgclN0ZXAgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHBhcmVudGhldGljYWwgd2FzIHVubmVjZXNzYXJpbHkgd3JhcHBlZCBhdCB0aGUgcm9vdCwgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIGFyZSBhcmdzIG9mIGEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhbmQgPSBldmFsdWF0ZShwYXJlbnRoZXRpY2FsLCAtMSwgZm4sIHRhaWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wICYmIChsU3RlcCA+PSByU3RlcCB8fCByU3RlcCA9PT0gLTEpICYmIHN0ZXAgPT09IGxTdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXMgYSBsZWZ0IGhhbmQgb3BlcmF0b3Igd2l0aCBhIGhpZ2hlciBvcmRlciBvZiBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBvcC5iaW5kKG51bGwsIGV2YWx1YXRlKHBhcmVudGhldGljYWwsIC0xLCBmbiwgdGFpbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmFuZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJTdGVwID4gbFN0ZXAgJiYgc3RlcCA9PT0gclN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSByaWdodCBoYW5kIG9wZXJhdG9yIHdoZW4gaXQgZ2V0cyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhbmQgPSBldmFsdWF0ZShwYXJlbnRoZXRpY2FsLCAtMSwgZm4sIHRhaWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmFuZCArPSBgKCR7cGFyZW50aGV0aWNhbH0pJHtoYXNUYWlsID8gYC4ke3RhaWx9YCA6ICcnfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50aGV0aWNhbCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50aGV0aWNhbCArPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID09PSAwICYmXG4gICAgICAgICAgICAgICAgKG9wZXJhdGlvbiA9IGdldE9wKHN5bWJvbHMsIGNoYXIsIHAsIGV4cHJlc3Npb24pKSkge1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKDEwMywgW29wZXJhdGlvbiwgZXhwcmVzc2lvbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBpZGVudGlmaWVkIHRoZSBvcGVyYXRvciBieSBsb29raW5nIGFoZWFkIGluIHRoZSBzdHJpbmcsIHNvIHdlIG5lZWRcbiAgICAgICAgICAgICAgICAvLyBvdXIgcG9zaXRpb24gdG8gbW92ZSBwYXN0IHRoZSBvcGVyYXRvclxuICAgICAgICAgICAgICAgIHAgKz0gb3BlcmF0aW9uLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IGV4cHJlc3Npb24ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcigxMDQsIFtvcGVyYXRpb24sIGV4cHJlc3Npb25dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCaW5kIHRoZSBsZWZ0IGhhbmQgb3BlcmFuZFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlJ3ZlIGFscmVhZHkgcGFyc2VkIHRoZSBsZWZ0IGhhbmQgb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0b3JzW29wZXJhdGlvbl0uYmluZChudWxsLCBldmFsdWF0ZShsZWZ0LCBzdGVwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0b3JzW29wZXJhdGlvbl0uYmluZChudWxsLCBldmFsdWF0ZShvcGVyYW5kLCBzdGVwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYW5kID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlcmFuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCaW5kIHRoZSByaWdodCBoYW5kIG9wZXJhbmQsIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBleHByZXNzaW9uIGFzIGEgbmV3IGxlZnQgaGFuZCBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gb3AuYmluZChudWxsLCBldmFsdWF0ZShvcGVyYW5kLCBzdGVwKSk7XG4gICAgICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0b3JzW29wZXJhdGlvbl0uYmluZChudWxsLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmFuZCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFRvKGRlcHRoLCBjaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3BlcmFuZCAmJiBvcCkge1xuICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBsZWZ0IHdpdGggYW4gb3BlcmFuZCBhZnRlciB0aGUgbG9vcCwgYW5kIGFuIG9wLCBpdCBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHRoZSByaWdodCBoYW5kIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICBvcCA9IG9wLmJpbmQobnVsbCwgZXZhbHVhdGUob3BlcmFuZCwgc3RlcCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW4gb3AsIGJ1dCB3ZSBkbyBoYXZlIGEgbGVmdCBoYW5kIGFzc2lnbm1lbnQsIHRoZW4gdGhhdFxuICAgICAgICAvLyBpcyBhY3R1YWxseSBvdXIgb3BlcmF0b3IsIHNvIGp1c3QgcmUtYXNzaWduIGl0IHRvIG9wXG4gICAgICAgIG9wID0gIW9wICYmIGxlZnQgPyBsZWZ0IDogb3A7XG4gICAgICAgIGlmICghb3AgJiYgb3BlcmFuZCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgb3AgYnV0IHdlIGRvIGhhdmUgYW4gb3BlcmFuZCBzbyB0aGVyZSBpcyBubyBib29sZWFuXG4gICAgICAgICAgICAvLyBsb2dpYyB0byBwZXJmb3JtLCBidXQgdGhhdCBvcGVyYW5kIHN0aWxsIG1lYW5zIHNvbWV0aGluZyBzbyB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBldmFsdWF0ZSBpdCBhbmQgcmV0dXJuIGl0IGFzIGEgZnVuY3Rpb25cbiAgICAgICAgICAgIG9wID0gKHYsIHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdmdW5jdGlvbicgPyB2KHQpIDogdjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvcCA9IG9wLmJpbmQobnVsbCwgZXZhbHVhdGUob3BlcmFuZCwgc3RlcCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3AgJiYgIW9wZXJhbmQpIHtcbiAgICAgICAgICAgIGVycm9yKDEwNSwgZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHN0cmluZyBsaWtlICckbmFtZT09Ym9iYnknIGV2YWx1YXRlIGl0IHRvIHRydWUgb3IgZmFsc2VcbiAgICAgKiBAcGFyYW0gb3BlcmFuZCAtIEEgbGVmdCBvciByaWdodCBib29sZWFuIG9wZXJhbmQg4oCUIHVzdWFsbHkgY29uZGl0aW9uc1xuICAgICAqIEBwYXJhbSBzdGVwIC0gVGhlIGN1cnJlbnQgb3JkZXIgb2Ygb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGZuVG9rZW4gLSBUaGUgdG9rZW4gKHN0cmluZykgcmVwcmVzZW50YXRpb24gb2YgYSBmdW5jdGlvbiBiZWluZyBjYWxsZWRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlKG9wZXJhbmQsIHN0ZXAsIGZuVG9rZW4sIHRhaWwgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgKSB7XG4gICAgICAgIGlmIChmblRva2VuKSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IGV2YWx1YXRlKGZuVG9rZW4sIG9wZXJhdG9yUmVnaXN0cnkubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCB1c2VyRnVuY1JldHVybjtcbiAgICAgICAgICAgIC8vIFwiVGFpbCBjYWxsc1wiIGFyZSBkb3QgYWNjZXNzb3JzIGFmdGVyIGEgZnVuY3Rpb24gJGZvbygpLnZhbHVlLiBXZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBjb21waWxlIHRhaWwgY2FsbHMsIGFuZCB0aGVuIHByb3ZpZGUgdGhlIGZ1bmN0aW9uIHJlc3VsdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGV4cG9zZWQgdG9rZW5zLlxuICAgICAgICAgICAgbGV0IHRhaWxDYWxsID0gdGFpbFxuICAgICAgICAgICAgICAgID8gY29tcGlsZShgJCR7dGFpbH1gKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHBhcnNlQXJncyhTdHJpbmcob3BlcmFuZCkpLm1hcCgoYXJnKSA9PiBldmFsdWF0ZShhcmcsIC0xKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0b2tlbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckZ1bmMgPSBmbih0b2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVzZXJGdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKDE1MCwgZm5Ub2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlckZ1bmM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckZ1bmNSZXR1cm4gPSB1c2VyRnVuYyguLi5hcmdzLm1hcCgoYXJnKSA9PiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKHRva2VucykgOiBhcmcpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhaWxDYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWlsQ2FsbCA9IHRhaWxDYWxsLnByb3ZpZGUoKHN1YlRva2VucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RUb2tlbnMgPSBwcm92aWRlVG9rZW5zKHN1YlRva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHN1YlRva2Vucy5yZWR1Y2UoKHRva2VuU2V0LCB0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1RhaWwgPSB0b2tlbiA9PT0gdGFpbCB8fCAodGFpbCA9PT0gbnVsbCB8fCB0YWlsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWlsLnN0YXJ0c1dpdGgoYCR7dG9rZW59KGApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRBdCh1c2VyRnVuY1JldHVybiwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5TZXRbdG9rZW5dID0gKCkgPT4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblNldFt0b2tlbl0gPSByb290VG9rZW5zW3Rva2VuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5TZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhaWxDYWxsID8gdGFpbENhbGwoKSA6IHVzZXJGdW5jUmV0dXJuO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyB0aGUgd29yZCB0cnVlIG9yIGZhbHNlIHdpbGwgbmV2ZXIgY29udGFpbiBmdXJ0aGVyIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIGlmIChvcGVyYW5kID09PSAndHJ1ZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAob3BlcmFuZCA9PT0gJ2ZhbHNlJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAob3BlcmFuZCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIFRydWx5IHF1b3RlcyBzdHJpbmdzIGNhbm5vdCBjb250YWluIGFuIG9wZXJhdGlvbiwgcmV0dXJuIHRoZSBzdHJpbmdcbiAgICAgICAgICAgIGlmIChpc1F1b3RlZFN0cmluZyhvcGVyYW5kKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcm1Fc2NhcGVzKG9wZXJhbmQuc3Vic3RyaW5nKDEsIG9wZXJhbmQubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgLy8gQWN0dWFsIG51bWJlcnMgY2Fubm90IGJlIGNvbnRhaW4gYW4gb3BlcmF0aW9uXG4gICAgICAgICAgICBpZiAoIWlzTmFOKCtvcGVyYW5kKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKG9wZXJhbmQpO1xuICAgICAgICAgICAgaWYgKHN0ZXAgPCBvcGVyYXRvclJlZ2lzdHJ5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VMb2dpY2FscyhvcGVyYW5kLCBzdGVwICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmFuZC5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZCA9IG9wZXJhbmQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlbWVudHMuYWRkKGNsZWFuZWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0VG9rZW4odG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xlYW5lZCBpbiB0b2tlbnMgPyB0b2tlbnNbY2xlYW5lZF0oKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gdW5xdW90ZWQgc3RyaW5nLCBqdXN0IHRyZWF0IGl0XG4gICAgICAgICAgICAgICAgLy8gYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBpbGUgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBjb25zdCBjb21waWxlZCA9IHBhcnNlTG9naWNhbHMoZXhwci5zdGFydHNXaXRoKCckOicpID8gZXhwci5zdWJzdHJpbmcoMikgOiBleHByKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGNvbXBpbGVkIHJlcXVpcmVtZW50cyB0byBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBjb25zdCByZXFzID0gQXJyYXkuZnJvbShyZXF1aXJlbWVudHMpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHRva2VuIHZhbHVlcyB2aWEgY2FsbGJhY2sgdG8gY29tcGlsZWQgb3V0cHV0LlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdGhhdCBuZWVkcyB0byBwcm92aWRlIGFsbCB0b2tlbiByZXF1aXJlbWVudHNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3ZpZGUoY2FsbGJhY2spIHtcbiAgICAgICAgcHJvdmlkZVRva2VucyA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihjb21waWxlZC5iaW5kKG51bGwsIGNhbGxiYWNrKHJlcXMpKSwge1xuICAgICAgICAgICAgcHJvdmlkZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNvbXBpbGVkLCB7XG4gICAgICAgIHByb3ZpZGUsXG4gICAgfSk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhIHN0YW5kYXJkaXplZCBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgQ1NTIGNsYXNzZXNcbiAqIEBwYXJhbSBwcm9wZXJ0eUtleSAtIHNlY3Rpb24ga2V5XG4gKiBAcGFyYW0gbm9kZSAtIEZvcm1LaXQgbm9kZVxuICogQHBhcmFtIHNlY3Rpb25DbGFzc0xpc3QgLSBUaGluZ3MgdG8gdHVybiBpbnRvIGNsYXNzZXNcbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzZXMocHJvcGVydHlLZXksIG5vZGUsIHNlY3Rpb25DbGFzc0xpc3QpIHtcbiAgICBpZiAoIXNlY3Rpb25DbGFzc0xpc3QpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBpZiAodHlwZW9mIHNlY3Rpb25DbGFzc0xpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzS2V5cyA9IHNlY3Rpb25DbGFzc0xpc3Quc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIGNsYXNzS2V5cy5yZWR1Y2UoKG9iaiwga2V5KSA9PiBPYmplY3QuYXNzaWduKG9iaiwgeyBba2V5XTogdHJ1ZSB9KSwge30pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2VjdGlvbkNsYXNzTGlzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2xhc3Nlcyhwcm9wZXJ0eUtleSwgbm9kZSwgc2VjdGlvbkNsYXNzTGlzdChub2RlLCBwcm9wZXJ0eUtleSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2VjdGlvbkNsYXNzTGlzdDtcbn1cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgY2xhc3MgbGlzdHMgaW50byBhIHNpbmdsZSBsaXN0XG4gKiBAcGFyYW0gbm9kZSAtIHRoZSBGb3JtS2l0IG5vZGUgYmVpbmcgb3BlcmF0ZWQgb25cbiAqIEBwYXJhbSBwcm9wZXJ0eSAtIFRoZSBwcm9wZXJ0eSBrZXkgdG8gd2hpY2ggdGhlIGNsYXNzIGxpc3Qgd2lsbCBiZSBhcHBsaWVkXG4gKiBAcGFyYW0gYXJncyAtIENTUyBjbGFzcyBsaXN0KHMpXG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUNsYXNzTGlzdChub2RlLCBwcm9wZXJ0eSwgLi4uYXJncykge1xuICAgIGNvbnN0IGNvbWJpbmVkQ2xhc3NMaXN0ID0gYXJncy5yZWR1Y2UoKGZpbmFsQ2xhc3NMaXN0LCBjdXJyZW50Q2xhc3NMaXN0KSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudENsYXNzTGlzdClcbiAgICAgICAgICAgIHJldHVybiBmaW5hbENsYXNzTGlzdDtcbiAgICAgICAgY29uc3QgeyAkcmVzZXQsIC4uLmNsYXNzTGlzdCB9ID0gY3VycmVudENsYXNzTGlzdDtcbiAgICAgICAgaWYgKCRyZXNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzTGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihmaW5hbENsYXNzTGlzdCwgY2xhc3NMaXN0KTtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIChPYmplY3Qua2V5cyhub2RlLmhvb2suY2xhc3Nlcy5kaXNwYXRjaCh7IHByb3BlcnR5LCBjbGFzc2VzOiBjb21iaW5lZENsYXNzTGlzdCB9KVxuICAgICAgICAuY2xhc3NlcylcbiAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBjb21iaW5lZENsYXNzTGlzdFtrZXldKVxuICAgICAgICAuam9pbignICcpIHx8IG51bGwpO1xufVxuXG4vKipcbiAqIFNldHMgZXJyb3JzIG9uIGEgZm9ybSwgZ3JvdXAsIG9yIGlucHV0LlxuICogQHBhcmFtIGZvcm1JZCAtIFRoZSBpZCBvZiBhIGZvcm1cbiAqIEBwYXJhbSBsb2NhbEVycm9ycyAtIFRoZSBlcnJvcnMgdG8gc2V0IG9uIHRoZSBmb3JtIG9yIHRoZSBmb3Jt4oCZcyBpbnB1dHNcbiAqIEBwYXJhbSBjaGlsZEVycm9ycyAtIChvcHRpb25hbCkgVGhlIGVycm9ycyB0byBzZXQgb24gdGhlIGZvcm0gb3IgdGhlIGZvcm3igJlzIGlucHV0c1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXRFcnJvcnMoaWQsIGxvY2FsRXJyb3JzLCBjaGlsZEVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoaWQpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUuc2V0RXJyb3JzKGxvY2FsRXJyb3JzLCBjaGlsZEVycm9ycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuKDY1MSwgaWQpO1xuICAgIH1cbn1cbi8qKlxuICogQ2xlYXJzIGNoaWxkIGVycm9ycy5cbiAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgbm9kZSB5b3Ugd2FudCB0byBjbGVhciBlcnJvcnMgZm9yXG4gKiBAcGFyYW0gY2xlYXJDaGlsZHJlbiAtIERldGVybWluZXMgaWYgdGhlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUgc2hvdWxkIGhhdmUgdGhlaXIgZXJyb3JzIGNsZWFyZWQuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXJyb3JzKGlkLCBjbGVhckNoaWxkcmVuID0gdHJ1ZSkge1xuICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlJDEoaWQpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUuY2xlYXJFcnJvcnMoY2xlYXJDaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuKDY1MiwgaWQpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgYmZzLCBjbGVhckVycm9ycywgY29tcGlsZSwgY3JlYXRlQ2xhc3NlcywgY3JlYXRlQ29uZmlnJDEgYXMgY3JlYXRlQ29uZmlnLCBjcmVhdGVNZXNzYWdlLCBjcmVhdGVOb2RlLCBjcmVhdGVWYWx1ZSwgZGVyZWdpc3RlciwgZXJyb3IsIGVycm9ySGFuZGxlciwgZ2VuZXJhdGVDbGFzc0xpc3QsIGdldE5vZGUkMSBhcyBnZXROb2RlLCBpc0NvbXBvbmVudCwgaXNDb25kaXRpb25hbCwgaXNET00sIGlzTGlzdCwgaXNOb2RlLCBpc1N1Z2FyLCBuYW1lcywgcmVnaXN0ZXIsIHJlc2V0LCByZXNldENvdW50LCByZXNldFJlZ2lzdHJ5LCBzZXRFcnJvcnMsIHN1Ym1pdEZvcm0sIHN1Z2FyLCB1c2UsIHVzZUluZGV4LCB2YWx1ZUluc2VydGVkLCB2YWx1ZU1vdmVkLCB2YWx1ZVJlbW92ZWQsIHdhcm4sIHdhcm5pbmdIYW5kbGVyLCB3YXRjaFJlZ2lzdHJ5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formkit/core/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/@formkit/dev/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@formkit/dev/dist/index.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"errors\": function() { return /* binding */ errors; },\n/* harmony export */   \"warnings\": function() { return /* binding */ warnings; }\n/* harmony export */ });\n/* harmony import */ var _formkit_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formkit/core */ \"./node_modules/@formkit/core/dist/index.mjs\");\n\n\nlet registered = false;\n/**\n * Catalog of the error message codes in FormKit.\n * @public\n */\nconst errors = {\n    /**\n     * FormKit errors:\n     */\n    100: ({ data: node }) => `Only groups, lists, and forms can have children (${node.name}).`,\n    101: ({ data: node }) => `You cannot directly modify the store (${node.name}). See: https://formkit.com/advanced/core#message-store`,\n    102: ({ data: [node, property], }) => `You cannot directly assign node.${property} (${node.name})`,\n    103: ({ data: [operator] }) => `Schema expressions cannot start with an operator (${operator})`,\n    104: ({ data: [operator, expression] }) => `Schema expressions cannot end with an operator (${operator} in \"${expression}\")`,\n    105: ({ data: expression }) => `Invalid schema expression: ${expression}`,\n    106: ({ data: name }) => `Cannot submit because (${name}) is not in a form.`,\n    107: ({ data: [node, value] }) => `Cannot set ${node.name} to non object value: ${value}`,\n    108: ({ data: [node, value] }) => `Cannot set ${node.name} to non array value: ${value}`,\n    /**\n     * FormKit vue errors:\n     */\n    600: ({ data: node }) => `Unknown input type${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} (\"${node.name}\")`,\n    601: ({ data: node }) => `Input definition${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} is missing a schema or component property (${node.name}).`,\n};\n/**\n * Catalog of the warning message codes in FormKit.\n * @public\n */\nconst warnings = {\n    /**\n     * Core warnings:\n     */\n    150: ({ data: fn }) => `Schema function \"${fn}()\" is not a valid function.`,\n    151: ({ data: id }) => `No form element with id: ${id}`,\n    152: ({ data: id }) => `No input element with id: ${id}`,\n    /**\n     * Input specific warnings:\n     */\n    350: ({ data: node }) => `Invalid options prop for radio input (${node.name}). See https://formkit.com/inputs/radio`,\n    /**\n     * Vue warnings:\n     */\n    650: 'Schema \"$get()\" must use the id of an input to access.',\n    651: ({ data: id }) => `Cannot setErrors() on \"${id}\" because no such id exists.`,\n    652: ({ data: id }) => `Cannot clearErrors() on \"${id}\" because no such id exists.`,\n    /**\n     * Deprecation warnings:\n     */\n};\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeErrors = (error, next) => {\n    if (error.code in errors) {\n        const err = errors[error.code];\n        error.message = typeof err === 'function' ? err(error) : err;\n    }\n    return next(error);\n};\nif (!registered)\n    (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.errorHandler)(decodeErrors);\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeWarnings = (warning, next) => {\n    if (warning.code in warnings) {\n        const warn = warnings[warning.code];\n        warning.message = typeof warn === 'function' ? warn(warning) : warn;\n    }\n    return next(warning);\n};\nif (!registered)\n    (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.warningHandler)(decodeWarnings);\nregistered = true;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvZGV2L2Rpc3QvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3Jta2l0L2Rldi9kaXN0L2luZGV4Lm1qcz8zMGZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVycm9ySGFuZGxlciwgd2FybmluZ0hhbmRsZXIgfSBmcm9tICdAZm9ybWtpdC9jb3JlJztcblxubGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbi8qKlxuICogQ2F0YWxvZyBvZiB0aGUgZXJyb3IgbWVzc2FnZSBjb2RlcyBpbiBGb3JtS2l0LlxuICogQHB1YmxpY1xuICovXG5jb25zdCBlcnJvcnMgPSB7XG4gICAgLyoqXG4gICAgICogRm9ybUtpdCBlcnJvcnM6XG4gICAgICovXG4gICAgMTAwOiAoeyBkYXRhOiBub2RlIH0pID0+IGBPbmx5IGdyb3VwcywgbGlzdHMsIGFuZCBmb3JtcyBjYW4gaGF2ZSBjaGlsZHJlbiAoJHtub2RlLm5hbWV9KS5gLFxuICAgIDEwMTogKHsgZGF0YTogbm9kZSB9KSA9PiBgWW91IGNhbm5vdCBkaXJlY3RseSBtb2RpZnkgdGhlIHN0b3JlICgke25vZGUubmFtZX0pLiBTZWU6IGh0dHBzOi8vZm9ybWtpdC5jb20vYWR2YW5jZWQvY29yZSNtZXNzYWdlLXN0b3JlYCxcbiAgICAxMDI6ICh7IGRhdGE6IFtub2RlLCBwcm9wZXJ0eV0sIH0pID0+IGBZb3UgY2Fubm90IGRpcmVjdGx5IGFzc2lnbiBub2RlLiR7cHJvcGVydHl9ICgke25vZGUubmFtZX0pYCxcbiAgICAxMDM6ICh7IGRhdGE6IFtvcGVyYXRvcl0gfSkgPT4gYFNjaGVtYSBleHByZXNzaW9ucyBjYW5ub3Qgc3RhcnQgd2l0aCBhbiBvcGVyYXRvciAoJHtvcGVyYXRvcn0pYCxcbiAgICAxMDQ6ICh7IGRhdGE6IFtvcGVyYXRvciwgZXhwcmVzc2lvbl0gfSkgPT4gYFNjaGVtYSBleHByZXNzaW9ucyBjYW5ub3QgZW5kIHdpdGggYW4gb3BlcmF0b3IgKCR7b3BlcmF0b3J9IGluIFwiJHtleHByZXNzaW9ufVwiKWAsXG4gICAgMTA1OiAoeyBkYXRhOiBleHByZXNzaW9uIH0pID0+IGBJbnZhbGlkIHNjaGVtYSBleHByZXNzaW9uOiAke2V4cHJlc3Npb259YCxcbiAgICAxMDY6ICh7IGRhdGE6IG5hbWUgfSkgPT4gYENhbm5vdCBzdWJtaXQgYmVjYXVzZSAoJHtuYW1lfSkgaXMgbm90IGluIGEgZm9ybS5gLFxuICAgIDEwNzogKHsgZGF0YTogW25vZGUsIHZhbHVlXSB9KSA9PiBgQ2Fubm90IHNldCAke25vZGUubmFtZX0gdG8gbm9uIG9iamVjdCB2YWx1ZTogJHt2YWx1ZX1gLFxuICAgIDEwODogKHsgZGF0YTogW25vZGUsIHZhbHVlXSB9KSA9PiBgQ2Fubm90IHNldCAke25vZGUubmFtZX0gdG8gbm9uIGFycmF5IHZhbHVlOiAke3ZhbHVlfWAsXG4gICAgLyoqXG4gICAgICogRm9ybUtpdCB2dWUgZXJyb3JzOlxuICAgICAqL1xuICAgIDYwMDogKHsgZGF0YTogbm9kZSB9KSA9PiBgVW5rbm93biBpbnB1dCB0eXBlJHt0eXBlb2Ygbm9kZS5wcm9wcy50eXBlID09PSAnc3RyaW5nJyA/ICcgXCInICsgbm9kZS5wcm9wcy50eXBlICsgJ1wiJyA6ICcnfSAoXCIke25vZGUubmFtZX1cIilgLFxuICAgIDYwMTogKHsgZGF0YTogbm9kZSB9KSA9PiBgSW5wdXQgZGVmaW5pdGlvbiR7dHlwZW9mIG5vZGUucHJvcHMudHlwZSA9PT0gJ3N0cmluZycgPyAnIFwiJyArIG5vZGUucHJvcHMudHlwZSArICdcIicgOiAnJ30gaXMgbWlzc2luZyBhIHNjaGVtYSBvciBjb21wb25lbnQgcHJvcGVydHkgKCR7bm9kZS5uYW1lfSkuYCxcbn07XG4vKipcbiAqIENhdGFsb2cgb2YgdGhlIHdhcm5pbmcgbWVzc2FnZSBjb2RlcyBpbiBGb3JtS2l0LlxuICogQHB1YmxpY1xuICovXG5jb25zdCB3YXJuaW5ncyA9IHtcbiAgICAvKipcbiAgICAgKiBDb3JlIHdhcm5pbmdzOlxuICAgICAqL1xuICAgIDE1MDogKHsgZGF0YTogZm4gfSkgPT4gYFNjaGVtYSBmdW5jdGlvbiBcIiR7Zm59KClcIiBpcyBub3QgYSB2YWxpZCBmdW5jdGlvbi5gLFxuICAgIDE1MTogKHsgZGF0YTogaWQgfSkgPT4gYE5vIGZvcm0gZWxlbWVudCB3aXRoIGlkOiAke2lkfWAsXG4gICAgMTUyOiAoeyBkYXRhOiBpZCB9KSA9PiBgTm8gaW5wdXQgZWxlbWVudCB3aXRoIGlkOiAke2lkfWAsXG4gICAgLyoqXG4gICAgICogSW5wdXQgc3BlY2lmaWMgd2FybmluZ3M6XG4gICAgICovXG4gICAgMzUwOiAoeyBkYXRhOiBub2RlIH0pID0+IGBJbnZhbGlkIG9wdGlvbnMgcHJvcCBmb3IgcmFkaW8gaW5wdXQgKCR7bm9kZS5uYW1lfSkuIFNlZSBodHRwczovL2Zvcm1raXQuY29tL2lucHV0cy9yYWRpb2AsXG4gICAgLyoqXG4gICAgICogVnVlIHdhcm5pbmdzOlxuICAgICAqL1xuICAgIDY1MDogJ1NjaGVtYSBcIiRnZXQoKVwiIG11c3QgdXNlIHRoZSBpZCBvZiBhbiBpbnB1dCB0byBhY2Nlc3MuJyxcbiAgICA2NTE6ICh7IGRhdGE6IGlkIH0pID0+IGBDYW5ub3Qgc2V0RXJyb3JzKCkgb24gXCIke2lkfVwiIGJlY2F1c2Ugbm8gc3VjaCBpZCBleGlzdHMuYCxcbiAgICA2NTI6ICh7IGRhdGE6IGlkIH0pID0+IGBDYW5ub3QgY2xlYXJFcnJvcnMoKSBvbiBcIiR7aWR9XCIgYmVjYXVzZSBubyBzdWNoIGlkIGV4aXN0cy5gLFxuICAgIC8qKlxuICAgICAqIERlcHJlY2F0aW9uIHdhcm5pbmdzOlxuICAgICAqL1xufTtcbi8qKlxuICogRGVjb2RlcyBhbiBlcnJvciB0aGF0IGlzIGJlaW5nIGVtaXR0ZWQgYW5kIGNvbnNvbGUgbG9ncyBpdC5cbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBjdXJyZW50bHkgYmVpbmcgaGFuZGxlZFxuICogQHBhcmFtIG5leHQgLSBDYWxsIGFkZGl0aW9uYWwgaGFuZGxlcnNcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGRlY29kZUVycm9ycyA9IChlcnJvciwgbmV4dCkgPT4ge1xuICAgIGlmIChlcnJvci5jb2RlIGluIGVycm9ycykge1xuICAgICAgICBjb25zdCBlcnIgPSBlcnJvcnNbZXJyb3IuY29kZV07XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSB0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nID8gZXJyKGVycm9yKSA6IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoZXJyb3IpO1xufTtcbmlmICghcmVnaXN0ZXJlZClcbiAgICBlcnJvckhhbmRsZXIoZGVjb2RlRXJyb3JzKTtcbi8qKlxuICogRGVjb2RlcyBhbiBlcnJvciB0aGF0IGlzIGJlaW5nIGVtaXR0ZWQgYW5kIGNvbnNvbGUgbG9ncyBpdC5cbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBjdXJyZW50bHkgYmVpbmcgaGFuZGxlZFxuICogQHBhcmFtIG5leHQgLSBDYWxsIGFkZGl0aW9uYWwgaGFuZGxlcnNcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGRlY29kZVdhcm5pbmdzID0gKHdhcm5pbmcsIG5leHQpID0+IHtcbiAgICBpZiAod2FybmluZy5jb2RlIGluIHdhcm5pbmdzKSB7XG4gICAgICAgIGNvbnN0IHdhcm4gPSB3YXJuaW5nc1t3YXJuaW5nLmNvZGVdO1xuICAgICAgICB3YXJuaW5nLm1lc3NhZ2UgPSB0eXBlb2Ygd2FybiA9PT0gJ2Z1bmN0aW9uJyA/IHdhcm4od2FybmluZykgOiB3YXJuO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dCh3YXJuaW5nKTtcbn07XG5pZiAoIXJlZ2lzdGVyZWQpXG4gICAgd2FybmluZ0hhbmRsZXIoZGVjb2RlV2FybmluZ3MpO1xucmVnaXN0ZXJlZCA9IHRydWU7XG5cbmV4cG9ydCB7IGVycm9ycywgd2FybmluZ3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formkit/dev/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/@formkit/i18n/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@formkit/i18n/dist/index.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ar\": function() { return /* binding */ ar; },\n/* harmony export */   \"createI18nPlugin\": function() { return /* binding */ createI18nPlugin; },\n/* harmony export */   \"cs\": function() { return /* binding */ cs; },\n/* harmony export */   \"da\": function() { return /* binding */ da; },\n/* harmony export */   \"date\": function() { return /* binding */ date; },\n/* harmony export */   \"de\": function() { return /* binding */ de; },\n/* harmony export */   \"en\": function() { return /* binding */ en; },\n/* harmony export */   \"es\": function() { return /* binding */ es; },\n/* harmony export */   \"fa\": function() { return /* binding */ fa; },\n/* harmony export */   \"fi\": function() { return /* binding */ fi; },\n/* harmony export */   \"fr\": function() { return /* binding */ fr; },\n/* harmony export */   \"fy\": function() { return /* binding */ fy; },\n/* harmony export */   \"he\": function() { return /* binding */ he; },\n/* harmony export */   \"hr\": function() { return /* binding */ hr; },\n/* harmony export */   \"id\": function() { return /* binding */ id; },\n/* harmony export */   \"it\": function() { return /* binding */ it; },\n/* harmony export */   \"ja\": function() { return /* binding */ ja; },\n/* harmony export */   \"ko\": function() { return /* binding */ ko; },\n/* harmony export */   \"list\": function() { return /* binding */ list; },\n/* harmony export */   \"locales\": function() { return /* binding */ locales; },\n/* harmony export */   \"nl\": function() { return /* binding */ nl; },\n/* harmony export */   \"order\": function() { return /* binding */ order; },\n/* harmony export */   \"pl\": function() { return /* binding */ pl; },\n/* harmony export */   \"pt\": function() { return /* binding */ pt; },\n/* harmony export */   \"ro\": function() { return /* binding */ ro; },\n/* harmony export */   \"ru\": function() { return /* binding */ ru; },\n/* harmony export */   \"sentence\": function() { return /* binding */ sentence; },\n/* harmony export */   \"sl\": function() { return /* binding */ sl; },\n/* harmony export */   \"sv\": function() { return /* binding */ sv; },\n/* harmony export */   \"th\": function() { return /* binding */ th; },\n/* harmony export */   \"tr\": function() { return /* binding */ tr; },\n/* harmony export */   \"vi\": function() { return /* binding */ vi; },\n/* harmony export */   \"zh\": function() { return /* binding */ zh; }\n/* harmony export */ });\n/* harmony import */ var _formkit_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formkit/utils */ \"./node_modules/@formkit/utils/dist/index.mjs\");\n\n\n/**\n * Given a string, convert it to sentence case.\n * @param item - The string to sentence case\n * @returns\n * @public\n */\nfunction sentence(str) {\n    return str[0].toUpperCase() + str.substr(1);\n}\n/**\n * Creates an oxford-comma separated list of items.\n * @param args - items to list out\n * @param conjunction - in: x, y, and z \"and\" is the conjunction to use\n * @returns\n * @public\n */\nfunction list(items, conjunction = 'or') {\n    return items.reduce((oxford, item, index) => {\n        oxford += item;\n        if (index <= items.length - 2 && items.length > 2) {\n            oxford += ', ';\n        }\n        if (index === items.length - 2) {\n            oxford += `${items.length === 2 ? ' ' : ''}${conjunction} `;\n        }\n        return oxford;\n    }, '');\n}\n/**\n * Given a string or a date return a nice human-readable version.\n * @param date - A string or a date.\n * @public\n */\nfunction date(date) {\n    const dateTime = typeof date === 'string' ? new Date(Date.parse(date)) : date;\n    if (!(dateTime instanceof Date)) {\n        return '(unknown)';\n    }\n    return new Intl.DateTimeFormat(undefined, {\n        dateStyle: 'medium',\n    }).format(dateTime);\n}\n/**\n * Orders two variables smallest to largest.\n * @param first - first argument\n * @param second - Second argument\n * @returns\n * @public\n */\nfunction order(first, second) {\n    return Number(first) >= Number(second) ? [second, first] : [first, second];\n}\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$q = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'إضافة',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'إزالة',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'إزالة الكل',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'عذرا، لم يتم تعبئة جميع الحقول بشكل صحيح.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'إرسال',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'لا يوجد ملف مختار',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$q = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `الرجاء قبول ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `يجب أن يكون ${sentence(name)} بعد ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `يجب أن يكون ${sentence(name)} في المستقبل.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `يمكن أن يحتوي ${sentence(name)} على أحرف أبجدية فقط.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `يمكن أن يحتوي ${sentence(name)} على أحرف وأرقام فقط.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `يمكن أن تحتوي ${sentence(name)} على أحرف ومسافات فقط.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `يجب أن يكون ${sentence(name)} قبل ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `يجب أن يكون ${sentence(name)} في الماضي.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `تمت تهيئة هذا الحقل بشكل غير صحيح ولا يمكن إرساله.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `يجب أن يكون ${sentence(name)} ما بين ${a} و ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} غير متطابق.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ليس تاريخًا صالحًا ، يرجى استخدام التنسيق ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'تمت تهيئة هذا الحقل بشكل غير صحيح ولا يمكن إرساله';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `يجب أن يكون ${sentence(name)} بين ${date(args[0])} و ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'الرجاء أدخال بريد إليكتروني صالح.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `لا ينتهي ${sentence(name)} بـ ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} ليست قيمة مسموح بها.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `يجب أن يكون ${sentence(name)} حرفًا واحدًا على الأقل.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `يجب أن يكون ${sentence(name)} أقل من أو يساوي ${max} حرفًا.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `يجب أن يكون ${sentence(name)} أكبر من أو يساوي ${min} حرفًا.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `يجب أن يكون ${sentence(name)} بين ${min} و ${max} حرفًا.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} ليست قيمة مسموح بها.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `لا يمكن أن يكون أكثر من ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `يجب أن يكون ${sentence(name)} أقل من أو يساوي ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'لا يسمح بتنسيقات الملفات.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `يجب أن يكون ${sentence(name)} من النوع: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `لا يمكن أن يكون أقل من ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `يجب أن يكون ${sentence(name)} على الأقل ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” ليس ${name} مسموحًا به.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} يجب ان يكون رقماً`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} مطلوب.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `لا يبدأ ${sentence(name)} بـ ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `الرجاء تضمين عنوان رابط صحيح.`;\n        /* </i18n> */\n    },\n};\n\nvar ar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$q,\n    validation: validation$q\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$p = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Přidat',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Odebrat',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Odebrat vše',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pardon, ale ne všechna pole jsou vyplněna správně.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Odeslat',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Žádný soubor nebyl vybrán',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$p = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Prosím, zaškrtněte ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} musí být po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musí být v budoucnosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} může obsahovat pouze písmena.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} může obsahovat pouze písmena a čísla.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} musí být před ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musí být v minulosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Toto pole bylo špatně nakonfigurováno a nemůže být odesláno.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} musí být mezi ${a} a ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nejsou shodná.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} není platné datum, prosím, použijte formát ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Toto pole bylo špatně nakonfigurováno a nemůže být odesláno.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} musí být mezi ${date(args[0])} a ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Prosím, zadejte platnou e-mailovou adresu.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nekončí na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} není povolená hodnota.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} musí mít nejméně jeden znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} může mít maximálně ${max} znaků.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} musí obsahovat minimálně ${min} znaků.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} musí být dlouhé ${min} až ${max} znaků.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} není povolená hodnota.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nelze použít více než ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} musí mít menší nebo rovno než ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nejsou nakonfigurovány povolené typy souborů.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} musí být typu: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Nelze mít méně než ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} musí být minimálně ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” není dovolená hodnota pro ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} musí být číslo.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je povinné.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nezačíná na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Zadejte, prosím, platnou URL adresu.`;\n        /* </i18n> */\n    },\n};\n\nvar cs = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$p,\n    validation: validation$p\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$o = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Tilføj',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Fjern',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Fjern alle',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Alle felter er ikke korrekt udfyldt.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Send',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ingen filer valgt',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$o = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Accepter venligst ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} skal være senere end ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} skal være i fremtiden.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver og tal.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver og mellemrum.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} skal være før ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} skal være før i dag.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} skal være mellem ${a} og ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} matcher ikke.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} er ikke gyldig, brug venligst formatet ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} skal være mellem ${date(args[0])} og ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Indtast venligst en gyldig email-adresse.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} slutter ikke med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} er ikke en gyldig værdi.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} skal være på mindst ét tegn.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} skal være på højst ${max} tegn.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} skal være på mindst ${min} tegn.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} skal være på mindst ${min} og højst ${max} tegn.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} er ikke en gyldig værdi.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Kan ikke have flere end ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} skal være mindre eller lig med ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Ingen filformater tilladt.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} skal være af filtypen: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Kan ikke have mindre end ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} skal være mindst ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” er ikke en tilladt ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} skal være et tal.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} er påkrævet.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} starter ikke med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Indtast venligst en gyldig URL.`;\n        /* </i18n> */\n    },\n};\n\nvar da = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$o,\n    validation: validation$o\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$n = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Hinzufügen',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Entfernen',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Alles entfernen',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Entschuldigung, nicht alle Felder wurden korrekt ausgefüllt.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Senden',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Keine Datei ausgewählt',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$n = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Bitte ${name} akzeptieren.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} muss nach dem ${date(args[0])} liegen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} muss in der Zukunft liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} darf nur Buchstaben enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} darf nur Buchstaben und Zahlen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} dürfen nur Buchstaben und Leerzeichen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} muss vor dem ${date(args[0])} liegen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} muss in der Vergangenheit liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dieses Feld wurde falsch konfiguriert und kann nicht übermittelt werden.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} muss zwischen ${args[0]} und ${args[1]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} stimmt nicht überein.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ist kein gültiges Datum im Format ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dieses Feld wurde falsch konfiguriert und kann nicht übermittelt werden.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} muss zwischen ${date(args[0])} und ${date(args[1])} liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'E-Mail Adresse ist ungültig.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} endet nicht mit ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} enthält einen ungültigen Wert.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} muss mindestens ein Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} darf maximal ${max} Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} muss mindestens ${min} Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} muss zwischen ${min} und ${max} Zeichen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} enthält einen ungültigen Wert.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Darf maximal ${args[0]} ${name} haben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} darf maximal ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Keine Dateiformate konfiguriert.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} muss vom Typ ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mindestens ${args[0]} ${name} erforderlich.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} muss mindestens ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” ist kein gültiger Wert für ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} muss eine Zahl sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} ist erforderlich.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} beginnt nicht mit ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `URL ist ungültig.`;\n        /* </i18n> */\n    },\n};\n\nvar de = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$n,\n    validation: validation$n\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$m = {\n    /**\n     * Shown on a button for adding additional items.\n     */\n    add: 'Add',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Remove',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Remove all',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, not all fields are filled out correctly.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Submit',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'No file chosen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$m = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Please accept the ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} must be after ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} must be in the future.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} can only contain alphabetical characters.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} can only contain letters and numbers.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} can only contain letters and spaces.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} must be before ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} must be in the past.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `This field was configured incorrectly and can’t be submitted.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} must be between ${a} and ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} does not match.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is not a valid date, please use the format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'This field was configured incorrectly and can’t be submitted';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} must be between ${date(args[0])} and ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Please enter a valid email address.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} doesn’t end with ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is not an allowed value.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} must be at least one character.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} must be less than or equal to ${max} characters.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} must be greater than or equal to ${min} characters.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} must be between ${min} and ${max} characters.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is not an allowed value.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Cannot have more than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} must be less than or equal to ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'No file formats allowed.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} must be of the type: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Cannot have less than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} must be at least ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” is not an allowed ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} must be a number.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is required.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} doesn’t start with ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Please include a valid url.`;\n        /* </i18n> */\n    },\n};\n\nvar en = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$m,\n    validation: validation$m\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$l = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Añadir',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Quitar',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Quitar todos',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Discúlpe, los campos no fueron completados correctamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Enviar',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Archivo no seleccionado',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$l = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Acepte el ${name} por favor.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} debe ser posterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} debe ser una fecha futura.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} debe contener solo caractéres alfabéticos.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} debe ser alfanumérico.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} espacios alfa solo pueden contener letras y espacios.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} debe ser anterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} debe ser una fecha pasada.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `El campo no fue completado correctamente y no puede ser enviado.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} debe estar entre ${a} y ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} no coincide.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} no es una fecha válida, por favor utilice el formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'El campo no fue completado correctamente y no puede ser enviado.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} debe estar entre ${date(args[0])} y ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Ingrese una dirección de correo electrónico válida por favor.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} no termina con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} no es un valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} debe tener al menos una letra.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} debe tener como máximo ${max} caractéres.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} debe tener como mínimo ${min} caractéres.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} debe tener entre ${min} y ${max} caractéres.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} no es un valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Cannot have more than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} debe ser menor o igual a ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'No existen formatos de archivos permitidos.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} debe ser del tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Cannot have less than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} debe ser de al menos ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” no es un valor permitido de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} debe ser un número.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} es requerido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} debe comenzar con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Proporcione una URL válida por favor.`;\n        /* </i18n> */\n    },\n};\n\nvar es = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$l,\n    validation: validation$l\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$k = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'افزودن',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'حذف',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'همه را حذف کنید',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'همه فیلدها به‌درستی پر نشده‌اند',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'ثبت',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'هیچ فایلی انتخاب نشده است',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$k = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `لطفاً ${name} را بپذیرید.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} باید بعد از تاریخ ${date(args[0])} باشد.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} باید مربوط به آینده باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} فقط میتواند شامل حروف الفبا باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} فقط میتواند شامل حروف و اعداد باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} فقط می تواند شامل حروف و فاصله باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} باید قبل از تاریخ ${date(args[0])} باشد.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} باید مربوط به گذشته باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `این فیلد به اشتباه پیکربندی شده است و قابل ارسال نیست`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} باید بین ${args[0]} و ${args[1]} باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} مطابقت ندارد.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} تاریخ معتبری نیست، لطفاً از قالب ${args[0]} استفاده کنید\n`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'این فیلد به اشتباه پیکربندی شده است و قابل ارسال نیست';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} باید بین ${date(args[0])} و ${date(args[1])} باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'لطفا آدرس ایمیل معتبر وارد کنید.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} باید به ${list(args)} ختم شود.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} مجاز نیست.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} باید حداقل یک کاراکتر باشد.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} باید کمتر یا برابر با ${max} کاراکتر باشد.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} باید بزرگتر یا برابر با ${min} کاراکتر باشد.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} باید بین ${min} و ${max} کاراکتر باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} مجاز نیست.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} نمی تواند بیش از ${args[0]} باشد.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} باید کمتر یا برابر با ${args[0]} باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'فرمت فایل مجاز نیست.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} باید از این نوع باشد: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} نمی تواند کمتر از ${args[0]} باشد.\n`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} باید حداقل ${args[0]} باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" یک ${name} مجاز نیست.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} باید عدد باشد.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `پر کردن ${sentence(name)} اجباری است.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} باید با ${list(args)} شروع شود.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `لطفاً آدرس اینترنتی معتبر وارد کنید.`;\n        /* </i18n> */\n    },\n};\n\nvar fa = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$k,\n    validation: validation$k\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$j = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Lisää',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Poista',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Poista kaikki',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Kaikkia kenttiä ei ole täytetty oikein.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Tallenna',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ei valittuja tiedostoja',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$j = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Ole hyvä ja hyväksy ${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} tulee olla ${date(args[0])} jälkeen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} on oltava tulevaisuudessa.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} saa sisältää vain kirjaimia.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} saa sisältää vain kirjaimia ja numeroita.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} voivat sisältää vain kirjaimia ja välilyöntejä.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} tulee olla ennen: ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} on oltava menneisyydessä.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Tämä kenttä on täytetty virheellisesti joten sitä ei voitu lähettää.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} on oltava välillä ${a} - ${b} `;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ei täsmää.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ei ole validi päivämäärä, ole hyvä ja syötä muodossa: ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Tämä kenttä on täytetty virheellisesti joten sitä ei voitu lähettää.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} on oltava välillä ${date(args[0])} - ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Syötä validi sähköpostiosoite.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} tulee päättyä ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} ei ole sallittu vaihtoehto.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} on oltava vähintään yksi merkki.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} on oltava ${max} tai alle merkkiä.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} on oltava vähintään ${min} merkkiä.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} on oltava vähintään ${min}, enintään ${max} merkkiä.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} ei ole sallittu arvo.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Valitse enintään ${args[0]} ${name} vaihtoehtoa.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} on oltava ${args[0]} tai alle.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Tiedostoja ei sallita.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} tulee olla ${args[0]}-tiedostotyyppiä.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Valitse vähintään ${args[0]} ${name} vaihtoehtoa.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} tulee olla ${args[0]} tai suurempi.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” ei ole sallittu ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `Kentän ${sentence(name)} tulee olla numero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} vaaditaan.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} on alettava ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Syötä validi url-osoite.`;\n        /* </i18n> */\n    },\n};\n\nvar fi = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$j,\n    validation: validation$j\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$i = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Ajouter',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Supprimer',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Enlever tout',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Désolé, tous les champs ne sont pas remplis correctement.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Valider',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Aucun fichier choisi',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$i = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Veuillez accepter le ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} doit être postérieure au ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} doit être dans le futur.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} ne peut contenir que des caractères alphabétiques.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} ne peut contenir que des lettres et des chiffres.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} ne peuvent contenir que des lettres et des espaces.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} doit être antérieure au ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} doit être dans le passé.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Ce champ a été configuré de manière incorrecte et ne peut pas être soumis.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} doit être comprise entre ${a} et ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ne correspond pas.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} n'est pas une date valide, veuillez utiliser le format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ce champ a été configuré de manière incorrecte et ne peut pas être soumis.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} doit être comprise entre ${date(args[0])} et ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Veuillez saisir une adresse email valide.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne se termine pas par ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} n'est pas une valeur autorisée.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} doit comporter au moins un caractère.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} doit être inférieur ou égal à ${max} caractères.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} doit être supérieur ou égal à ${min} caractères.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} doit être comprise entre ${min} et ${max} caractères.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} n'est pas une valeur autorisée.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Ne peut pas avoir plus de ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} doit être inférieur ou égal à ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Aucun format de fichier n’est autorisé';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} doit être du type: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Ne peut pas avoir moins de ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} doit être au moins de ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” n'est pas un ${name} autorisé.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} doit être un nombre.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} est requis.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne commence pas par ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Veuillez saisir une url valide.`;\n        /* </i18n> */\n    },\n};\n\nvar fr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$i,\n    validation: validation$i\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$h = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ferwider',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Ferwider alles',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, net alle fjilden binne korrekt ynfolle.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Ferstjoere',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Gjin bestân keazen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$h = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Akseptearje de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} moat nei ${date(args[0])} wêze.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moat yn de takomst lizze.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mei allinne alfabetyske tekens befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mei allinne letters en sifers befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} moat foar ${date(args[0])} falle.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moat yn it ferline wêze.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} moat tusken ${a} en ${b} lizze.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} komt net oerien.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is gjin jildige datum, brûk de notaasje ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} moat tusken ${date(args[0])} en ${date(args[1])} lizze`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Folje in jildich e-mailadres yn.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} einiget net mei ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is gjin tastiene wearde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} moat minimaal ien teken wêze.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} moat lytser wêze as of gelyk wêze oan ${max} tekens.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} moat grutter wêze as of gelyk wêze oan ${min} tekens.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} moat tusken de ${min} en ${max} tekens befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is gjin tastiene wearde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Mei net mear as ${args[0]} ${name} hawwe.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} moat lytser wêze as of gelyk wêze oan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Gjin bestânsnotaasjes tastien.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} moat fan it type: ${args[0]} wêze`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mei net minder as ${args[0]} ${name} hawwe.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} moat minimaal ${args[0]} wêze.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" is gjin tastiene ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} moat in getal wêze.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is ferplicht.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} begjint net mei ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Doch der in jildige url by.`;\n        /* </i18n> */\n    },\n};\n\nvar fy = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$h,\n    validation: validation$h\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$g = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'הוסף',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'מחק',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'שים לב, לא כל השדות מלאים כראוי.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'שלח',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$g = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `אנא אשר את ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} חייב להיות אחרי ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} חייב להיות בעתיד.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} חייב להכיל אותיות אלפבת.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} יכול להכיל רק מספרים ואותיות.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} יכול להכיל רק אותיות ורווחים.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} חייב להיות לפני ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} חייב להיות בעבר`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `שדה זה לא הוגדר כראוי ולא יכול להישלח.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} חייב להיות בין ${args[0]} ו-${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} לא מתאים.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} הוא לא תאריך תקין, אנא השתמש בפורמט ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'שדה זה לא הוגדר כראוי ולא יכול להישלח.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} חייב להיות בין ${date(args[0])} ו- ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'אנא הקלד אימייל תקין.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} לא מסתיים ב- ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} הוא לא ערך מורשה.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} חייב להיות לפחות תו אחד.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} חייב להיות פחות או שווה ל- ${max} תווים.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} חייב ליות גדול או שווה ל- ${min} תווים.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} חייב להיות בין ${min} ו- ${max} תווים.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} הוא לא ערך תקין.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} לא יכול להיות עם יותר מ- ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} חייב להיות פחות או שווה ל- ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'פורמט הקובץ לא מורשה.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} חייב להיות מסוג: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} לא יכול להיות עם פחות מ- ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} חייב להיות לפחות ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” לא מתאים ל- ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} חייב להיות מספר.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} הינו חובה.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} לא מתחיל ב- ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `אנא הקלד קישור תקין.`;\n        /* </i18n> */\n    },\n};\n\nvar he = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$g,\n    validation: validation$g\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$f = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Dodaj',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ukloni',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pojedina polja nisu ispravno ispunjena.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Predaj',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$f = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Potrebno je potvrditi ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti u periodu poslije ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u budućnosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mora sadržavati samo slova.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mora sadržavati slova i brojeve.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} mogu sadržavati samo slova i razmake..`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti prije ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u prošlosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Format sadržaja nije ispravan i ne može biti predan.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mora biti između ${args[0]} i ${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ne odgovara zadanoj vrijednosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nije ispravan format datuma. Molimo koristite sljedeći format: ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ovo polje nije ispravno postavljeno i ne može biti predano.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mora biti vrijednost između ${date(args[0])} i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Molimo upišite ispravnu email adresu.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne završava s ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nije dopuštena vrijednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mora sadržavati barem jedan znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} mora imati ${max} ili manje znakova.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mora imati barem ${min} znakova.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `Broj znakova za polje ${sentence(name)} mora biti između ${min} i ${max}.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nije dozvoljena vrijednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Ne smije imati više od ${args[0]} ${name} polja.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} mora imati vrijednost manju ili jednaku ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Format datoteke nije dozvoljen.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `Format datoteke na polju ${sentence(name)} mora odgovarati: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Broj upisanih vrijednosti na polju ${name} mora biti barem ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mora biti barem ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” nije dozvoljena vrijednost na polju ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mora biti broj.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je obavezno.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne počinje s ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Molimo unesite ispravnu poveznicu.`;\n        /* </i18n> */\n    },\n};\n\nvar hr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$f,\n    validation: validation$f\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$e = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Tambah',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Hapus',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Hapus semua',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Maaf, tidak semua bidang formulir terisi dengan benar',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Kirim',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Tidak ada file yang dipilih',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$e = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Tolong terima kolom ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} nilainya harus lebih dari waktu ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} harus berisi waktu di masa depan.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} hanya bisa diisi huruf alfabet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} hanya bisa diisi huruf dan angka.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} hanya boleh berisi huruf dan spasi..`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} nilainya harus kurang dari waktu ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} harus berisi waktu yang sudah lampau.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} harus bernilai diantara ${a} dan ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nilainya tidak cocok.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} waktu tidak cocok, mohon gunakan format waktu ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} harus diantara waktu ${date(args[0])} dan waktu ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Tolong tulis alamat email yang benar.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nilainya tidak berakhiran dengan ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} adalah nilai yang tidak diizinkan.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} nilainya setidaknya berisi satu karakter.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} jumlah karakternya harus kurang dari atau sama dengan ${max} karakter.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} jumlah karakternya harus lebih dari atau sama dengan ${min} karakter.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} jumlah karakternya hanya bisa antara ${min} dan ${max} karakter.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nilainya tidak diizinkan.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Tidak bisa memiliki lebih dari ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} harus lebih kecil atau sama dengan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Format file tidak diizinkan';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} hanya bisa bertipe: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Tidak boleh kurang dari ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} setidaknya harus berisi ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” adalah nilai yang tidak diperbolehkan untuk ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} harus berupa angka.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} harus diisi.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} tidak dimulai dengan ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Mohon tuliskan url yang benar.`;\n        /* </i18n> */\n    },\n};\n\nvar id = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$e,\n    validation: validation$e\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$d = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Inserisci',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Rimuovi',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Rimuovi tutti',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Ci dispiace, non tutti i campi sono compilati correttamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Invia',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nessun file selezionato',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$d = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Si prega di accettare ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `la data ${sentence(name)} deve essere successiva ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `la data ${sentence(name)} deve essere nel futuro.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} può contenere solo caratteri alfanumerici.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} può contenere solo lettere e numeri.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} può contenere solo lettere e spazi.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `la data ${sentence(name)} deve essere antecedente ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve essere nel passato.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Questo campo è stato configurato male e non può essere inviato.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} deve essere tra ${a} e ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} non corrisponde.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} non è una data valida, per favore usa il formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Questo campo è stato configurato in modo errato e non può essere inviato.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} deve essere tra ${date(args[0])} e ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Per favore inserire un indirizzo email valido.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} non termina con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} non è un valore consentito.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} deve contenere almeno un carattere.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} deve essere minore o uguale a ${max} caratteri.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} deve essere maggiore o uguale a ${min} caratteri.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} deve essere tra ${min} e ${max} caratteri.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} non è un valore consentito.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Non può avere più di ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} deve essere minore o uguale a ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Formato file non consentito.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} deve essere di tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Non può avere meno di ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} deve essere almeno ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" non è un ${name} consentito.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} deve essere un numero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} è richiesto.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} non inizia con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Per favore utilizare un url valido.`;\n        /* </i18n> */\n    },\n};\n\nvar it = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$d,\n    validation: validation$d\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$c = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '追加',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '削除',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '全て削除',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '項目が正しく入力されていません。',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '送信',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'ファイルが選択されていません',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$c = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `${name}の同意が必要です。`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)}は${date(args[0])}より後の日付である必要があります。`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}は将来の日付でなければなりません。`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)}には英字のみを含めることができます。`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)}には、文字と数字のみを含めることができます。`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)}には、文字とスペースのみを含めることができます。`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)}は${date(args[0])}より前の日付である必要があります。`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}は過去の日付である必要があります。`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `このフィールドは正しく構成されていないため、送信できません。`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)}は${a}と${b}の間にある必要があります。`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)}が一致しません。`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)}は有効な日付ではありません。${args[0]}の形式を使用してください。`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'このフィールドは正しく構成されておらず、送信できません。';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}は${date(args[0])}と${date(args[1])}の間にある必要があります。`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '有効なメールアドレスを入力してください。',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)}は${list(args)}で終わっていません。`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)}は許可された値ではありません。`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)}は少なくとも1文字である必要があります。`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)}は${max}文字以下である必要があります。`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)}は${min}文字以上である必要があります。`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}は${min}から${max}文字の間でなければなりません。`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)}は許可された値ではありません。`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}は${args[0]}を超えることはできません。`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)}は${args[0]}以下である必要があります。`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'ファイル形式は許可されていません。';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)}は${args[0]}である必要があります。`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}は${args[0]}未満にすることはできません。`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)}は少なくとも${args[0]}である必要があります。`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}”は許可された${name}ではありません。`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)}は数値でなければなりません。`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)}は必須です。`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)}は${list(args)}で始まっていません。`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `有効なURLを含めてください。`;\n        /* </i18n> */\n    },\n};\n\nvar ja = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$c,\n    validation: validation$c\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$b = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '추가',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '제거',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '모두 제거',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '모든 값을 채워주세요',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '제출하기',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '선택된 파일이 없습니다',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$b = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `${name} 올바른 값을 선택 해주세요`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} 이후여야 합니다`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} 미래의 날짜여야합니다`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} 알파벳 문자만 포함할 수 있습니다`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} 문자와 숫자만 포함될 수 있습니다`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} 문자와 공백만 포함할 수 있습니다.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} 이전여야 합니다`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} 과거의 날짜여야합니다`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `잘못된 구성으로 제출할 수 없습니다`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ${a}와 ${b} 사이여야 합니다`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} 일치하지 않습니다`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} 유효한 날짜가 아닙니다. ${args[0]}과 같은 형식을 사용해주세요`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '잘못된 구성으로 제출할 수 없습니다';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} ${date(args[0])}에서 ${date(args[1])} 사이여야 합니다`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '올바른 이메일 주소를 입력해주세요',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)}로 끝나지 않습니다`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} 허용되는 값이 아닙니다`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} 하나 이상의 문자여야 합니다`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ${max}자 이하여야 합니다`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ${min} 문자보다 크거나 같아야 합니다`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} ${min}에서 ${max}자 사이여야 합니다`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} 허용되는 값이 아닙니다`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${args[0]} ${name} 초과할 수 없습니다`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]}보다 작거나 같아야 합니다`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '파일 형식이 허용되지 않습니다';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]} 유형이어야 합니다`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${args[0]} ${name}보다 작을 수 없습니다`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]} 이상이어야 합니다`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `${value}\" 허용되지 않는 ${name}입니다`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} 숫자여야 합니다`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} 필수 값입니다`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)}로 시작하지 않습니다`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `올바른 URL을 입력해주세요`;\n        /* </i18n> */\n    },\n};\n\nvar ko = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$b,\n    validation: validation$b\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$a = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Toevoegen',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Verwijder',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Verwijder alles',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, niet alle velden zijn correct ingevuld.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Versturen',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Geen bestand gekozen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$a = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Accepteer de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} moet na ${date(args[0])} zijn.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moet in de toekomst liggen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mag alleen alfabetische tekens bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mag alleen letters en cijfers bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kunnen alleen letters en spaties bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} moet vóór ${date(args[0])} vallen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moet in het verleden zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dit veld is onjuist geconfigureerd en kan niet worden verzonden.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} moet tussen ${a} en ${b} liggen.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} komt niet overeen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is geen geldige datum, gebruik de notatie ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dit veld is onjuist geconfigureerd en kan niet worden verzonden';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} moet tussen ${date(args[0])} en ${date(args[1])} liggen`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Vul een geldig e-mailadres in.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} eindigt niet met ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is geen toegestane waarde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} moet minimaal één teken zijn.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${max} tekens.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} moet groter zijn dan of gelijk zijn aan ${min} tekens.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} moet tussen de ${min} en ${max} tekens bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is geen toegestane waarde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Mag niet meer dan ${args[0]} ${name} hebben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Geen bestandsformaten toegestaan.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} moet van het type: ${args[0]} zijn`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mag niet minder dan ${args[0]} ${name} hebben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} moet minimaal ${args[0]} zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" is geen toegestane ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} moet een getal zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is verplicht.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} begint niet met ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Voeg een geldige url toe.`;\n        /* </i18n> */\n    },\n};\n\nvar nl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$a,\n    validation: validation$a\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$9 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Dodaj',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Usuń',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Usuń wszystko',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Nie wszystkie pola zostały wypełnione poprawnie.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Wyślij',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nie wybrano pliku',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$9 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Proszę zaakceptować ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} musi być po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musi być w przyszłości.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `Pole ${sentence(name)} może zawierać tylko znaki alfabetyczne.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `Pole ${sentence(name)} może zawierać tylko znaki alfanumeryczne.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `Pole ${sentence(name)} mogą zawierać tylko litery i spacje.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} musi być przed ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musi być w przeszłości.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Pole zostało wypełnione niepoprawnie i nie może zostać wysłane.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `Wartość pola ${sentence(name)} musi być pomiędzy ${a} i ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nie pokrywa się.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `Wartość pola ${sentence(name)} nie jest poprawną datą, proszę użyć formatu ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'To pole zostało wypełnione niepoprawnie i nie może zostać wysłane';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `Data w polu ${sentence(name)} musi być pomiędzy ${date(args[0])} i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Proszę wpisać poprawny adres email.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `Pole ${sentence(name)} nie kończy się na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `Pole ${sentence(name)} nie jest dozwoloną wartością.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `Pole ${sentence(name)} musi posiadać minimum jeden znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `Pole ${sentence(name)} musi zawierać ${max} lub mniej znaków.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `Pole ${sentence(name)} musi zawierać ${min} lub więcej znaków.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `Pole ${sentence(name)} musi mieć ${min}-${max} znaków.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `Pole ${sentence(name)} zawiera niedozwolone znaki.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nie można mieć więcej niż ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `Wartość pola ${sentence(name)} musi być mniejsza lub równa ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nie podano dozwolonych typów plików.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} musi być typem: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Musisz podać więcej niż ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return ` Musisz podać conajmniej ${args[0]} ${sentence(name)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `Wartość pola ${name} jest niedozwolona.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} musi być numerem.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `Pole ${sentence(name)} jest wymagane.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `Wartośc pola ${sentence(name)} nie zaczyna się od ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Proszę podać prawidłowy adres url.`;\n        /* </i18n> */\n    },\n};\n\nvar pl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$9,\n    validation: validation$9\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$8 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Adicionar',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Remover',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Deletar tudo',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Desculpe, nem todos os campos foram preenchidos corretamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Enviar',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nenhum arquivo',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$8 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Por favor aceite o ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} deve ser posterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve ser no futuro.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} só pode conter caracteres do alfabeto.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} só pode ter letras e números.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} só podem conter letras e espaços.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} deve ser anterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve ser anterior a data atual.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `O campo foi configurado incorretamente e não pode ser enviado.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} deve estar entre ${args[0]} e ${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} não confere.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} não é uma data válida, por favor use o formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'O campo foi configurado incorretamente e não pode ser enviado.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} deve ser entre ${date(args[0])} e ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Por favor informe um e-mail válido.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} não termina com ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} não é um valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} deve ter ao menos um caractere.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} não pode ter mais que ${max} caracteres.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} deve ter no mínimo ${min} caracteres.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} deve ter entre ${min} e ${max} caracteres.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} não é um valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Não pode ter mais que ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} deve ser igual ou menor que ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nenhum formato de arquivo permitido.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} deve ser do tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Não pode ter menos que ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} deve ter pelo menos ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” não permite ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} deve ser um número.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} é obrigatório.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} não começa com ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Por favor informe um url válido.`;\n        /* </i18n> */\n    },\n};\n\nvar pt = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$8,\n    validation: validation$8\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$7 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Adăugare',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Elimină',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Elimină tot',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pare rău, unele câmpuri nu sunt corect completate.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Trimite',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nu este selectat nici un fișier',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$7 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Te rog acceptă ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} trebuie să fie după ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} trebuie sa fie în viitor.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} poate conține doar caractere alafetice.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} poate conține doar litere și numere.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} poate conține doar litere și spații.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} trebuie să preceadă ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} trebuie să fie în trecut.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Câmpul a fost configurat incorect și nu poate fi trimis.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} trebuie să fie între ${a} și ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nu se potrivește.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nu este validă, te rog foloște formatul ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Câmpul a fost incorect configurat și nu poate fi trimis.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} trebuie să fie între ${date(args[0])} și ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Te rog folosește o adresă de email validă.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nu se termină cu ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nu este o valoare acceptată.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} trebuie sa conțină cel puțin un caracter.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} trebuie sa aibă cel mult ${max} caractere.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} trebuie să aibă cel puțin ${min} caractere.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} trebuie să aibă între ${min} și ${max} caractere.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nu este o valoare acceptată.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nu poate avea mai mult decat ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} trebuie să fie cel mult egal cu ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Tipul de fișier neacceptat.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} trebuie să fie de tipul: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Nu poate avea mai puțin decât ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} trebuie să fie cel puțin ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” nu este o valoare acceptă pentru ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} trebuie să fie un număr.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} este necesar.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nu începe cu ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Te rog include o adresă web validă`;\n        /* </i18n> */\n    },\n};\n\nvar ro = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$7,\n    validation: validation$7\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$6 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Добавить',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Удалить',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Убрать все',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Извините, не все поля заполнены верно.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Отправить',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Файл не выбран',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$6 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Пожалуйста, примите ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `Дата ${sentence(name)} должна быть позже ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `Дата ${sentence(name)} должна быть в будущем.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `Поле ${sentence(name)} может содержать только буквы.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `Поле ${sentence(name)} может содержать только буквы и цифры.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} могут содержать только буквы и пробелы.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `Дата ${sentence(name)} должна быть раньше ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `Дата ${sentence(name)} должна быть в прошлом.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Это поле заполнено неверно и не может быть отправлено.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `Поле ${sentence(name)} должно быть между ${a} и ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `Поле ${sentence(name)} не совпадает.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `Поле ${sentence(name)} имеет неверную дату. Пожалуйста, используйте формат ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Это поле заполнено неверно и не может быть отправлено.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `Дата ${sentence(name)} должна быть между ${date(args[0])} и ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Пожалуйста, введите действительный электронный адрес.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `Поле ${sentence(name)} не должно заканчиваться на ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `Поле ${sentence(name)} имеет неподустимое значение.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `Поле ${sentence(name)} должно содержать минимум один символ.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `Длина поля ${sentence(name)} должна быть меньше или равна ${max} символам.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `Длина поля ${sentence(name)} должна быть больше или равна ${min} символам.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `Длина поля ${sentence(name)} должна быть между ${min} и ${max} символами.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `Поле ${sentence(name)} имеет недопустимое значение.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Не может быть выбрано больше, чем ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `Поле ${sentence(name)} должно быть меньше или равно ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Не указаны поддержиавемые форматы файла.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `Формат файла в поле ${sentence(name)} должен быть: ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Не может быть выбрано меньше, чем ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `Поле ${sentence(name)} должно быть не менее, чем ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” не поддерживается в поле ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `Поле ${sentence(name)} должно быть числом.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `Поле ${sentence(name)} обязательно для заполнения.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `Поле ${sentence(name)} должно начинаться с ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Пожалуйста, введите действительный URL адрес.`;\n        /* </i18n> */\n    },\n};\n\nvar ru = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$6,\n    validation: validation$6\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$5 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Dodaj',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Odstrani',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Odstrani vse',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Nekatera polja niso pravilno izpolnjena.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Pošlji',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nobena datoteka ni izbrana',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$5 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Prosimo popravite ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti v prihodnosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} lahko vsebuje samo znake abecede.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} lahko vsebuje samo črke in številke.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} lahko vsebuje samo črke in presledke.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti pred ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti v preteklosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `To polje je narobe nastavljeno in ne mora biti izpolnjeno.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mora biti med ${a} in ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} se ne ujema.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ni pravilen datum, prosimo uporabite format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'To polje je narobe nastavljeno in ne mora biti izpolnjeno.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mora biti med ${date(args[0])} in ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Vnesite veljaven e-poštni naslov.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} se mora kočati z ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} ni dovoljena vrednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mora vsebovati vsaj en znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} mora vsebovati največ ${max} znakov.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mora vsebovati vsaj ${min} znakov.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} mora vsebovati med ${min} in ${max} znakov.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} ni dovoljena vrednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Največ je ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} je lahko največ ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nobena vrsta datoteke ni dovoljena.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} mora biti tipa: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Najmanj ${args[0]} ${name} je dovoljenih.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mora biti vsaj ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” ni dovoljen(a/o) ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mora biti številka.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je zahtevan(o/a).`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} se mora začeti z ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Vnesite veljavno povezavo.`;\n        /* </i18n> */\n    },\n};\n\nvar sl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$5,\n    validation: validation$5\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$4 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ta bort',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Ta bort alla',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Tyvärr är inte alla fält korrekt ifyllda',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Skicka',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ingen fil vald',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$4 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Var god acceptera ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} måste vara efter ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} måste vara framåt i tiden.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} kan enbart innehålla bokstäver i alfabetet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} kan bara innehålla bokstäver och siffror.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kan bara innehålla bokstäver och blanksteg.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} måste vara före ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} måste vara bakåt i tiden.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Det här fältet ställdes inte in korrekt och kan inte användas.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} måste vara mellan ${a} och ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} matchar inte.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} är inte ett giltigt datum, var god använd formatet ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Det här fältet ställdes inte in korrekt och kan inte användas';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} måste vara mellan ${date(args[0])} och ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Var god fyll i en giltig e-postadress.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} slutar inte med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} är inte ett godkänt värde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} måste ha minst ett tecken.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} måste vara ${max} tecken eller färre.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} måste vara ${min} tecken eller fler.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} måste vara mellan ${min} och ${max} tecken.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} är inte ett godkänt värde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Kan inte ha mer än ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} måste vara ${args[0]} eller mindre.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Inga filtyper tillåtna.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} måste vara av filtypen: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Kan inte ha mindre än ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} måste vara minst ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” är inte ett godkänt ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} måste vara en siffra.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} är obligatoriskt.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} börjar inte med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Var god fyll i en giltig länk.`;\n        /* </i18n> */\n    },\n};\n\nvar sv = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$4,\n    validation: validation$4\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$3 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'เพิ่ม',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'เอาออก',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'เอาออกทั้งหมด',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'ขออภัย ข้อมูลบางช่องที่กรอกไม่ถูกต้อง',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'ส่ง',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'ยังไม่ได้เลือกไฟล์',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$3 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `กรุณายอมรับ ${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} จะต้องเป็นวันที่หลังจาก ${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} จะต้องเป็นวันที่ที่ยังไม่มาถึง`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} สามารถเป็นได้แค่ตัวอักษรเท่านั้น`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} สามารถเป็นได้แค่ตัวอักษรและตัวเลขเท่านั้น`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} สามารถเป็นได้แค่ตัวอักษรและเว้นวรรคเท่านั้น`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} จะต้องเป็นวันที่ที่มาก่อน ${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} จะต้องเป็นวันที่ที่ผ่านมาแล้ว`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `ช่องนี้ถูกตั้งค่าอย่างไม่ถูกต้อง และจะไม่สามารถส่งข้อมูลได้`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} จะต้องเป็นค่าระหว่าง ${a} และ ${b}`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ไม่ตรงกัน`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ไม่อยู่ในรูปแบบวันที่ที่ถูกต้อง กรุณากรอกตามรูปแบบ ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'ช่องนี้ถูกตั้งค่าอย่างไม่ถูกต้อง และจะไม่สามารถส่งข้อมูลได้';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} จะต้องเป็นวันที่ระหว่าง ${date(args[0])} และ ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'กรุณากรอกที่อยู่อีเมลทีถูกต้อง',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} จะต้องลงท้ายด้วย ${list(args)}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} ไม่ใช่ค่าที่อนุญาตให้กรอก`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} จะต้องมีความยาวอย่างน้อยหนึ่งตัวอักษร`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} จะต้องมีความยาวไม่เกิน ${max} ตัวอักษร`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} จะต้องมีความยาว ${min} ตัวอักษรขึ้นไป`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} จะต้องมีความยาวระหว่าง ${min} และ ${max} ตัวอักษร`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} ไม่ใช่ค่าที่อนุญาตให้กรอก`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `ไม่สามารถเลือกมากกว่า ${args[0]} ${name} ได้`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} จะต้องมีค่าไม่เกิน ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'ไม่มีประเภทของไฟล์ที่อนุญาต';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} จะต้องเป็นไฟล์ประเภท ${args[0]} เท่านั้น`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `ไม่สามารถเลือกน้อยกว่า ${args[0]} ${name} ได้`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} จะต้องมีค่าอย่างน้อย ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” ไม่ใช่ค่า ${name} ที่อนุญาตให้กรอก`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} จะต้องเป็นตัวเลขเท่านั้น`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `กรุณากรอก ${sentence(name)}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} จะต้องเริ่มต้นด้วย ${list(args)}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `กรุณาระบุที่อยู่ลิงก์ให้ถูกต้อง`;\n        /* </i18n> */\n    },\n};\n\nvar th = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$3,\n    validation: validation$3\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$2 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Ekle',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Kaldır',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Hepsini kaldır',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Maalesef, tüm alanlar doğru doldurulmadı.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Gönder',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Dosya yok',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$2 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Lütfen ${name}'yi kabul edin.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])}'den sonra olmalıdır.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} gelecekte bir zaman olmalıdır.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} sadece alfabetik karakterler içerebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} sadece alfabetik karakterler ve sayı içerebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} yalnızca harf ve boşluk içerebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} tarihinden önce olmalı.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} geçmişte olmalı.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Alan yanlış yapılandırılmış ve gönderilemez.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ${args[0]} ve ${args[1]} aralığında olmalı.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} eşleşmiyor.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} geçerli bir tarih değil, lütfen ${args[0]} biçimini kullanın.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Alan yanlış yapılandırılmış ve gönderilemez.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}, ${date(args[0])} ve ${date(args[1])} aralığında olmalı.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Lütfen geçerli bir e-mail adresi girin.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)} ile bitmiyor.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} izin verilen bir değer değil.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} en azından bir karakter uzunluğunda olmalı.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ${max}'e eşit veya daha küçük olmalı.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ${min}'e eşit veya daha büyük olmalı.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}, ${min} ve ${max} karakter uzunluğu aralığında olmalı.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} izin verilen bir değer değil.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}'in uzunluğu ${args[0]}'dan daha uzun olamaz.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} en azından ${args[0]} uzunluğunda veya ona eşit olmalı.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Hiçbir dosya türüne izin verilmez.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} şu tiplerden biri olmalı: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}'in uzunluğu ${args[0]}'dan daha kısa olamaz.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} en azından ${args[0]} uzunluğunda olmalı.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}” ${name} olamaz.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} sayı olmalı.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} gerekli.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)} ile başlamıyor.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Lütfen geçerli bir url dahil edin.`;\n        /* </i18n> */\n    },\n};\n\nvar tr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$2,\n    validation: validation$2\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$1 = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: 'Thêm',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Xoá',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Xoá tất cả',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Xin lỗi, không phải tất cả các trường đều được nhập đúng.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Gửi',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Chưa chọn file',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$1 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Hãy đồng ý với ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} phải sau ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} phải trong tương lai.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} có thể chỉ bao gồm các chữ cái alphabet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} có thể chỉ bao gồm các chữ cái và chữ số.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} chỉ có thể chứa các chữ cái và khoảng trắng.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} phải trước ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} phải trong quá khứ.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Trường này đã được thiết lập sai và không thể gửi.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} phải ở giữa ${a} và ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} không khớp.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} không phải ngày hợp lệ, hãy sử dụng định dạng ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Trường này đã được thiết lập sai và không thể gửi.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} phải ở giữa khoảng từ ${date(args[0])} đến ${date(args[1])}.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Hãy nhập một địa chỉ email hợp lệ.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} không kết thúc với ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} không phải một giá trị được cho phép.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} phải có độ dài tối thiểu một ký tự.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} phải có độ dài tối đa ${max} ký tự.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} phải có độ dài tối thiểu ${min} ký tự.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} phải có độ dài tối đa trong khoảng từ ${min} đến ${max} ký tự.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} không phải một giá trị được cho phép.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} không thể lớn hơn ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} phải tối đa bằng ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Định dạng tệp tin này không được phép.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} phải là một trong các dạng: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} không thể nhỏ hơn ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} phải tối thiểu bằng ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" không phải giá trị ${name} được phép.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} phải là một số.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} là bắt buộc.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} không bắt đầu với ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Hãy nhập một URL hợp lệ.`;\n        /* </i18n> */\n    },\n};\n\nvar vi = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$1,\n    validation: validation$1\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui = {\n    /**\n     * Shown on buttons for adding new items.\n     */\n    add: '添加',\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '移除',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '对不起，有些字段未被正确填写',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '提交',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `请接受${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)}必须晚于${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}必须是未来的日期`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)}仅能包含字母字符`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)}仅能包含字母和数字`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)}只能包含字母和空格`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)}必须早于${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}必须是过去的日期`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `该字段未被正确设置而无法被提交`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)}必须在${args[0]}和${args[1]}之间`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)}不匹配`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)}不是一个合法日期，请使用此格式${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '该字段未被正确设置而无法被提交';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}必须在${date(args[0])}和${date(args[1])}之间`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '请输入一个合法的电子邮件地址',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)}并未以${list(args)}结尾`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)}不是一个允许值`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)}至少要有一个字符`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)}必须少于或等于${max}个字符`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)}必须多于或等于${min}个字符`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}必须有${min}至${max}个字符`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)}不是一个允许值`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}不能超过${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)}必须小于或等于${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '无允许的文件格式';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)}必须为此类型：${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}不能少于${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)}不能小于${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `“${value}”不是一个被允许的${name}`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)}必须是一个数字`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)}必须填写`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)}没有以${list(args)}开头`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `请包含一个合法的url`;\n        /* </i18n> */\n    },\n};\n\nvar zh = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui,\n    validation: validation\n});\n\n/**\n * Create a new internationalization plugin for FormKit.\n * @param locales - Creates the i18n plugin.\n * @public\n */\nfunction createI18nPlugin(registry) {\n    return function i18nPlugin(node) {\n        let localeKey = parseLocale(node.config.locale, registry);\n        let locale = localeKey ? registry[localeKey] : {};\n        /* If the locale prop changes, update the active locale */\n        node.on('prop:locale', ({ payload: lang }) => {\n            localeKey = parseLocale(lang, registry);\n            locale = localeKey ? registry[localeKey] : {};\n            // Run through all the messages in the store and update with new locale\n            node.store.touch();\n        });\n        node.on('prop:label', () => node.store.touch());\n        node.on('prop:validationLabel', () => node.store.touch());\n        /**\n         * Hook into the core text or t() hook to perform localization on the\n         * output of core functionality.\n         */\n        node.hook.text((fragment, next) => {\n            var _a, _b;\n            const key = ((_a = fragment.meta) === null || _a === void 0 ? void 0 : _a.messageKey) || fragment.key;\n            if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(locale, fragment.type) && (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(locale[fragment.type], key)) {\n                const t = locale[fragment.type][key];\n                if (typeof t === 'function') {\n                    fragment.value = Array.isArray((_b = fragment.meta) === null || _b === void 0 ? void 0 : _b.i18nArgs)\n                        ? t(...fragment.meta.i18nArgs) // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                        : t(fragment);\n                }\n                else {\n                    fragment.value = t;\n                }\n            }\n            return next(fragment);\n        });\n    };\n}\n/**\n * @param locale - An ISO 639-1 and (optionally) ISO 639-2 language tag. For\n * example these are valid locale keys:\n * zh\n * zh-CN\n * zh-HK\n * en\n * en-GB\n * @param availableLocales - An array of locales that may be valid.\n */\nfunction parseLocale(locale, availableLocales) {\n    if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(availableLocales, locale)) {\n        return locale;\n    }\n    const [lang] = locale.split('-');\n    if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(availableLocales, lang)) {\n        return lang;\n    }\n    for (const locale in availableLocales) {\n        return locale;\n    }\n    return false;\n}\n\n/**\n * Export all the available locales at once.\n * @public\n */\nconst locales = {\n    ar,\n    cs,\n    da,\n    de,\n    en,\n    es,\n    fa,\n    fi,\n    fr,\n    fy,\n    he,\n    hr,\n    id,\n    it,\n    ja,\n    ko,\n    nl,\n    pl,\n    pt,\n    ro,\n    ru,\n    sl,\n    sv,\n    th,\n    tr,\n    vi,\n    zh,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvaTE4bi9kaXN0L2luZGV4Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvaTE4bi9kaXN0L2luZGV4Lm1qcz9hMTUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhcyB9IGZyb20gJ0Bmb3Jta2l0L3V0aWxzJztcblxuLyoqXG4gKiBHaXZlbiBhIHN0cmluZywgY29udmVydCBpdCB0byBzZW50ZW5jZSBjYXNlLlxuICogQHBhcmFtIGl0ZW0gLSBUaGUgc3RyaW5nIHRvIHNlbnRlbmNlIGNhc2VcbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNlbnRlbmNlKHN0cikge1xuICAgIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHIoMSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gb3hmb3JkLWNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGl0ZW1zLlxuICogQHBhcmFtIGFyZ3MgLSBpdGVtcyB0byBsaXN0IG91dFxuICogQHBhcmFtIGNvbmp1bmN0aW9uIC0gaW46IHgsIHksIGFuZCB6IFwiYW5kXCIgaXMgdGhlIGNvbmp1bmN0aW9uIHRvIHVzZVxuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbGlzdChpdGVtcywgY29uanVuY3Rpb24gPSAnb3InKSB7XG4gICAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgob3hmb3JkLCBpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBveGZvcmQgKz0gaXRlbTtcbiAgICAgICAgaWYgKGluZGV4IDw9IGl0ZW1zLmxlbmd0aCAtIDIgJiYgaXRlbXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgb3hmb3JkICs9ICcsICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSBpdGVtcy5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICBveGZvcmQgKz0gYCR7aXRlbXMubGVuZ3RoID09PSAyID8gJyAnIDogJyd9JHtjb25qdW5jdGlvbn0gYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3hmb3JkO1xuICAgIH0sICcnKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBzdHJpbmcgb3IgYSBkYXRlIHJldHVybiBhIG5pY2UgaHVtYW4tcmVhZGFibGUgdmVyc2lvbi5cbiAqIEBwYXJhbSBkYXRlIC0gQSBzdHJpbmcgb3IgYSBkYXRlLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBkYXRlKGRhdGUpIHtcbiAgICBjb25zdCBkYXRlVGltZSA9IHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJyA/IG5ldyBEYXRlKERhdGUucGFyc2UoZGF0ZSkpIDogZGF0ZTtcbiAgICBpZiAoIShkYXRlVGltZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIHJldHVybiAnKHVua25vd24pJztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHVuZGVmaW5lZCwge1xuICAgICAgICBkYXRlU3R5bGU6ICdtZWRpdW0nLFxuICAgIH0pLmZvcm1hdChkYXRlVGltZSk7XG59XG4vKipcbiAqIE9yZGVycyB0d28gdmFyaWFibGVzIHNtYWxsZXN0IHRvIGxhcmdlc3QuXG4gKiBAcGFyYW0gZmlyc3QgLSBmaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIHNlY29uZCAtIFNlY29uZCBhcmd1bWVudFxuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gb3JkZXIoZmlyc3QsIHNlY29uZCkge1xuICAgIHJldHVybiBOdW1iZXIoZmlyc3QpID49IE51bWJlcihzZWNvbmQpID8gW3NlY29uZCwgZmlyc3RdIDogW2ZpcnN0LCBzZWNvbmRdO1xufVxuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJHEgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICfYpdi22KfZgdipJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ9il2LLYp9mE2KknLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHRvIHJlbW92ZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbDogJ9il2LLYp9mE2Kkg2KfZhNmD2YQnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICfYudiw2LHYp9iMINmE2YUg2YrYqtmFINiq2LnYqNim2Kkg2KzZhdmK2Lkg2KfZhNit2YLZiNmEINio2LTZg9mEINi12K3ZititLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAn2KXYsdiz2KfZhCcsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ9mE2Kcg2YrZiNis2K8g2YXZhNmBINmF2K7Yqtin2LEnLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiRxID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNin2YTYsdis2KfYoSDZgtio2YjZhCAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBg2YrYrNioINij2YYg2YrZg9mI2YYgJHtzZW50ZW5jZShuYW1lKX0g2KjYudivICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNmK2KzYqCDYo9mGINmK2YPZiNmGICR7c2VudGVuY2UobmFtZSl9INmB2Yog2KfZhNmF2LPYqtmC2KjZhC5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNmK2YXZg9mGINij2YYg2YrYrdiq2YjZiiAke3NlbnRlbmNlKG5hbWUpfSDYudmE2Ykg2KPYrdix2YEg2KPYqNis2K/ZitipINmB2YLYty5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFscGhhbnVtZXJpY1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGFudW1lcmljfVxuICAgICAqL1xuICAgIGFscGhhbnVtZXJpYyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBg2YrZhdmD2YYg2KPZhiDZitit2KrZiNmKICR7c2VudGVuY2UobmFtZSl9INi52YTZiSDYo9it2LHZgSDZiNij2LHZgtin2YUg2YHZgti3LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgbGV0dGVyIGFuZC9vciBzcGFjZXNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhLXNwYWNlc31cbiAgICAgKi9cbiAgICBhbHBoYV9zcGFjZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBhbmQgbm9uLXNwYWNlIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBg2YrZhdmD2YYg2KPZhiDYqtit2KrZiNmKICR7c2VudGVuY2UobmFtZSl9INi52YTZiSDYo9it2LHZgSDZiNmF2LPYp9mB2KfYqiDZgdmC2LcuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGJlZm9yZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZWZvcmV9XG4gICAgICovXG4gICAgZGF0ZV9iZWZvcmUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBg2YrYrNioINij2YYg2YrZg9mI2YYgJHtzZW50ZW5jZShuYW1lKX0g2YLYqNmEICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDZitis2Kgg2KPZhiDZitmD2YjZhiAke3NlbnRlbmNlKG5hbWUpfSDZgdmKINin2YTZhdin2LbZii5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGDYqtmF2Kog2KrZh9mK2KbYqSDZh9iw2Kcg2KfZhNit2YLZhCDYqNi02YPZhCDYutmK2LEg2LXYrdmK2K0g2YjZhNinINmK2YXZg9mGINil2LHYs9in2YTZhy5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthLCBiXSA9IG9yZGVyKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDZitis2Kgg2KPZhiDZitmD2YjZhiAke3NlbnRlbmNlKG5hbWUpfSDZhdinINio2YrZhiAke2F9INmIICR7Yn0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpcm1hdGlvbiBmaWVsZCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jY29uZmlybX1cbiAgICAgKi9cbiAgICBjb25maXJtKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgbWF0Y2hlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDYutmK2LEg2YXYqti32KfYqNmCLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g2YTZitizINiq2KfYsdmK2K7Zi9inINi12KfZhNit2YvYpyDYjCDZitix2KzZiSDYp9iz2KrYrtiv2KfZhSDYp9mE2KrZhtiz2YrZgiAke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICfYqtmF2Kog2KrZh9mK2KbYqSDZh9iw2Kcg2KfZhNit2YLZhCDYqNi02YPZhCDYutmK2LEg2LXYrdmK2K0g2YjZhNinINmK2YXZg9mGINil2LHYs9in2YTZhyc7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCB3aXRoaW4gZXhwZWN0ZWQgZGF0ZSByYW5nZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZXR3ZWVufVxuICAgICAqL1xuICAgIGRhdGVfYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGRhdGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGDZitis2Kgg2KPZhiDZitmD2YjZhiAke3NlbnRlbmNlKG5hbWUpfSDYqNmK2YYgJHtkYXRlKGFyZ3NbMF0pfSDZiCAke2RhdGUoYXJnc1sxXSl9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICfYp9mE2LHYrNin2KEg2KPYr9iu2KfZhCDYqNix2YrYryDYpdmE2YrZg9iq2LHZiNmG2Yog2LXYp9mE2K0uJyxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbmRzLXdpdGh9XG4gICAgICovXG4gICAgZW5kc193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVuZCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg2YTYpyDZitmG2KrZh9mKICR7c2VudGVuY2UobmFtZSl9INio2YAgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INmE2YrYs9iqINmC2YrZhdipINmF2LPZhdmI2K0g2KjZh9inLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBsZW5ndGhcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2xlbmd0aH1cbiAgICAgKi9cbiAgICBsZW5ndGgoeyBuYW1lLCBhcmdzOiBbZmlyc3QgPSAwLCBzZWNvbmQgPSBJbmZpbml0eV0gfSkge1xuICAgICAgICBjb25zdCBtaW4gPSBOdW1iZXIoZmlyc3QpIDw9IE51bWJlcihzZWNvbmQpID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgICAgIGNvbnN0IG1heCA9IE51bWJlcihzZWNvbmQpID49IE51bWJlcihmaXJzdCkgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgaWYgKG1pbiA9PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYNmK2KzYqCDYo9mGINmK2YPZiNmGICR7c2VudGVuY2UobmFtZSl9INit2LHZgdmL2Kcg2YjYp9it2K/Zi9inINi52YTZiSDYp9mE2KPZgtmELmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGDZitis2Kgg2KPZhiDZitmD2YjZhiAke3NlbnRlbmNlKG5hbWUpfSDYo9mC2YQg2YXZhiDYo9mIINmK2LPYp9mI2YogJHttYXh9INit2LHZgdmL2KcuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGDZitis2Kgg2KPZhiDZitmD2YjZhiAke3NlbnRlbmNlKG5hbWUpfSDYo9mD2KjYsSDZhdmGINij2Ygg2YrYs9in2YjZiiAke21pbn0g2K3YsdmB2YvYpy5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg2YrYrNioINij2YYg2YrZg9mI2YYgJHtzZW50ZW5jZShuYW1lKX0g2KjZitmGICR7bWlufSDZiCAke21heH0g2K3YsdmB2YvYpy5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBpcyBub3QgYSBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF0Y2hlc31cbiAgICAgKi9cbiAgICBtYXRjaGVzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgdmFsdWVzIG9yIFJlZ0V4cCBwYXR0ZXJucyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g2YTZitiz2Kog2YLZitmF2Kkg2YXYs9mF2YjYrSDYqNmH2KcuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21heH1cbiAgICAgKi9cbiAgICBtYXgoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYNmE2Kcg2YrZhdmD2YYg2KPZhiDZitmD2YjZhiDYo9mD2KvYsSDZhdmGICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg2YrYrNioINij2YYg2YrZg9mI2YYgJHtzZW50ZW5jZShuYW1lKX0g2KPZgtmEINmF2YYg2KPZiCDZitiz2KfZiNmKICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChmaWVsZC1sZXZlbCkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWltZX1cbiAgICAgKi9cbiAgICBtaW1lKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZmlsZSBmb3JtYXRzIHdlcmUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gJ9mE2Kcg2YrYs9mF2K0g2KjYqtmG2LPZitmC2KfYqiDYp9mE2YXZhNmB2KfYqi4nO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBtaW1lIHR5cGUgb2YgdXNlci1wcm92aWRlZCBmaWxlIGRvZXMgbm90IG1hdGNoIGFueSBtaW1lIHR5cGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNmK2KzYqCDYo9mGINmK2YPZiNmGICR7c2VudGVuY2UobmFtZSl9INmF2YYg2KfZhNmG2YjYuTogJHthcmdzWzBdfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGZ1bGZpbGwgbWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW59XG4gICAgICovXG4gICAgbWluKHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbiBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBg2YTYpyDZitmF2YPZhiDYo9mGINmK2YPZiNmGINij2YLZhCDZhdmGICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg2YrYrNioINij2YYg2YrZg9mI2YYgJHtzZW50ZW5jZShuYW1lKX0g2LnZhNmJINin2YTYo9mC2YQgJHthcmdzWzBdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbm90fVxuICAgICAqL1xuICAgIG5vdCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gKGFuZCB0aHVzIGRpc2FsbG93ZWQgYnkpIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYOKAnCR7dmFsdWV94oCdINmE2YrYsyAke25hbWV9INmF2LPZhdmI2K3Zi9inINio2YcuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogIElzIG5vdCBhIG51bWJlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlcih7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g2YrYrNioINin2YYg2YrZg9mI2YYg2LHZgtmF2KfZi2A7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZpZWxkLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jcmVxdWlyZWR9XG4gICAgICovXG4gICAgcmVxdWlyZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYSB2YWx1ZSB0byBhIHJlcXVpcmVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INmF2LfZhNmI2KguYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDZhNinINmK2KjYr9ijICR7c2VudGVuY2UobmFtZSl9INio2YAgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYSB1cmxcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3VybH1cbiAgICAgKi9cbiAgICB1cmwoKSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHVybC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDYp9mE2LHYrNin2KEg2KrYttmF2YrZhiDYudmG2YjYp9mGINix2KfYqNi3INi12K3ZititLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIGFyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkcSxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJHFcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJHAgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICdQxZlpZGF0JyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ09kZWJyYXQnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHRvIHJlbW92ZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbDogJ09kZWJyYXQgdsWhZScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhbGwgZmllbGRzIGFyZSBub3QgZmlsbGVkIG91dCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaW5jb21wbGV0ZTogJ1BhcmRvbiwgYWxlIG5lIHbFoWVjaG5hIHBvbGUganNvdSB2eXBsbsSbbmEgc3Byw6F2bsSbLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnT2Rlc2xhdCcsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ8W9w6FkbsO9IHNvdWJvciBuZWJ5bCB2eWJyw6FuJyxcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgdGhlIHBvc3NpYmxlIHN0cmluZ3MgdGhhdCBwZXJ0YWluIHRvIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHZhbGlkYXRpb24kcCA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQcm9zw61tLCB6YcWha3J0bsSbdGUgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYWZ0ZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYWZ0ZXJ9XG4gICAgICovXG4gICAgZGF0ZV9hZnRlcih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c8OtIGLDvXQgcG8gJHtkYXRlKGFyZ3NbMF0pfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzw60gYsO9dCB2IGJ1ZG91Y25vc3RpLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSBsZXR0ZXIuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYX1cbiAgICAgKi9cbiAgICBhbHBoYSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbcWvxb5lIG9ic2Fob3ZhdCBwb3V6ZSBww61zbWVuYS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFscGhhbnVtZXJpY1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGFudW1lcmljfVxuICAgICAqL1xuICAgIGFscGhhbnVtZXJpYyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbcWvxb5lIG9ic2Fob3ZhdCBwb3V6ZSBww61zbWVuYSBhIMSNw61zbGEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGJlZm9yZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZWZvcmV9XG4gICAgICovXG4gICAgZGF0ZV9iZWZvcmUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzw60gYsO9dCBwxZllZCAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzw60gYsO9dCB2IG1pbnVsb3N0aS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBUb3RvIHBvbGUgYnlsbyDFoXBhdG7EmyBuYWtvbmZpZ3Vyb3bDoW5vIGEgbmVtxa/FvmUgYsO9dCBvZGVzbMOhbm8uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzw60gYsO9dCBtZXppICR7YX0gYSAke2J9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjb25maXJtYXRpb24gZmllbGQgZG9lcyBub3QgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2NvbmZpcm19XG4gICAgICovXG4gICAgY29uZmlybSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlcXVhbCB0aGUgdmFsdWUgb2YgdGhlIG1hdGNoZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmVqc291IHNob2Ruw6EuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGRhdGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtZm9ybWF0fVxuICAgICAqL1xuICAgIGRhdGVfZm9ybWF0KHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGRvZXMgbm90IHNhdGlzZnkgdGhlIGRhdGUgZm9ybWF0IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuZW7DrSBwbGF0bsOpIGRhdHVtLCBwcm9zw61tLCBwb3XFvmlqdGUgZm9ybcOhdCAke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICdUb3RvIHBvbGUgYnlsbyDFoXBhdG7EmyBuYWtvbmZpZ3Vyb3bDoW5vIGEgbmVtxa/FvmUgYsO9dCBvZGVzbMOhbm8uJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c8OtIGLDvXQgbWV6aSAke2RhdGUoYXJnc1swXSl9IGEgJHtkYXRlKGFyZ3NbMV0pfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VtYWlsfVxuICAgICAqL1xuICAgIGVtYWlsOiAnUHJvc8OtbSwgemFkZWp0ZSBwbGF0bm91IGUtbWFpbG92b3UgYWRyZXN1LicsXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZW5kIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW5kcy13aXRofVxuICAgICAqL1xuICAgIGVuZHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5la29uxI3DrSBuYSAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNpc31cbiAgICAgKi9cbiAgICBpcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmVuw60gcG92b2xlbsOhIGhvZG5vdGEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IE51bWJlcihmaXJzdCkgPD0gTnVtYmVyKHNlY29uZCkgPyBmaXJzdCA6IHNlY29uZDtcbiAgICAgICAgY29uc3QgbWF4ID0gTnVtYmVyKHNlY29uZCkgPj0gTnVtYmVyKGZpcnN0KSA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICBpZiAobWluID09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYXQgbGVhc3Qgb25lIGNoYXJhY3Rlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzw60gbcOtdCBuZWptw6luxJsgamVkZW4gem5hay5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gPT0gMCAmJiBtYXgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGZpcnN0IGFyZ3VtZW50IHN1cHBsaWVkIHRvIHRoZSBydWxlIGlzIDAsIGFuZCB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsb25nZXIgdGhhbiB0aGUgbWF4ICh0aGUgMm5kIGFyZ3VtZW50KSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbcWvxb5lIG3DrXQgbWF4aW3DoWxuxJsgJHttYXh9IHpuYWvFry5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUgYW5kIHRoZXJlIGlzIG5vIG1heGltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c8OtIG9ic2Fob3ZhdCBtaW5pbcOhbG7EmyAke21pbn0gem5ha8WvLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBiZXR3ZWVuIHRoZSB0d28gbGVuZ3RocyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXPDrSBiw710IGRsb3Vow6kgJHttaW59IGHFviAke21heH0gem5ha8WvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuZW7DrSBwb3ZvbGVuw6EgaG9kbm90YS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFeGNlZWRzIG1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF4fVxuICAgICAqL1xuICAgIG1heCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgTmVsemUgcG91xb7DrXQgdsOtY2UgbmXFviAke2FyZ3NbMF19ICR7bmFtZX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c8OtIG3DrXQgbWVuxaHDrSBuZWJvIHJvdm5vIG5lxb4gJHthcmdzWzBdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgKGZpZWxkLWxldmVsKSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbWltZSB0eXBlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW1lfVxuICAgICAqL1xuICAgIG1pbWUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBmaWxlIGZvcm1hdHMgd2VyZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiAnTmVqc291IG5ha29uZmlndXJvdsOhbnkgcG92b2xlbsOpIHR5cHkgc291Ym9yxa8uJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXPDrSBiw710IHR5cHU6ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE5lbHplIG3DrXQgbcOpbsSbIG5lxb4gJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXPDrSBiw710IG1pbmltw6FsbsSbICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI25vdH1cbiAgICAgKi9cbiAgICBub3QoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0gfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIChhbmQgdGh1cyBkaXNhbGxvd2VkIGJ5KSB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDigJwke3ZhbHVlfeKAnSBuZW7DrSBkb3ZvbGVuw6EgaG9kbm90YSBwcm8gJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgSXMgbm90IGEgbnVtYmVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXPDrSBiw710IMSNw61zbG8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gamUgcG92aW5uw6kuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuZXphxI3DrW7DoSBuYSAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhIHVybFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jdXJsfVxuICAgICAqL1xuICAgIHVybCgpIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgdXJsLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFphZGVqdGUsIHByb3PDrW0sIHBsYXRub3UgVVJMIGFkcmVzdS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbn07XG5cbnZhciBjcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdWk6IHVpJHAsXG4gICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbiRwXG59KTtcblxuLyoqXG4gKiBIZXJlIHdlIGNhbiBpbXBvcnQgYWRkaXRpb25hbCBoZWxwZXIgZnVuY3Rpb25zIHRvIGFzc2lzdCBpbiBmb3JtYXR0aW5nIG91clxuICogbGFuZ3VhZ2UuIEZlZWwgZnJlZSB0byBhZGQgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyB0byBsaWJzL2Zvcm1hdHMgaWYgaXRcbiAqIGFzc2lzdHMgaW4gY3JlYXRpbmcgZ29vZCB2YWxpZGF0aW9uIG1lc3NhZ2VzIGZvciB5b3VyIGxvY2FsZS5cbiAqL1xuLyoqXG4gKiBTdGFuZGFyZCBsYW5ndWFnZSBmb3IgaW50ZXJmYWNlIGZlYXR1cmVzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB1aSRvID0ge1xuICAgIC8qKlxuICAgICAqIFNob3duIG9uIGJ1dHRvbnMgZm9yIGFkZGluZyBuZXcgaXRlbXMuXG4gICAgICovXG4gICAgYWRkOiAnVGlsZsO4aicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhIGJ1dHRvbiB0byByZW1vdmUgaXRlbXMgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmU6ICdGamVybicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgdG8gcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiAnRmplcm4gYWxsZScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhbGwgZmllbGRzIGFyZSBub3QgZmlsbGVkIG91dCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaW5jb21wbGV0ZTogJ0FsbGUgZmVsdGVyIGVyIGlra2Uga29ycmVrdCB1ZGZ5bGR0LicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnU2VuZCcsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ0luZ2VuIGZpbGVyIHZhbGd0Jyxcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgdGhlIHBvc3NpYmxlIHN0cmluZ3MgdGhhdCBwZXJ0YWluIHRvIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHZhbGlkYXRpb24kbyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBBY2NlcHRlciB2ZW5saWdzdCAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gc2thbCB2w6ZyZSBzZW5lcmUgZW5kICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNrYWwgdsOmcmUgaSBmcmVtdGlkZW4uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIGxldHRlci5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhfVxuICAgICAqL1xuICAgIGFscGhhKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBrYW4ga3VuIGluZGVob2xkZSBib2dzdGF2ZXIuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGthbiBrdW4gaW5kZWhvbGRlIGJvZ3N0YXZlciBvZyB0YWwuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBrYW4ga3VuIGluZGVob2xkZSBib2dzdGF2ZXIgb2cgbWVsbGVtcnVtLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNrYWwgdsOmcmUgZsO4ciAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gc2thbCB2w6ZyZSBmw7hyIGkgZGFnLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYERldHRlIGZlbHQgZXIgaWtrZSBrb25maWd1cmVyZXQga29ycmVrdCBvZyBrYW4gZGVyZm9yIGlra2UgYmxpdmUgc2VuZHQuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gc2thbCB2w6ZyZSBtZWxsZW0gJHthfSBvZyAke2J9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjb25maXJtYXRpb24gZmllbGQgZG9lcyBub3QgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2NvbmZpcm19XG4gICAgICovXG4gICAgY29uZmlybSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlcXVhbCB0aGUgdmFsdWUgb2YgdGhlIG1hdGNoZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbWF0Y2hlciBpa2tlLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZXIgaWtrZSBneWxkaWcsIGJydWcgdmVubGlnc3QgZm9ybWF0ZXQgJHthcmdzWzBdfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAnRGV0dGUgZmVsdCBlciBpa2tlIGtvbmZpZ3VyZXJldCBrb3JyZWt0IG9nIGthbiBkZXJmb3IgaWtrZSBibGl2ZSBzZW5kdC4nO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3Qgd2l0aGluIGV4cGVjdGVkIGRhdGUgcmFuZ2VcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBkYXRlX2JldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gc2thbCB2w6ZyZSBtZWxsZW0gJHtkYXRlKGFyZ3NbMF0pfSBvZyAke2RhdGUoYXJnc1sxXSl9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICdJbmR0YXN0IHZlbmxpZ3N0IGVuIGd5bGRpZyBlbWFpbC1hZHJlc3NlLicsXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZW5kIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW5kcy13aXRofVxuICAgICAqL1xuICAgIGVuZHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNsdXR0ZXIgaWtrZSBtZWQgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGVyIGlra2UgZW4gZ3lsZGlnIHbDpnJkaS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNsZW5ndGh9XG4gICAgICovXG4gICAgbGVuZ3RoKHsgbmFtZSwgYXJnczogW2ZpcnN0ID0gMCwgc2Vjb25kID0gSW5maW5pdHldIH0pIHtcbiAgICAgICAgY29uc3QgbWluID0gTnVtYmVyKGZpcnN0KSA8PSBOdW1iZXIoc2Vjb25kKSA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBOdW1iZXIoc2Vjb25kKSA+PSBOdW1iZXIoZmlyc3QpID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgICAgIGlmIChtaW4gPT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBza2FsIHbDpnJlIHDDpSBtaW5kc3Qgw6l0IHRlZ24uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNrYWwgdsOmcmUgcMOlIGjDuGpzdCAke21heH0gdGVnbi5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUgYW5kIHRoZXJlIGlzIG5vIG1heGltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNrYWwgdsOmcmUgcMOlIG1pbmRzdCAke21pbn0gdGVnbi5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gc2thbCB2w6ZyZSBww6UgbWluZHN0ICR7bWlufSBvZyBow7hqc3QgJHttYXh9IHRlZ24uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsdWUgaXMgbm90IGEgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21hdGNoZXN9XG4gICAgICovXG4gICAgbWF0Y2hlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHZhbHVlcyBvciBSZWdFeHAgcGF0dGVybnMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGVyIGlra2UgZW4gZ3lsZGlnIHbDpnJkaS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFeGNlZWRzIG1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF4fVxuICAgICAqL1xuICAgIG1heCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgS2FuIGlra2UgaGF2ZSBmbGVyZSBlbmQgJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBza2FsIHbDpnJlIG1pbmRyZSBlbGxlciBsaWcgbWVkICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChmaWVsZC1sZXZlbCkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWltZX1cbiAgICAgKi9cbiAgICBtaW1lKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZmlsZSBmb3JtYXRzIHdlcmUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gJ0luZ2VuIGZpbGZvcm1hdGVyIHRpbGxhZHQuJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBza2FsIHbDpnJlIGFmIGZpbHR5cGVuOiAke2FyZ3NbMF19YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZnVsZmlsbCBtaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbn1cbiAgICAgKi9cbiAgICBtaW4oeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBLYW4gaWtrZSBoYXZlIG1pbmRyZSBlbmQgJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBza2FsIHbDpnJlIG1pbmRzdCAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9IH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byAoYW5kIHRodXMgZGlzYWxsb3dlZCBieSkgdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg4oCcJHt2YWx1ZX3igJ0gZXIgaWtrZSBlbiB0aWxsYWR0ICR7bmFtZX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogIElzIG5vdCBhIG51bWJlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlcih7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gc2thbCB2w6ZyZSBldCB0YWwuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZXIgcMOla3LDpnZldC5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBzdGFydCB3aXRoIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jc3RhcnRzLXdpdGh9XG4gICAgICovXG4gICAgc3RhcnRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHN0YXJ0ZXIgaWtrZSBtZWQgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYSB1cmxcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3VybH1cbiAgICAgKi9cbiAgICB1cmwoKSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHVybC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBJbmR0YXN0IHZlbmxpZ3N0IGVuIGd5bGRpZyBVUkwuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgZGEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSRvLFxuICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24kb1xufSk7XG5cbi8qKlxuICogSGVyZSB3ZSBjYW4gaW1wb3J0IGFkZGl0aW9uYWwgaGVscGVyIGZ1bmN0aW9ucyB0byBhc3Npc3QgaW4gZm9ybWF0dGluZyBvdXJcbiAqIGxhbmd1YWdlLiBGZWVsIGZyZWUgdG8gYWRkIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgdG8gbGlicy9mb3JtYXRzIGlmIGl0XG4gKiBhc3Npc3RzIGluIGNyZWF0aW5nIGdvb2QgdmFsaWRhdGlvbiBtZXNzYWdlcyBmb3IgeW91ciBsb2NhbGUuXG4gKi9cbi8qKlxuICogU3RhbmRhcmQgbGFuZ3VhZ2UgZm9yIGludGVyZmFjZSBmZWF0dXJlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdWkkbiA9IHtcbiAgICAvKipcbiAgICAgKiBTaG93biBvbiBidXR0b25zIGZvciBhZGRpbmcgbmV3IGl0ZW1zLlxuICAgICAqL1xuICAgIGFkZDogJ0hpbnp1ZsO8Z2VuJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ0VudGZlcm5lbicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgdG8gcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiAnQWxsZXMgZW50ZmVybmVuJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAnRW50c2NodWxkaWd1bmcsIG5pY2h0IGFsbGUgRmVsZGVyIHd1cmRlbiBrb3JyZWt0IGF1c2dlZsO8bGx0LicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnU2VuZGVuJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIG5vIGZpbGVzIGFyZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBub0ZpbGVzOiAnS2VpbmUgRGF0ZWkgYXVzZ2V3w6RobHQnLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiRuID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYEJpdHRlICR7bmFtZX0gYWt6ZXB0aWVyZW4uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGFmdGVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWFmdGVyfVxuICAgICAqL1xuICAgIGRhdGVfYWZ0ZXIoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXNzIG5hY2ggZGVtICR7ZGF0ZShhcmdzWzBdKX0gbGllZ2VuLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXNzIGluIGRlciBadWt1bmZ0IGxpZWdlbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRhcmYgbnVyIEJ1Y2hzdGFiZW4gZW50aGFsdGVuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkYXJmIG51ciBCdWNoc3RhYmVuIHVuZCBaYWhsZW4gZW50aGFsdGVuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgbGV0dGVyIGFuZC9vciBzcGFjZXNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhLXNwYWNlc31cbiAgICAgKi9cbiAgICBhbHBoYV9zcGFjZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBhbmQgbm9uLXNwYWNlIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZMO8cmZlbiBudXIgQnVjaHN0YWJlbiB1bmQgTGVlcnplaWNoZW4gZW50aGFsdGVuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3Mgdm9yIGRlbSAke2RhdGUoYXJnc1swXSl9IGxpZWdlbi5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3MgaW4gZGVyIFZlcmdhbmdlbmhlaXQgbGllZ2VuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYERpZXNlcyBGZWxkIHd1cmRlIGZhbHNjaCBrb25maWd1cmllcnQgdW5kIGthbm4gbmljaHQgw7xiZXJtaXR0ZWx0IHdlcmRlbi5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3Mgendpc2NoZW4gJHthcmdzWzBdfSB1bmQgJHthcmdzWzFdfSBzZWluLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjb25maXJtYXRpb24gZmllbGQgZG9lcyBub3QgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2NvbmZpcm19XG4gICAgICovXG4gICAgY29uZmlybSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlcXVhbCB0aGUgdmFsdWUgb2YgdGhlIG1hdGNoZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gc3RpbW10IG5pY2h0IMO8YmVyZWluLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaXN0IGtlaW4gZ8O8bHRpZ2VzIERhdHVtIGltIEZvcm1hdCAke2FyZ3NbMF19LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAnRGllc2VzIEZlbGQgd3VyZGUgZmFsc2NoIGtvbmZpZ3VyaWVydCB1bmQga2FubiBuaWNodCDDvGJlcm1pdHRlbHQgd2VyZGVuLic7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCB3aXRoaW4gZXhwZWN0ZWQgZGF0ZSByYW5nZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZXR3ZWVufVxuICAgICAqL1xuICAgIGRhdGVfYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGRhdGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXNzIHp3aXNjaGVuICR7ZGF0ZShhcmdzWzBdKX0gdW5kICR7ZGF0ZShhcmdzWzFdKX0gbGllZ2VuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VtYWlsfVxuICAgICAqL1xuICAgIGVtYWlsOiAnRS1NYWlsIEFkcmVzc2UgaXN0IHVuZ8O8bHRpZy4nLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBlbmRldCBuaWNodCBtaXQgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGVudGjDpGx0IGVpbmVuIHVuZ8O8bHRpZ2VuIFdlcnQuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IGZpcnN0IDw9IHNlY29uZCA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBzZWNvbmQgPj0gZmlyc3QgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgaWYgKG1pbiA9PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3MgbWluZGVzdGVucyBlaW4gWmVpY2hlbiBlbnRoYWx0ZW4uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRhcmYgbWF4aW1hbCAke21heH0gWmVpY2hlbiBlbnRoYWx0ZW4uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXNzIG1pbmRlc3RlbnMgJHttaW59IFplaWNoZW4gZW50aGFsdGVuLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBiZXR3ZWVuIHRoZSB0d28gbGVuZ3RocyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXNzIHp3aXNjaGVuICR7bWlufSB1bmQgJHttYXh9IFplaWNoZW4gZW50aGFsdGVuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBlbnRow6RsdCBlaW5lbiB1bmfDvGx0aWdlbiBXZXJ0LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBEYXJmIG1heGltYWwgJHthcmdzWzBdfSAke25hbWV9IGhhYmVuLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkYXJmIG1heGltYWwgJHthcmdzWzBdfSBzZWluLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICdLZWluZSBEYXRlaWZvcm1hdGUga29uZmlndXJpZXJ0Lic7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIG1pbWUgdHlwZSBvZiB1c2VyLXByb3ZpZGVkIGZpbGUgZG9lcyBub3QgbWF0Y2ggYW55IG1pbWUgdHlwZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzcyB2b20gVHlwICR7YXJnc1swXX0gc2Vpbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE1pbmRlc3RlbnMgJHthcmdzWzBdfSAke25hbWV9IGVyZm9yZGVybGljaC5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzcyBtaW5kZXN0ZW5zICR7YXJnc1swXX0gc2Vpbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbm90fVxuICAgICAqL1xuICAgIG5vdCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gKGFuZCB0aHVzIGRpc2FsbG93ZWQgYnkpIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYOKAnCR7dmFsdWV94oCdIGlzdCBrZWluIGfDvGx0aWdlciBXZXJ0IGbDvHIgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgSXMgbm90IGEgbnVtYmVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXNzIGVpbmUgWmFobCBzZWluLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZpZWxkLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jcmVxdWlyZWR9XG4gICAgICovXG4gICAgcmVxdWlyZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYSB2YWx1ZSB0byBhIHJlcXVpcmVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGlzdCBlcmZvcmRlcmxpY2guYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBiZWdpbm50IG5pY2h0IG1pdCAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhIHVybFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jdXJsfVxuICAgICAqL1xuICAgIHVybCgpIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgdXJsLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFVSTCBpc3QgdW5nw7xsdGlnLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIGRlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkbixcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJG5cbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJG0gPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYSBidXR0b24gZm9yIGFkZGluZyBhZGRpdGlvbmFsIGl0ZW1zLlxuICAgICAqL1xuICAgIGFkZDogJ0FkZCcsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhIGJ1dHRvbiB0byByZW1vdmUgaXRlbXMgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmU6ICdSZW1vdmUnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHRvIHJlbW92ZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbDogJ1JlbW92ZSBhbGwnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICdTb3JyeSwgbm90IGFsbCBmaWVsZHMgYXJlIGZpbGxlZCBvdXQgY29ycmVjdGx5LicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnU3VibWl0JyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIG5vIGZpbGVzIGFyZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBub0ZpbGVzOiAnTm8gZmlsZSBjaG9zZW4nLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiRtID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFBsZWFzZSBhY2NlcHQgdGhlICR7bmFtZX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGFmdGVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWFmdGVyfVxuICAgICAqL1xuICAgIGRhdGVfYWZ0ZXIoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXN0IGJlIGFmdGVyICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3QgYmUgaW4gdGhlIGZ1dHVyZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGNhbiBvbmx5IGNvbnRhaW4gYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycyBhbmQgbnVtYmVycy5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGxldHRlciBhbmQvb3Igc3BhY2VzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYS1zcGFjZXN9XG4gICAgICovXG4gICAgYWxwaGFfc3BhY2VzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgYW5kIG5vbi1zcGFjZSBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycyBhbmQgc3BhY2VzLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3QgYmUgYmVmb3JlICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXN0IGJlIGluIHRoZSBwYXN0LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYFRoaXMgZmllbGQgd2FzIGNvbmZpZ3VyZWQgaW5jb3JyZWN0bHkgYW5kIGNhbuKAmXQgYmUgc3VibWl0dGVkLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2EsIGJdID0gb3JkZXIoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3QgYmUgYmV0d2VlbiAke2F9IGFuZCAke2J9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjb25maXJtYXRpb24gZmllbGQgZG9lcyBub3QgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2NvbmZpcm19XG4gICAgICovXG4gICAgY29uZmlybSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlcXVhbCB0aGUgdmFsdWUgb2YgdGhlIG1hdGNoZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZG9lcyBub3QgbWF0Y2guYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGRhdGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtZm9ybWF0fVxuICAgICAqL1xuICAgIGRhdGVfZm9ybWF0KHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGRvZXMgbm90IHNhdGlzZnkgdGhlIGRhdGUgZm9ybWF0IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBpcyBub3QgYSB2YWxpZCBkYXRlLCBwbGVhc2UgdXNlIHRoZSBmb3JtYXQgJHthcmdzWzBdfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAnVGhpcyBmaWVsZCB3YXMgY29uZmlndXJlZCBpbmNvcnJlY3RseSBhbmQgY2Fu4oCZdCBiZSBzdWJtaXR0ZWQnO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3Qgd2l0aGluIGV4cGVjdGVkIGRhdGUgcmFuZ2VcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBkYXRlX2JldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzdCBiZSBiZXR3ZWVuICR7ZGF0ZShhcmdzWzBdKX0gYW5kICR7ZGF0ZShhcmdzWzFdKX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbWFpbH1cbiAgICAgKi9cbiAgICBlbWFpbDogJ1BsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuJyxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbmRzLXdpdGh9XG4gICAgICovXG4gICAgZW5kc193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVuZCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZG9lc27igJl0IGVuZCB3aXRoICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2lzfVxuICAgICAqL1xuICAgIGlzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBpcyBub3QgYW4gYWxsb3dlZCB2YWx1ZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNsZW5ndGh9XG4gICAgICovXG4gICAgbGVuZ3RoKHsgbmFtZSwgYXJnczogW2ZpcnN0ID0gMCwgc2Vjb25kID0gSW5maW5pdHldIH0pIHtcbiAgICAgICAgY29uc3QgbWluID0gTnVtYmVyKGZpcnN0KSA8PSBOdW1iZXIoc2Vjb25kKSA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBOdW1iZXIoc2Vjb25kKSA+PSBOdW1iZXIoZmlyc3QpID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgICAgIGlmIChtaW4gPT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fSBjaGFyYWN0ZXJzLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBzdXBwbGllZCB0byB0aGUgcnVsZSBhbmQgdGhlcmUgaXMgbm8gbWF4aW11bSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHttaW59IGNoYXJhY3RlcnMuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGJldHdlZW4gdGhlIHR3byBsZW5ndGhzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3QgYmUgYmV0d2VlbiAke21pbn0gYW5kICR7bWF4fSBjaGFyYWN0ZXJzLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBpcyBub3QgYW4gYWxsb3dlZCB2YWx1ZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFeGNlZWRzIG1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF4fVxuICAgICAqL1xuICAgIG1heCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgQ2Fubm90IGhhdmUgbW9yZSB0aGFuICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHthcmdzWzBdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgKGZpZWxkLWxldmVsKSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbWltZSB0eXBlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW1lfVxuICAgICAqL1xuICAgIG1pbWUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBmaWxlIGZvcm1hdHMgd2VyZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiAnTm8gZmlsZSBmb3JtYXRzIGFsbG93ZWQuJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXN0IGJlIG9mIHRoZSB0eXBlOiAke2FyZ3NbMF19YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZnVsZmlsbCBtaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbn1cbiAgICAgKi9cbiAgICBtaW4oeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBDYW5ub3QgaGF2ZSBsZXNzIHRoYW4gJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXN0IGJlIGF0IGxlYXN0ICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI25vdH1cbiAgICAgKi9cbiAgICBub3QoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0gfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIChhbmQgdGh1cyBkaXNhbGxvd2VkIGJ5KSB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDigJwke3ZhbHVlfeKAnSBpcyBub3QgYW4gYWxsb3dlZCAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c3QgYmUgYSBudW1iZXIuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaXMgcmVxdWlyZWQuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkb2VzbuKAmXQgc3RhcnQgd2l0aCAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhIHVybFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jdXJsfVxuICAgICAqL1xuICAgIHVybCgpIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgdXJsLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFBsZWFzZSBpbmNsdWRlIGEgdmFsaWQgdXJsLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIGVuID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkbSxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJG1cbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJGwgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICdBw7FhZGlyJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ1F1aXRhcicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgdG8gcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiAnUXVpdGFyIHRvZG9zJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAnRGlzY8O6bHBlLCBsb3MgY2FtcG9zIG5vIGZ1ZXJvbiBjb21wbGV0YWRvcyBjb3JyZWN0YW1lbnRlLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnRW52aWFyJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIG5vIGZpbGVzIGFyZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBub0ZpbGVzOiAnQXJjaGl2byBubyBzZWxlY2Npb25hZG8nLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiRsID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYEFjZXB0ZSBlbCAke25hbWV9IHBvciBmYXZvci5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYWZ0ZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYWZ0ZXJ9XG4gICAgICovXG4gICAgZGF0ZV9hZnRlcih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRlYmUgc2VyIHBvc3RlcmlvciBhICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRlYmUgc2VyIHVuYSBmZWNoYSBmdXR1cmEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIGxldHRlci5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhfVxuICAgICAqL1xuICAgIGFscGhhKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZWJlIGNvbnRlbmVyIHNvbG8gY2FyYWN0w6lyZXMgYWxmYWLDqXRpY29zLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZWJlIHNlciBhbGZhbnVtw6lyaWNvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgbGV0dGVyIGFuZC9vciBzcGFjZXNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhLXNwYWNlc31cbiAgICAgKi9cbiAgICBhbHBoYV9zcGFjZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBhbmQgbm9uLXNwYWNlIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZXNwYWNpb3MgYWxmYSBzb2xvIHB1ZWRlbiBjb250ZW5lciBsZXRyYXMgeSBlc3BhY2lvcy5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYmVmb3JlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJlZm9yZX1cbiAgICAgKi9cbiAgICBkYXRlX2JlZm9yZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZWJlIHNlciBhbnRlcmlvciBhICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZWJlIHNlciB1bmEgZmVjaGEgcGFzYWRhLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYEVsIGNhbXBvIG5vIGZ1ZSBjb21wbGV0YWRvIGNvcnJlY3RhbWVudGUgeSBubyBwdWVkZSBzZXIgZW52aWFkby5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthLCBiXSA9IG9yZGVyKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZWJlIGVzdGFyIGVudHJlICR7YX0geSAke2J9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjb25maXJtYXRpb24gZmllbGQgZG9lcyBub3QgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2NvbmZpcm19XG4gICAgICovXG4gICAgY29uZmlybSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlcXVhbCB0aGUgdmFsdWUgb2YgdGhlIG1hdGNoZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbm8gY29pbmNpZGUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGRhdGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtZm9ybWF0fVxuICAgICAqL1xuICAgIGRhdGVfZm9ybWF0KHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGRvZXMgbm90IHNhdGlzZnkgdGhlIGRhdGUgZm9ybWF0IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBubyBlcyB1bmEgZmVjaGEgdsOhbGlkYSwgcG9yIGZhdm9yIHV0aWxpY2UgZWwgZm9ybWF0byAke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICdFbCBjYW1wbyBubyBmdWUgY29tcGxldGFkbyBjb3JyZWN0YW1lbnRlIHkgbm8gcHVlZGUgc2VyIGVudmlhZG8uJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRlYmUgZXN0YXIgZW50cmUgJHtkYXRlKGFyZ3NbMF0pfSB5ICR7ZGF0ZShhcmdzWzFdKX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbWFpbH1cbiAgICAgKi9cbiAgICBlbWFpbDogJ0luZ3Jlc2UgdW5hIGRpcmVjY2nDs24gZGUgY29ycmVvIGVsZWN0csOzbmljbyB2w6FsaWRhIHBvciBmYXZvci4nLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBubyB0ZXJtaW5hIGNvbiAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNpc31cbiAgICAgKi9cbiAgICBpcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbm8gZXMgdW4gdmFsb3IgcGVybWl0aWRvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBsZW5ndGhcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2xlbmd0aH1cbiAgICAgKi9cbiAgICBsZW5ndGgoeyBuYW1lLCBhcmdzOiBbZmlyc3QgPSAwLCBzZWNvbmQgPSBJbmZpbml0eV0gfSkge1xuICAgICAgICBjb25zdCBtaW4gPSBOdW1iZXIoZmlyc3QpIDw9IE51bWJlcihzZWNvbmQpID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgICAgIGNvbnN0IG1heCA9IE51bWJlcihzZWNvbmQpID49IE51bWJlcihmaXJzdCkgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgaWYgKG1pbiA9PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRlYmUgdGVuZXIgYWwgbWVub3MgdW5hIGxldHJhLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZWJlIHRlbmVyIGNvbW8gbcOheGltbyAke21heH0gY2FyYWN0w6lyZXMuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZWJlIHRlbmVyIGNvbW8gbcOtbmltbyAke21pbn0gY2FyYWN0w6lyZXMuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGJldHdlZW4gdGhlIHR3byBsZW5ndGhzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRlYmUgdGVuZXIgZW50cmUgJHttaW59IHkgJHttYXh9IGNhcmFjdMOpcmVzLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBubyBlcyB1biB2YWxvciBwZXJtaXRpZG8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21heH1cbiAgICAgKi9cbiAgICBtYXgoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYENhbm5vdCBoYXZlIG1vcmUgdGhhbiAke2FyZ3NbMF19ICR7bmFtZX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRlYmUgc2VyIG1lbm9yIG8gaWd1YWwgYSAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICdObyBleGlzdGVuIGZvcm1hdG9zIGRlIGFyY2hpdm9zIHBlcm1pdGlkb3MuJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZWJlIHNlciBkZWwgdGlwbzogJHthcmdzWzBdfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGZ1bGZpbGwgbWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW59XG4gICAgICovXG4gICAgbWluKHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbiBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgQ2Fubm90IGhhdmUgbGVzcyB0aGFuICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGViZSBzZXIgZGUgYWwgbWVub3MgJHthcmdzWzBdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbm90fVxuICAgICAqL1xuICAgIG5vdCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gKGFuZCB0aHVzIGRpc2FsbG93ZWQgYnkpIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYOKAnCR7dmFsdWV94oCdIG5vIGVzIHVuIHZhbG9yIHBlcm1pdGlkbyBkZSAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRlYmUgc2VyIHVuIG7Dum1lcm8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZXMgcmVxdWVyaWRvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGViZSBjb21lbnphciBjb24gJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYSB1cmxcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3VybH1cbiAgICAgKi9cbiAgICB1cmwoKSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHVybC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQcm9wb3JjaW9uZSB1bmEgVVJMIHbDoWxpZGEgcG9yIGZhdm9yLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkbCxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJGxcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJGsgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICfYp9mB2LLZiNiv2YYnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYSBidXR0b24gdG8gcmVtb3ZlIGl0ZW1zIGlzIHZpc2libGUuXG4gICAgICovXG4gICAgcmVtb3ZlOiAn2K3YsNmBJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyB0byByZW1vdmUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6ICfZh9mF2Ycg2LHYpyDYrdiw2YEg2qnZhtuM2K8nLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICfZh9mF2Ycg2YHbjNmE2K/Zh9inINio2YfigIzYr9ix2LPYqtuMINm+2LEg2YbYtNiv2YfigIzYp9mG2K8nLFxuICAgIC8qKlxuICAgICAqIFNob3duIGluIGEgYnV0dG9uIGluc2lkZSBhIGZvcm0gdG8gc3VibWl0IHRoZSBmb3JtLlxuICAgICAqL1xuICAgIHN1Ym1pdDogJ9ir2KjYqicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ9mH24zahiDZgdin24zZhNuMINin2YbYqtiu2KfYqCDZhti02K/ZhyDYp9iz2KonLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiRrID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNmE2LfZgdin2YsgJHtuYW1lfSDYsdinINio2b7YsNuM2LHbjNivLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g2KjYp9uM2K8g2KjYudivINin2LIg2KrYp9ix24zYriAke2RhdGUoYXJnc1swXSl9INio2KfYtNivLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDYqNin24zYryDZhdix2KjZiNi3INio2Ycg2KLbjNmG2K/ZhyDYqNin2LTYry5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INmB2YLYtyDZhduM2KrZiNin2YbYryDYtNin2YXZhCDYrdix2YjZgSDYp9mE2YHYqNinINio2KfYtNivLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDZgdmC2Lcg2YXbjNiq2YjYp9mG2K8g2LTYp9mF2YQg2K3YsdmI2YEg2Ygg2KfYudiv2KfYryDYqNin2LTYry5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGxldHRlciBhbmQvb3Igc3BhY2VzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYS1zcGFjZXN9XG4gICAgICovXG4gICAgYWxwaGFfc3BhY2VzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgYW5kIG5vbi1zcGFjZSBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INmB2YLYtyDZhduMINiq2YjYp9mG2K8g2LTYp9mF2YQg2K3YsdmI2YEg2Ygg2YHYp9i12YTZhyDYqNin2LTYry5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYmVmb3JlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJlZm9yZX1cbiAgICAgKi9cbiAgICBkYXRlX2JlZm9yZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDYqNin24zYryDZgtio2YQg2KfYsiDYqtin2LHbjNiuICR7ZGF0ZShhcmdzWzBdKX0g2KjYp9i02K8uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDYqNin24zYryDZhdix2KjZiNi3INio2Ycg2q/YsNi02KrZhyDYqNin2LTYry5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGDYp9uM2YYg2YHbjNmE2K8g2KjZhyDYp9i02KrYqNin2Ycg2b7bjNqp2LHYqNmG2K/bjCDYtNiv2Ycg2KfYs9iqINmIINmC2KfYqNmEINin2LHYs9in2YQg2YbbjNiz2KpgO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INio2KfbjNivINio24zZhiAke2FyZ3NbMF19INmIICR7YXJnc1sxXX0g2KjYp9i02K8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpcm1hdGlvbiBmaWVsZCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jY29uZmlybX1cbiAgICAgKi9cbiAgICBjb25maXJtKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgbWF0Y2hlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDZhdi32KfYqNmC2Kog2YbYr9in2LHYry5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1mb3JtYXR9XG4gICAgICovXG4gICAgZGF0ZV9mb3JtYXQoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgZG9lcyBub3Qgc2F0aXNmeSB0aGUgZGF0ZSBmb3JtYXQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INiq2KfYsduM2K4g2YXYudiq2KjYsduMINmG24zYs9iq2Iwg2YTYt9mB2KfZiyDYp9iyINmC2KfZhNioICR7YXJnc1swXX0g2KfYs9iq2YHYp9iv2Ycg2qnZhtuM2K9cbmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAn2KfbjNmGINmB24zZhNivINio2Ycg2KfYtNiq2KjYp9mHINm+24zaqdix2KjZhtiv24wg2LTYr9mHINin2LPYqiDZiCDZgtin2KjZhCDYp9ix2LPYp9mEINmG24zYs9iqJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INio2KfbjNivINio24zZhiAke2RhdGUoYXJnc1swXSl9INmIICR7ZGF0ZShhcmdzWzFdKX0g2KjYp9i02K8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICfZhNi32YHYpyDYotiv2LHYsyDYp9uM2YXbjNmEINmF2LnYqtio2LEg2YjYp9ix2K8g2qnZhtuM2K8uJyxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbmRzLXdpdGh9XG4gICAgICovXG4gICAgZW5kc193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVuZCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g2KjYp9uM2K8g2KjZhyAke2xpc3QoYXJncyl9INiu2KrZhSDYtNmI2K8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2lzfVxuICAgICAqL1xuICAgIGlzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDZhdis2KfYsiDZhtuM2LPYqi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNsZW5ndGh9XG4gICAgICovXG4gICAgbGVuZ3RoKHsgbmFtZSwgYXJnczogW2ZpcnN0ID0gMCwgc2Vjb25kID0gSW5maW5pdHldIH0pIHtcbiAgICAgICAgY29uc3QgbWluID0gZmlyc3QgPD0gc2Vjb25kID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgICAgIGNvbnN0IG1heCA9IHNlY29uZCA+PSBmaXJzdCA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICBpZiAobWluID09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYXQgbGVhc3Qgb25lIGNoYXJhY3Rlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g2KjYp9uM2K8g2K3Yr9in2YLZhCDbjNqpINqp2KfYsdin2qnYqtixINio2KfYtNivLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDYqNin24zYryDaqdmF2KrYsSDbjNinINio2LHYp9io2LEg2KjYpyAke21heH0g2qnYp9ix2Kfaqdiq2LEg2KjYp9i02K8uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDYqNin24zYryDYqNiy2LHar9iq2LEg24zYpyDYqNix2KfYqNixINio2KcgJHttaW59INqp2KfYsdin2qnYqtixINio2KfYtNivLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBiZXR3ZWVuIHRoZSB0d28gbGVuZ3RocyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDYqNin24zYryDYqNuM2YYgJHttaW59INmIICR7bWF4fSDaqdin2LHYp9qp2KrYsSDYqNin2LTYry5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBpcyBub3QgYSBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF0Y2hlc31cbiAgICAgKi9cbiAgICBtYXRjaGVzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgdmFsdWVzIG9yIFJlZ0V4cCBwYXR0ZXJucyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g2YXYrNin2LIg2YbbjNiz2KouYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21heH1cbiAgICAgKi9cbiAgICBtYXgoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX0g2YbZhduMINiq2YjYp9mG2K8g2KjbjNi0INin2LIgJHthcmdzWzBdfSDYqNin2LTYry5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g2KjYp9uM2K8g2qnZhdiq2LEg24zYpyDYqNix2KfYqNixINio2KcgJHthcmdzWzBdfSDYqNin2LTYry5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgKGZpZWxkLWxldmVsKSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbWltZSB0eXBlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW1lfVxuICAgICAqL1xuICAgIG1pbWUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBmaWxlIGZvcm1hdHMgd2VyZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiAn2YHYsdmF2Kog2YHYp9uM2YQg2YXYrNin2LIg2YbbjNiz2KouJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDYqNin24zYryDYp9iyINin24zZhiDZhtmI2Lkg2KjYp9i02K86ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX0g2YbZhduMINiq2YjYp9mG2K8g2qnZhdiq2LEg2KfYsiAke2FyZ3NbMF19INio2KfYtNivLlxuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INio2KfbjNivINit2K/Yp9mC2YQgJHthcmdzWzBdfSDYqNin2LTYry5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbm90fVxuICAgICAqL1xuICAgIG5vdCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gKGFuZCB0aHVzIGRpc2FsbG93ZWQgYnkpIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFwiJHt2YWx1ZX1cIiDbjNqpICR7bmFtZX0g2YXYrNin2LIg2YbbjNiz2KouYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogIElzIG5vdCBhIG51bWJlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlcih7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g2KjYp9uM2K8g2LnYr9ivINio2KfYtNivLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZpZWxkLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jcmVxdWlyZWR9XG4gICAgICovXG4gICAgcmVxdWlyZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYSB2YWx1ZSB0byBhIHJlcXVpcmVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYNm+2LEg2qnYsdiv2YYgJHtzZW50ZW5jZShuYW1lKX0g2KfYrNio2KfYsduMINin2LPYqi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBzdGFydCB3aXRoIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jc3RhcnRzLXdpdGh9XG4gICAgICovXG4gICAgc3RhcnRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INio2KfbjNivINio2KcgJHtsaXN0KGFyZ3MpfSDYtNix2YjYuSDYtNmI2K8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBg2YTYt9mB2KfZiyDYotiv2LHYsyDYp9uM2YbYqtix2YbYqtuMINmF2LnYqtio2LEg2YjYp9ix2K8g2qnZhtuM2K8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgZmEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSRrLFxuICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24ka1xufSk7XG5cbi8qKlxuICogSGVyZSB3ZSBjYW4gaW1wb3J0IGFkZGl0aW9uYWwgaGVscGVyIGZ1bmN0aW9ucyB0byBhc3Npc3QgaW4gZm9ybWF0dGluZyBvdXJcbiAqIGxhbmd1YWdlLiBGZWVsIGZyZWUgdG8gYWRkIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgdG8gbGlicy9mb3JtYXRzIGlmIGl0XG4gKiBhc3Npc3RzIGluIGNyZWF0aW5nIGdvb2QgdmFsaWRhdGlvbiBtZXNzYWdlcyBmb3IgeW91ciBsb2NhbGUuXG4gKi9cbi8qKlxuICogU3RhbmRhcmQgbGFuZ3VhZ2UgZm9yIGludGVyZmFjZSBmZWF0dXJlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdWkkaiA9IHtcbiAgICAvKipcbiAgICAgKiBTaG93biBvbiBidXR0b25zIGZvciBhZGRpbmcgbmV3IGl0ZW1zLlxuICAgICAqL1xuICAgIGFkZDogJ0xpc8Okw6QnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYSBidXR0b24gdG8gcmVtb3ZlIGl0ZW1zIGlzIHZpc2libGUuXG4gICAgICovXG4gICAgcmVtb3ZlOiAnUG9pc3RhJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyB0byByZW1vdmUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6ICdQb2lzdGEga2Fpa2tpJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAnS2Fpa2tpYSBrZW50dGnDpCBlaSBvbGUgdMOkeXRldHR5IG9pa2Vpbi4nLFxuICAgIC8qKlxuICAgICAqIFNob3duIGluIGEgYnV0dG9uIGluc2lkZSBhIGZvcm0gdG8gc3VibWl0IHRoZSBmb3JtLlxuICAgICAqL1xuICAgIHN1Ym1pdDogJ1RhbGxlbm5hJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIG5vIGZpbGVzIGFyZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBub0ZpbGVzOiAnRWkgdmFsaXR0dWphIHRpZWRvc3RvamEnLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiRqID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYE9sZSBoeXbDpCBqYSBoeXbDpGtzeSAke25hbWV9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGFmdGVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWFmdGVyfVxuICAgICAqL1xuICAgIGRhdGVfYWZ0ZXIoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0dWxlZSBvbGxhICR7ZGF0ZShhcmdzWzBdKX0gasOkbGtlZW4uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG9uIG9sdGF2YSB0dWxldmFpc3V1ZGVzc2EuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIGxldHRlci5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhfVxuICAgICAqL1xuICAgIGFscGhhKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBzYWEgc2lzw6RsdMOkw6QgdmFpbiBraXJqYWltaWEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNhYSBzaXPDpGx0w6TDpCB2YWluIGtpcmphaW1pYSBqYSBudW1lcm9pdGEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB2b2l2YXQgc2lzw6RsdMOkw6QgdmFpbiBraXJqYWltaWEgamEgdsOkbGlsecO2bnRlasOkLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHR1bGVlIG9sbGEgZW5uZW46ICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBvbiBvbHRhdmEgbWVubmVpc3l5ZGVzc8OkLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYFTDpG3DpCBrZW50dMOkIG9uIHTDpHl0ZXR0eSB2aXJoZWVsbGlzZXN0aSBqb3RlbiBzaXTDpCBlaSB2b2l0dSBsw6RoZXR0w6TDpC5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthLCBiXSA9IG9yZGVyKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBvbiBvbHRhdmEgdsOkbGlsbMOkICR7YX0gLSAke2J9IGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjb25maXJtYXRpb24gZmllbGQgZG9lcyBub3QgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2NvbmZpcm19XG4gICAgICovXG4gICAgY29uZmlybSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlcXVhbCB0aGUgdmFsdWUgb2YgdGhlIG1hdGNoZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZWkgdMOkc23DpMOkLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZWkgb2xlIHZhbGlkaSBww6RpdsOkbcOkw6Ryw6QsIG9sZSBoeXbDpCBqYSBzecO2dMOkIG11b2Rvc3NhOiAke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICdUw6Rtw6Qga2VudHTDpCBvbiB0w6R5dGV0dHkgdmlyaGVlbGxpc2VzdGkgam90ZW4gc2l0w6QgZWkgdm9pdHUgbMOkaGV0dMOkw6QuJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG9uIG9sdGF2YSB2w6RsaWxsw6QgJHtkYXRlKGFyZ3NbMF0pfSAtICR7ZGF0ZShhcmdzWzFdKX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbWFpbH1cbiAgICAgKi9cbiAgICBlbWFpbDogJ1N5w7Z0w6QgdmFsaWRpIHPDpGhrw7Zwb3N0aW9zb2l0ZS4nLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0dWxlZSBww6TDpHR0ecOkICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2lzfVxuICAgICAqL1xuICAgIGlzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBlaSBvbGUgc2FsbGl0dHUgdmFpaHRvZWh0by5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNsZW5ndGh9XG4gICAgICovXG4gICAgbGVuZ3RoKHsgbmFtZSwgYXJnczogW2ZpcnN0ID0gMCwgc2Vjb25kID0gSW5maW5pdHldIH0pIHtcbiAgICAgICAgY29uc3QgbWluID0gTnVtYmVyKGZpcnN0KSA8PSBOdW1iZXIoc2Vjb25kKSA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBOdW1iZXIoc2Vjb25kKSA+PSBOdW1iZXIoZmlyc3QpID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgICAgIGlmIChtaW4gPT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBvbiBvbHRhdmEgdsOkaGludMOkw6RuIHlrc2kgbWVya2tpLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBvbiBvbHRhdmEgJHttYXh9IHRhaSBhbGxlIG1lcmtracOkLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBzdXBwbGllZCB0byB0aGUgcnVsZSBhbmQgdGhlcmUgaXMgbm8gbWF4aW11bSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gb24gb2x0YXZhIHbDpGhpbnTDpMOkbiAke21pbn0gbWVya2tpw6QuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGJldHdlZW4gdGhlIHR3byBsZW5ndGhzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG9uIG9sdGF2YSB2w6RoaW50w6TDpG4gJHttaW59LCBlbmludMOkw6RuICR7bWF4fSBtZXJra2nDpC5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBpcyBub3QgYSBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF0Y2hlc31cbiAgICAgKi9cbiAgICBtYXRjaGVzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgdmFsdWVzIG9yIFJlZ0V4cCBwYXR0ZXJucyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZWkgb2xlIHNhbGxpdHR1IGFydm8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21heH1cbiAgICAgKi9cbiAgICBtYXgoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYFZhbGl0c2UgZW5pbnTDpMOkbiAke2FyZ3NbMF19ICR7bmFtZX0gdmFpaHRvZWh0b2EuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG9uIG9sdGF2YSAke2FyZ3NbMF19IHRhaSBhbGxlLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICdUaWVkb3N0b2phIGVpIHNhbGxpdGEuJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0dWxlZSBvbGxhICR7YXJnc1swXX0tdGllZG9zdG90eXlwcGnDpC5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYFZhbGl0c2UgdsOkaGludMOkw6RuICR7YXJnc1swXX0gJHtuYW1lfSB2YWlodG9laHRvYS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gdHVsZWUgb2xsYSAke2FyZ3NbMF19IHRhaSBzdXVyZW1waS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbm90fVxuICAgICAqL1xuICAgIG5vdCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gKGFuZCB0aHVzIGRpc2FsbG93ZWQgYnkpIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYOKAnCR7dmFsdWV94oCdIGVpIG9sZSBzYWxsaXR0dSAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYEtlbnTDpG4gJHtzZW50ZW5jZShuYW1lKX0gdHVsZWUgb2xsYSBudW1lcm8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gdmFhZGl0YWFuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gb24gYWxldHRhdmEgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYSB1cmxcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3VybH1cbiAgICAgKi9cbiAgICB1cmwoKSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHVybC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBTecO2dMOkIHZhbGlkaSB1cmwtb3NvaXRlLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIGZpID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkaixcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJGpcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJGkgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICdBam91dGVyJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ1N1cHByaW1lcicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgdG8gcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiAnRW5sZXZlciB0b3V0JyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAnRMOpc29sw6ksIHRvdXMgbGVzIGNoYW1wcyBuZSBzb250IHBhcyByZW1wbGlzIGNvcnJlY3RlbWVudC4nLFxuICAgIC8qKlxuICAgICAqIFNob3duIGluIGEgYnV0dG9uIGluc2lkZSBhIGZvcm0gdG8gc3VibWl0IHRoZSBmb3JtLlxuICAgICAqL1xuICAgIHN1Ym1pdDogJ1ZhbGlkZXInLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gbm8gZmlsZXMgYXJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIG5vRmlsZXM6ICdBdWN1biBmaWNoaWVyIGNob2lzaScsXG59O1xuLyoqXG4gKiBUaGVzZSBhcmUgYWxsIHRoZSBwb3NzaWJsZSBzdHJpbmdzIHRoYXQgcGVydGFpbiB0byB2YWxpZGF0aW9uIG1lc3NhZ2VzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB2YWxpZGF0aW9uJGkgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbiBhY2NlcHRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FjY2VwdGVkfVxuICAgICAqL1xuICAgIGFjY2VwdGVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkICdhY2NlcHRlZCcgdmFsdWUuXCI+ICovXG4gICAgICAgIHJldHVybiBgVmV1aWxsZXogYWNjZXB0ZXIgbGUgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYWZ0ZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYWZ0ZXJ9XG4gICAgICovXG4gICAgZGF0ZV9hZnRlcih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRvaXQgw6p0cmUgcG9zdMOpcmlldXJlIGF1ICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRvaXQgw6p0cmUgZGFucyBsZSBmdXR1ci5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5lIHBldXQgY29udGVuaXIgcXVlIGRlcyBjYXJhY3TDqHJlcyBhbHBoYWLDqXRpcXVlcy5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFscGhhbnVtZXJpY1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGFudW1lcmljfVxuICAgICAqL1xuICAgIGFscGhhbnVtZXJpYyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmUgcGV1dCBjb250ZW5pciBxdWUgZGVzIGxldHRyZXMgZXQgZGVzIGNoaWZmcmVzLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgbGV0dGVyIGFuZC9vciBzcGFjZXNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhLXNwYWNlc31cbiAgICAgKi9cbiAgICBhbHBoYV9zcGFjZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBhbmQgbm9uLXNwYWNlIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmUgcGV1dmVudCBjb250ZW5pciBxdWUgZGVzIGxldHRyZXMgZXQgZGVzIGVzcGFjZXMuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGJlZm9yZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZWZvcmV9XG4gICAgICovXG4gICAgZGF0ZV9iZWZvcmUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZG9pdCDDqnRyZSBhbnTDqXJpZXVyZSBhdSAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZG9pdCDDqnRyZSBkYW5zIGxlIHBhc3PDqS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBDZSBjaGFtcCBhIMOpdMOpIGNvbmZpZ3Vyw6kgZGUgbWFuacOocmUgaW5jb3JyZWN0ZSBldCBuZSBwZXV0IHBhcyDDqnRyZSBzb3VtaXMuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZG9pdCDDqnRyZSBjb21wcmlzZSBlbnRyZSAke2F9IGV0ICR7Yn0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpcm1hdGlvbiBmaWVsZCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jY29uZmlybX1cbiAgICAgKi9cbiAgICBjb25maXJtKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgbWF0Y2hlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuZSBjb3JyZXNwb25kIHBhcy5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1mb3JtYXR9XG4gICAgICovXG4gICAgZGF0ZV9mb3JtYXQoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgZG9lcyBub3Qgc2F0aXNmeSB0aGUgZGF0ZSBmb3JtYXQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG4nZXN0IHBhcyB1bmUgZGF0ZSB2YWxpZGUsIHZldWlsbGV6IHV0aWxpc2VyIGxlIGZvcm1hdCAke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICdDZSBjaGFtcCBhIMOpdMOpIGNvbmZpZ3Vyw6kgZGUgbWFuacOocmUgaW5jb3JyZWN0ZSBldCBuZSBwZXV0IHBhcyDDqnRyZSBzb3VtaXMuJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRvaXQgw6p0cmUgY29tcHJpc2UgZW50cmUgJHtkYXRlKGFyZ3NbMF0pfSBldCAke2RhdGUoYXJnc1sxXSl9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICdWZXVpbGxleiBzYWlzaXIgdW5lIGFkcmVzc2UgZW1haWwgdmFsaWRlLicsXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZW5kIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW5kcy13aXRofVxuICAgICAqL1xuICAgIGVuZHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5lIHNlIHRlcm1pbmUgcGFzIHBhciAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNpc31cbiAgICAgKi9cbiAgICBpcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbidlc3QgcGFzIHVuZSB2YWxldXIgYXV0b3Jpc8OpZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNsZW5ndGh9XG4gICAgICovXG4gICAgbGVuZ3RoKHsgbmFtZSwgYXJnczogW2ZpcnN0ID0gMCwgc2Vjb25kID0gSW5maW5pdHldIH0pIHtcbiAgICAgICAgY29uc3QgbWluID0gTnVtYmVyKGZpcnN0KSA8PSBOdW1iZXIoc2Vjb25kKSA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBOdW1iZXIoc2Vjb25kKSA+PSBOdW1iZXIoZmlyc3QpID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgICAgIGlmIChtaW4gPT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkb2l0IGNvbXBvcnRlciBhdSBtb2lucyB1biBjYXJhY3TDqHJlLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkb2l0IMOqdHJlIGluZsOpcmlldXIgb3Ugw6lnYWwgw6AgJHttYXh9IGNhcmFjdMOocmVzLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBzdXBwbGllZCB0byB0aGUgcnVsZSBhbmQgdGhlcmUgaXMgbm8gbWF4aW11bSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZG9pdCDDqnRyZSBzdXDDqXJpZXVyIG91IMOpZ2FsIMOgICR7bWlufSBjYXJhY3TDqHJlcy5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZG9pdCDDqnRyZSBjb21wcmlzZSBlbnRyZSAke21pbn0gZXQgJHttYXh9IGNhcmFjdMOocmVzLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuJ2VzdCBwYXMgdW5lIHZhbGV1ciBhdXRvcmlzw6llLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBOZSBwZXV0IHBhcyBhdm9pciBwbHVzIGRlICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZG9pdCDDqnRyZSBpbmbDqXJpZXVyIG91IMOpZ2FsIMOgICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChmaWVsZC1sZXZlbCkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWltZX1cbiAgICAgKi9cbiAgICBtaW1lKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZmlsZSBmb3JtYXRzIHdlcmUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gJ0F1Y3VuIGZvcm1hdCBkZSBmaWNoaWVyIG7igJllc3QgYXV0b3Jpc8OpJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkb2l0IMOqdHJlIGR1IHR5cGU6ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE5lIHBldXQgcGFzIGF2b2lyIG1vaW5zIGRlICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZG9pdCDDqnRyZSBhdSBtb2lucyBkZSAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9IH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byAoYW5kIHRodXMgZGlzYWxsb3dlZCBieSkgdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg4oCcJHt2YWx1ZX3igJ0gbidlc3QgcGFzIHVuICR7bmFtZX0gYXV0b3Jpc8OpLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRvaXQgw6p0cmUgdW4gbm9tYnJlLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZpZWxkLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jcmVxdWlyZWR9XG4gICAgICovXG4gICAgcmVxdWlyZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYSB2YWx1ZSB0byBhIHJlcXVpcmVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGVzdCByZXF1aXMuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuZSBjb21tZW5jZSBwYXMgcGFyICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBgVmV1aWxsZXogc2Fpc2lyIHVuZSB1cmwgdmFsaWRlLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIGZyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkaSxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJGlcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJGggPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhIGJ1dHRvbiB0byByZW1vdmUgaXRlbXMgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmU6ICdGZXJ3aWRlcicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgdG8gcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiAnRmVyd2lkZXIgYWxsZXMnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICdTb3JyeSwgbmV0IGFsbGUgZmppbGRlbiBiaW5uZSBrb3JyZWt0IHluZm9sbGUuJyxcbiAgICAvKipcbiAgICAgKiBTaG93biBpbiBhIGJ1dHRvbiBpbnNpZGUgYSBmb3JtIHRvIHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzdWJtaXQ6ICdGZXJzdGpvZXJlJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIG5vIGZpbGVzIGFyZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBub0ZpbGVzOiAnR2ppbiBiZXN0w6JuIGtlYXplbicsXG59O1xuLyoqXG4gKiBUaGVzZSBhcmUgYWxsIHRoZSBwb3NzaWJsZSBzdHJpbmdzIHRoYXQgcGVydGFpbiB0byB2YWxpZGF0aW9uIG1lc3NhZ2VzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB2YWxpZGF0aW9uJGggPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbiBhY2NlcHRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FjY2VwdGVkfVxuICAgICAqL1xuICAgIGFjY2VwdGVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkICdhY2NlcHRlZCcgdmFsdWUuXCI+ICovXG4gICAgICAgIHJldHVybiBgQWtzZXB0ZWFyamUgZGUgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYWZ0ZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYWZ0ZXJ9XG4gICAgICovXG4gICAgZGF0ZV9hZnRlcih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vYXQgbmVpICR7ZGF0ZShhcmdzWzBdKX0gd8OqemUuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vYXQgeW4gZGUgdGFrb21zdCBsaXp6ZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1laSBhbGxpbm5lIGFsZmFiZXR5c2tlIHRla2VucyBiZWZldHNqZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFscGhhbnVtZXJpY1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGFudW1lcmljfVxuICAgICAqL1xuICAgIGFscGhhbnVtZXJpYyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbWVpIGFsbGlubmUgbGV0dGVycyBlbiBzaWZlcnMgYmVmZXRzamUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGJlZm9yZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZWZvcmV9XG4gICAgICovXG4gICAgZGF0ZV9iZWZvcmUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9hdCBmb2FyICR7ZGF0ZShhcmdzWzBdKX0gZmFsbGUuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb2F0IHluIGl0IGZlcmxpbmUgd8OqemUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNiZXR3ZWVufVxuICAgICAqL1xuICAgIGJldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKGlzTmFOKGFyZ3NbMF0pIHx8IGlzTmFOKGFyZ3NbMV0pKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBzdXBwbGllZCB0byB0aGUgcnVsZSB3ZXJlIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgRGl0IGZqaWxkIGlzIGZlcmtlYXJkIGtvbmZpZ3VyZWFycmUgZW4ga2luIG5ldCBmZXJzdGpvZXJkIHd1cmRlLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2EsIGJdID0gb3JkZXIoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vYXQgdHVza2VuICR7YX0gZW4gJHtifSBsaXp6ZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGtvbXQgbmV0IG9lcmllbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1mb3JtYXR9XG4gICAgICovXG4gICAgZGF0ZV9mb3JtYXQoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgZG9lcyBub3Qgc2F0aXNmeSB0aGUgZGF0ZSBmb3JtYXQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGlzIGdqaW4gamlsZGlnZSBkYXR1bSwgYnLDu2sgZGUgbm90YWFzamUgJHthcmdzWzBdfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAnRGl0IGZqaWxkIGlzIGZlcmtlYXJkIGtvbmZpZ3VyZWFycmUgZW4ga2luIG5ldCBmZXJzdGpvZXJkIHd1cmRlJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vYXQgdHVza2VuICR7ZGF0ZShhcmdzWzBdKX0gZW4gJHtkYXRlKGFyZ3NbMV0pfSBsaXp6ZWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VtYWlsfVxuICAgICAqL1xuICAgIGVtYWlsOiAnRm9samUgaW4gamlsZGljaCBlLW1haWxhZHJlcyB5bi4nLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBlaW5pZ2V0IG5ldCBtZWkgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGlzIGdqaW4gdGFzdGllbmUgd2VhcmRlLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBsZW5ndGhcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2xlbmd0aH1cbiAgICAgKi9cbiAgICBsZW5ndGgoeyBuYW1lLCBhcmdzOiBbZmlyc3QgPSAwLCBzZWNvbmQgPSBJbmZpbml0eV0gfSkge1xuICAgICAgICBjb25zdCBtaW4gPSBOdW1iZXIoZmlyc3QpIDw9IE51bWJlcihzZWNvbmQpID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgICAgIGNvbnN0IG1heCA9IE51bWJlcihzZWNvbmQpID49IE51bWJlcihmaXJzdCkgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgaWYgKG1pbiA9PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vYXQgbWluaW1hYWwgaWVuIHRla2VuIHfDqnplLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb2F0IGx5dHNlciB3w6p6ZSBhcyBvZiBnZWx5ayB3w6p6ZSBvYW4gJHttYXh9IHRla2Vucy5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUgYW5kIHRoZXJlIGlzIG5vIG1heGltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vYXQgZ3J1dHRlciB3w6p6ZSBhcyBvZiBnZWx5ayB3w6p6ZSBvYW4gJHttaW59IHRla2Vucy5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9hdCB0dXNrZW4gZGUgJHttaW59IGVuICR7bWF4fSB0ZWtlbnMgYmVmZXRzamUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsdWUgaXMgbm90IGEgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21hdGNoZXN9XG4gICAgICovXG4gICAgbWF0Y2hlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHZhbHVlcyBvciBSZWdFeHAgcGF0dGVybnMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGlzIGdqaW4gdGFzdGllbmUgd2VhcmRlLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBNZWkgbmV0IG1lYXIgYXMgJHthcmdzWzBdfSAke25hbWV9IGhhd3dlLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb2F0IGx5dHNlciB3w6p6ZSBhcyBvZiBnZWx5ayB3w6p6ZSBvYW4gJHthcmdzWzBdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgKGZpZWxkLWxldmVsKSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbWltZSB0eXBlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW1lfVxuICAgICAqL1xuICAgIG1pbWUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBmaWxlIGZvcm1hdHMgd2VyZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiAnR2ppbiBiZXN0w6Juc25vdGFhc2plcyB0YXN0aWVuLic7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIG1pbWUgdHlwZSBvZiB1c2VyLXByb3ZpZGVkIGZpbGUgZG9lcyBub3QgbWF0Y2ggYW55IG1pbWUgdHlwZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9hdCBmYW4gaXQgdHlwZTogJHthcmdzWzBdfSB3w6p6ZWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGZ1bGZpbGwgbWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW59XG4gICAgICovXG4gICAgbWluKHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbiBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgTWVpIG5ldCBtaW5kZXIgYXMgJHthcmdzWzBdfSAke25hbWV9IGhhd3dlLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb2F0IG1pbmltYWFsICR7YXJnc1swXX0gd8OqemUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI25vdH1cbiAgICAgKi9cbiAgICBub3QoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0gfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIChhbmQgdGh1cyBkaXNhbGxvd2VkIGJ5KSB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCIgaXMgZ2ppbiB0YXN0aWVuZSAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vYXQgaW4gZ2V0YWwgd8OqemUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaXMgZmVycGxpY2h0LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gYmVnamludCBuZXQgbWVpICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBgRG9jaCBkZXIgaW4gamlsZGlnZSB1cmwgYnkuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgZnkgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSRoLFxuICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24kaFxufSk7XG5cbi8qKlxuICogSGVyZSB3ZSBjYW4gaW1wb3J0IGFkZGl0aW9uYWwgaGVscGVyIGZ1bmN0aW9ucyB0byBhc3Npc3QgaW4gZm9ybWF0dGluZyBvdXJcbiAqIGxhbmd1YWdlLiBGZWVsIGZyZWUgdG8gYWRkIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgdG8gbGlicy9mb3JtYXRzIGlmIGl0XG4gKiBhc3Npc3RzIGluIGNyZWF0aW5nIGdvb2QgdmFsaWRhdGlvbiBtZXNzYWdlcyBmb3IgeW91ciBsb2NhbGUuXG4gKi9cbi8qKlxuICogU3RhbmRhcmQgbGFuZ3VhZ2UgZm9yIGludGVyZmFjZSBmZWF0dXJlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdWkkZyA9IHtcbiAgICAvKipcbiAgICAgKiBTaG93biBvbiBidXR0b25zIGZvciBhZGRpbmcgbmV3IGl0ZW1zLlxuICAgICAqL1xuICAgIGFkZDogJ9eU15XXodejJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ9ee15fXpycsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhbGwgZmllbGRzIGFyZSBub3QgZmlsbGVkIG91dCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaW5jb21wbGV0ZTogJ9ep15nXnSDXnNeRLCDXnNeQINeb15wg15TXqdeT15XXqiDXntec15DXmdedINeb16jXkNeV15kuJyxcbiAgICAvKipcbiAgICAgKiBTaG93biBpbiBhIGJ1dHRvbiBpbnNpZGUgYSBmb3JtIHRvIHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzdWJtaXQ6ICfXqdec15cnLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiRnID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNeQ16DXkCDXkNep16gg15DXqiAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g15fXmdeZ15Eg15zXlNeZ15XXqiDXkNeX16jXmSAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDXl9eZ15nXkSDXnNeU15nXldeqINeR16LXqteZ15MuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIGxldHRlci5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhfVxuICAgICAqL1xuICAgIGFscGhhKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDXl9eZ15nXkSDXnNeU15vXmdecINeQ15XXqteZ15XXqiDXkNec16TXkdeqLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDXmdeb15XXnCDXnNeU15vXmdecINeo16cg157Xodek16jXmdedINeV15DXldeq15nXldeqLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgbGV0dGVyIGFuZC9vciBzcGFjZXNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhLXNwYWNlc31cbiAgICAgKi9cbiAgICBhbHBoYV9zcGFjZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBhbmQgbm9uLXNwYWNlIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g15nXm9eV15wg15zXlNeb15nXnCDXqNenINeQ15XXqteZ15XXqiDXldeo15XXldeX15nXnS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYmVmb3JlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJlZm9yZX1cbiAgICAgKi9cbiAgICBkYXRlX2JlZm9yZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDXl9eZ15nXkSDXnNeU15nXldeqINec16TXoNeZICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDXl9eZ15nXkSDXnNeU15nXldeqINeR16LXkdeoYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNiZXR3ZWVufVxuICAgICAqL1xuICAgIGJldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKGlzTmFOKGFyZ3NbMF0pIHx8IGlzTmFOKGFyZ3NbMV0pKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBzdXBwbGllZCB0byB0aGUgcnVsZSB3ZXJlIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBg16nXk9eUINeW15Qg15zXkCDXlNeV15LXk9eoINeb16jXkNeV15kg15XXnNeQINeZ15vXldecINec15TXmdep15zXly5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INeX15nXmdeRINec15TXmdeV16og15HXmdefICR7YXJnc1swXX0g15UtJHthcmdzWzFdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INec15Ag157XqteQ15nXnS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1mb3JtYXR9XG4gICAgICovXG4gICAgZGF0ZV9mb3JtYXQoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgZG9lcyBub3Qgc2F0aXNmeSB0aGUgZGF0ZSBmb3JtYXQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INeU15XXkCDXnNeQINeq15DXqNeZ15og16rXp9eZ158sINeQ16DXkCDXlNep16rXntepINeR16TXldeo157XmCAke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICfXqdeT15Qg15bXlCDXnNeQINeU15XXkteT16gg15vXqNeQ15XXmSDXldec15Ag15nXm9eV15wg15zXlNeZ16nXnNeXLic7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCB3aXRoaW4gZXhwZWN0ZWQgZGF0ZSByYW5nZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZXR3ZWVufVxuICAgICAqL1xuICAgIGRhdGVfYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGRhdGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDXl9eZ15nXkSDXnNeU15nXldeqINeR15nXnyAke2RhdGUoYXJnc1swXSl9INeVLSAke2RhdGUoYXJnc1sxXSl9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICfXkNeg15Ag15TXp9ec15Mg15DXmdee15nXmdecINeq16fXmdefLicsXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZW5kIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW5kcy13aXRofVxuICAgICAqL1xuICAgIGVuZHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INec15Ag157Xodeq15nXmdedINeRLSAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNpc31cbiAgICAgKi9cbiAgICBpcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g15TXldeQINec15Ag16LXqNeaINee15XXqNep15QuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IGZpcnN0IDw9IHNlY29uZCA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBzZWNvbmQgPj0gZmlyc3QgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgaWYgKG1pbiA9PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INeX15nXmdeRINec15TXmdeV16og15zXpNeX15XXqiDXqteVINeQ15fXky5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gPT0gMCAmJiBtYXgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGZpcnN0IGFyZ3VtZW50IHN1cHBsaWVkIHRvIHRoZSBydWxlIGlzIDAsIGFuZCB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsb25nZXIgdGhhbiB0aGUgbWF4ICh0aGUgMm5kIGFyZ3VtZW50KSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g15fXmdeZ15Eg15zXlNeZ15XXqiDXpNeX15XXqiDXkNeVINep15XXldeUINecLSAke21heH0g16rXldeV15nXnS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUgYW5kIHRoZXJlIGlzIG5vIG1heGltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INeX15nXmdeRINec15nXldeqINeS15PXldecINeQ15Ug16nXldeV15Qg15wtICR7bWlufSDXqteV15XXmdedLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBiZXR3ZWVuIHRoZSB0d28gbGVuZ3RocyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDXl9eZ15nXkSDXnNeU15nXldeqINeR15nXnyAke21pbn0g15UtICR7bWF4fSDXqteV15XXmdedLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDXlNeV15Ag15zXkCDXoteo15og16rXp9eZ158uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21heH1cbiAgICAgKi9cbiAgICBtYXgoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX0g15zXkCDXmdeb15XXnCDXnNeU15nXldeqINei150g15nXldeq16gg154tICR7YXJnc1swXX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INeX15nXmdeRINec15TXmdeV16og16TXl9eV16og15DXlSDXqdeV15XXlCDXnC0gJHthcmdzWzBdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgKGZpZWxkLWxldmVsKSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbWltZSB0eXBlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW1lfVxuICAgICAqL1xuICAgIG1pbWUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBmaWxlIGZvcm1hdHMgd2VyZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiAn16TXldeo157XmCDXlNen15XXkdelINec15Ag157Xldeo16nXlC4nO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBtaW1lIHR5cGUgb2YgdXNlci1wcm92aWRlZCBmaWxlIGRvZXMgbm90IG1hdGNoIGFueSBtaW1lIHR5cGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INeX15nXmdeRINec15TXmdeV16og157XodeV15I6ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX0g15zXkCDXmdeb15XXnCDXnNeU15nXldeqINei150g16TXl9eV16og154tICR7YXJnc1swXX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INeX15nXmdeRINec15TXmdeV16og15zXpNeX15XXqiAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9IH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byAoYW5kIHRodXMgZGlzYWxsb3dlZCBieSkgdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg4oCcJHt2YWx1ZX3igJ0g15zXkCDXnteq15DXmdedINecLSAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9INeX15nXmdeRINec15TXmdeV16og157Xodek16guYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g15TXmdeg15Ug15fXldeR15QuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDXnNeQINee16rXl9eZ15wg15EtICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBg15DXoNeQINeU16fXnNeTINen15nXqdeV16gg16rXp9eZ158uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgaGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSRnLFxuICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24kZ1xufSk7XG5cbi8qKlxuICogSGVyZSB3ZSBjYW4gaW1wb3J0IGFkZGl0aW9uYWwgaGVscGVyIGZ1bmN0aW9ucyB0byBhc3Npc3QgaW4gZm9ybWF0dGluZyBvdXJcbiAqIGxhbmd1YWdlLiBGZWVsIGZyZWUgdG8gYWRkIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgdG8gbGlicy9mb3JtYXRzIGlmIGl0XG4gKiBhc3Npc3RzIGluIGNyZWF0aW5nIGdvb2QgdmFsaWRhdGlvbiBtZXNzYWdlcyBmb3IgeW91ciBsb2NhbGUuXG4gKi9cbi8qKlxuICogU3RhbmRhcmQgbGFuZ3VhZ2UgZm9yIGludGVyZmFjZSBmZWF0dXJlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdWkkZiA9IHtcbiAgICAvKipcbiAgICAgKiBTaG93biBvbiBidXR0b25zIGZvciBhZGRpbmcgbmV3IGl0ZW1zLlxuICAgICAqL1xuICAgIGFkZDogJ0RvZGFqJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ1VrbG9uaScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhbGwgZmllbGRzIGFyZSBub3QgZmlsbGVkIG91dCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaW5jb21wbGV0ZTogJ1BvamVkaW5hIHBvbGphIG5pc3UgaXNwcmF2bm8gaXNwdW5qZW5hLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnUHJlZGFqJyxcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgdGhlIHBvc3NpYmxlIHN0cmluZ3MgdGhhdCBwZXJ0YWluIHRvIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHZhbGlkYXRpb24kZiA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQb3RyZWJubyBqZSBwb3R2cmRpdGkgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYWZ0ZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYWZ0ZXJ9XG4gICAgICovXG4gICAgZGF0ZV9hZnRlcih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgYml0aSB1IHBlcmlvZHUgcG9zbGlqZSAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb3JhIGJpdGkgdSBidWR1xIdub3N0aS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgc2FkcsW+YXZhdGkgc2FtbyBzbG92YS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFscGhhbnVtZXJpY1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGFudW1lcmljfVxuICAgICAqL1xuICAgIGFscGhhbnVtZXJpYyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9yYSBzYWRyxb5hdmF0aSBzbG92YSBpIGJyb2pldmUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb2d1IHNhZHLFvmF2YXRpIHNhbW8gc2xvdmEgaSByYXptYWtlLi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYmVmb3JlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJlZm9yZX1cbiAgICAgKi9cbiAgICBkYXRlX2JlZm9yZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb3JhIGJpdGkgcHJpamUgJHtkYXRlKGFyZ3NbMF0pfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgYml0aSB1IHByb8WhbG9zdGkuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNiZXR3ZWVufVxuICAgICAqL1xuICAgIGJldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKGlzTmFOKGFyZ3NbMF0pIHx8IGlzTmFOKGFyZ3NbMV0pKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBzdXBwbGllZCB0byB0aGUgcnVsZSB3ZXJlIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgRm9ybWF0IHNhZHLFvmFqYSBuaWplIGlzcHJhdmFuIGkgbmUgbW/FvmUgYml0aSBwcmVkYW4uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb3JhIGJpdGkgaXptZcSRdSAke2FyZ3NbMF19IGkgJHthcmdzWzFdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5lIG9kZ292YXJhIHphZGFub2ogdnJpamVkbm9zdGkuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGRhdGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtZm9ybWF0fVxuICAgICAqL1xuICAgIGRhdGVfZm9ybWF0KHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGRvZXMgbm90IHNhdGlzZnkgdGhlIGRhdGUgZm9ybWF0IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuaWplIGlzcHJhdmFuIGZvcm1hdCBkYXR1bWEuIE1vbGltbyBrb3Jpc3RpdGUgc2xqZWRlxIdpIGZvcm1hdDogJHthcmdzWzBdfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAnT3ZvIHBvbGplIG5pamUgaXNwcmF2bm8gcG9zdGF2bGplbm8gaSBuZSBtb8W+ZSBiaXRpIHByZWRhbm8uJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgYml0aSB2cmlqZWRub3N0IGl6bWXEkXUgJHtkYXRlKGFyZ3NbMF0pfSBpICR7ZGF0ZShhcmdzWzFdKX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbWFpbH1cbiAgICAgKi9cbiAgICBlbWFpbDogJ01vbGltbyB1cGnFoWl0ZSBpc3ByYXZudSBlbWFpbCBhZHJlc3UuJyxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbmRzLXdpdGh9XG4gICAgICovXG4gICAgZW5kc193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVuZCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmUgemF2csWhYXZhIHMgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5pamUgZG9wdcWhdGVuYSB2cmlqZWRub3N0LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBsZW5ndGhcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2xlbmd0aH1cbiAgICAgKi9cbiAgICBsZW5ndGgoeyBuYW1lLCBhcmdzOiBbZmlyc3QgPSAwLCBzZWNvbmQgPSBJbmZpbml0eV0gfSkge1xuICAgICAgICBjb25zdCBtaW4gPSBmaXJzdCA8PSBzZWNvbmQgPyBmaXJzdCA6IHNlY29uZDtcbiAgICAgICAgY29uc3QgbWF4ID0gc2Vjb25kID49IGZpcnN0ID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgICAgIGlmIChtaW4gPT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb3JhIHNhZHLFvmF2YXRpIGJhcmVtIGplZGFuIHpuYWsuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgaW1hdGkgJHttYXh9IGlsaSBtYW5qZSB6bmFrb3ZhLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBzdXBwbGllZCB0byB0aGUgcnVsZSBhbmQgdGhlcmUgaXMgbm8gbWF4aW11bSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9yYSBpbWF0aSBiYXJlbSAke21pbn0gem5ha292YS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgQnJvaiB6bmFrb3ZhIHphIHBvbGplICR7c2VudGVuY2UobmFtZSl9IG1vcmEgYml0aSBpem1lxJF1ICR7bWlufSBpICR7bWF4fS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBpcyBub3QgYSBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF0Y2hlc31cbiAgICAgKi9cbiAgICBtYXRjaGVzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgdmFsdWVzIG9yIFJlZ0V4cCBwYXR0ZXJucyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmlqZSBkb3p2b2xqZW5hIHZyaWplZG5vc3QuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21heH1cbiAgICAgKi9cbiAgICBtYXgoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE5lIHNtaWplIGltYXRpIHZpxaFlIG9kICR7YXJnc1swXX0gJHtuYW1lfSBwb2xqYS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9yYSBpbWF0aSB2cmlqZWRub3N0IG1hbmp1IGlsaSBqZWRuYWt1ICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChmaWVsZC1sZXZlbCkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWltZX1cbiAgICAgKi9cbiAgICBtaW1lKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZmlsZSBmb3JtYXRzIHdlcmUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gJ0Zvcm1hdCBkYXRvdGVrZSBuaWplIGRvenZvbGplbi4nO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBtaW1lIHR5cGUgb2YgdXNlci1wcm92aWRlZCBmaWxlIGRvZXMgbm90IG1hdGNoIGFueSBtaW1lIHR5cGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYEZvcm1hdCBkYXRvdGVrZSBuYSBwb2xqdSAke3NlbnRlbmNlKG5hbWUpfSBtb3JhIG9kZ292YXJhdGk6ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYEJyb2ogdXBpc2FuaWggdnJpamVkbm9zdGkgbmEgcG9sanUgJHtuYW1lfSBtb3JhIGJpdGkgYmFyZW0gJHthcmdzWzBdfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9yYSBiaXRpIGJhcmVtICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI25vdH1cbiAgICAgKi9cbiAgICBub3QoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0gfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIChhbmQgdGh1cyBkaXNhbGxvd2VkIGJ5KSB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDigJwke3ZhbHVlfeKAnSBuaWplIGRvenZvbGplbmEgdnJpamVkbm9zdCBuYSBwb2xqdSAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgYml0aSBicm9qLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZpZWxkLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jcmVxdWlyZWR9XG4gICAgICovXG4gICAgcmVxdWlyZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYSB2YWx1ZSB0byBhIHJlcXVpcmVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGplIG9iYXZlem5vLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmUgcG/EjWluamUgcyAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhIHVybFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jdXJsfVxuICAgICAqL1xuICAgIHVybCgpIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgdXJsLlwiPiAqL1xuICAgICAgICByZXR1cm4gYE1vbGltbyB1bmVzaXRlIGlzcHJhdm51IHBvdmV6bmljdS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbn07XG5cbnZhciBociA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdWk6IHVpJGYsXG4gICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbiRmXG59KTtcblxuLyoqXG4gKiBIZXJlIHdlIGNhbiBpbXBvcnQgYWRkaXRpb25hbCBoZWxwZXIgZnVuY3Rpb25zIHRvIGFzc2lzdCBpbiBmb3JtYXR0aW5nIG91clxuICogbGFuZ3VhZ2UuIEZlZWwgZnJlZSB0byBhZGQgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyB0byBsaWJzL2Zvcm1hdHMgaWYgaXRcbiAqIGFzc2lzdHMgaW4gY3JlYXRpbmcgZ29vZCB2YWxpZGF0aW9uIG1lc3NhZ2VzIGZvciB5b3VyIGxvY2FsZS5cbiAqL1xuLyoqXG4gKiBTdGFuZGFyZCBsYW5ndWFnZSBmb3IgaW50ZXJmYWNlIGZlYXR1cmVzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB1aSRlID0ge1xuICAgIC8qKlxuICAgICAqIFNob3duIG9uIGJ1dHRvbnMgZm9yIGFkZGluZyBuZXcgaXRlbXMuXG4gICAgICovXG4gICAgYWRkOiAnVGFtYmFoJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ0hhcHVzJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyB0byByZW1vdmUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6ICdIYXB1cyBzZW11YScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhbGwgZmllbGRzIGFyZSBub3QgZmlsbGVkIG91dCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaW5jb21wbGV0ZTogJ01hYWYsIHRpZGFrIHNlbXVhIGJpZGFuZyBmb3JtdWxpciB0ZXJpc2kgZGVuZ2FuIGJlbmFyJyxcbiAgICAvKipcbiAgICAgKiBTaG93biBpbiBhIGJ1dHRvbiBpbnNpZGUgYSBmb3JtIHRvIHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzdWJtaXQ6ICdLaXJpbScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ1RpZGFrIGFkYSBmaWxlIHlhbmcgZGlwaWxpaCcsXG59O1xuLyoqXG4gKiBUaGVzZSBhcmUgYWxsIHRoZSBwb3NzaWJsZSBzdHJpbmdzIHRoYXQgcGVydGFpbiB0byB2YWxpZGF0aW9uIG1lc3NhZ2VzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB2YWxpZGF0aW9uJGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbiBhY2NlcHRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FjY2VwdGVkfVxuICAgICAqL1xuICAgIGFjY2VwdGVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkICdhY2NlcHRlZCcgdmFsdWUuXCI+ICovXG4gICAgICAgIHJldHVybiBgVG9sb25nIHRlcmltYSBrb2xvbSAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmlsYWlueWEgaGFydXMgbGViaWggZGFyaSB3YWt0dSAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBoYXJ1cyBiZXJpc2kgd2FrdHUgZGkgbWFzYSBkZXBhbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGhhbnlhIGJpc2EgZGlpc2kgaHVydWYgYWxmYWJldC5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFscGhhbnVtZXJpY1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGFudW1lcmljfVxuICAgICAqL1xuICAgIGFscGhhbnVtZXJpYyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaGFueWEgYmlzYSBkaWlzaSBodXJ1ZiBkYW4gYW5na2EuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBoYW55YSBib2xlaCBiZXJpc2kgaHVydWYgZGFuIHNwYXNpLi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYmVmb3JlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJlZm9yZX1cbiAgICAgKi9cbiAgICBkYXRlX2JlZm9yZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuaWxhaW55YSBoYXJ1cyBrdXJhbmcgZGFyaSB3YWt0dSAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaGFydXMgYmVyaXNpIHdha3R1IHlhbmcgc3VkYWggbGFtcGF1LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYEtvbG9tIGluaSB0aWRhayBkaWlzaSBkZW5nYW4gYmVuYXIgc2VoaW5nZ2EgdGlkYWsgYmlzYSBkaWtpcmltYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaGFydXMgYmVybmlsYWkgZGlhbnRhcmEgJHthfSBkYW4gJHtifS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5pbGFpbnlhIHRpZGFrIGNvY29rLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gd2FrdHUgdGlkYWsgY29jb2ssIG1vaG9uIGd1bmFrYW4gZm9ybWF0IHdha3R1ICR7YXJnc1swXX1gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGRhdGUgYXJndW1lbnQgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gJ0tvbG9tIGluaSB0aWRhayBkaWlzaSBkZW5nYW4gYmVuYXIgc2VoaW5nZ2EgdGlkYWsgYmlzYSBkaWtpcmltJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGhhcnVzIGRpYW50YXJhIHdha3R1ICR7ZGF0ZShhcmdzWzBdKX0gZGFuIHdha3R1ICR7ZGF0ZShhcmdzWzFdKX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbWFpbH1cbiAgICAgKi9cbiAgICBlbWFpbDogJ1RvbG9uZyB0dWxpcyBhbGFtYXQgZW1haWwgeWFuZyBiZW5hci4nLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuaWxhaW55YSB0aWRhayBiZXJha2hpcmFuIGRlbmdhbiAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNpc31cbiAgICAgKi9cbiAgICBpcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gYWRhbGFoIG5pbGFpIHlhbmcgdGlkYWsgZGlpemlua2FuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBsZW5ndGhcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2xlbmd0aH1cbiAgICAgKi9cbiAgICBsZW5ndGgoeyBuYW1lLCBhcmdzOiBbZmlyc3QgPSAwLCBzZWNvbmQgPSBJbmZpbml0eV0gfSkge1xuICAgICAgICBjb25zdCBtaW4gPSBOdW1iZXIoZmlyc3QpIDw9IE51bWJlcihzZWNvbmQpID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgICAgIGNvbnN0IG1heCA9IE51bWJlcihzZWNvbmQpID49IE51bWJlcihmaXJzdCkgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgaWYgKG1pbiA9PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5pbGFpbnlhIHNldGlkYWtueWEgYmVyaXNpIHNhdHUga2FyYWt0ZXIuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGp1bWxhaCBrYXJha3Rlcm55YSBoYXJ1cyBrdXJhbmcgZGFyaSBhdGF1IHNhbWEgZGVuZ2FuICR7bWF4fSBrYXJha3Rlci5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUgYW5kIHRoZXJlIGlzIG5vIG1heGltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGp1bWxhaCBrYXJha3Rlcm55YSBoYXJ1cyBsZWJpaCBkYXJpIGF0YXUgc2FtYSBkZW5nYW4gJHttaW59IGthcmFrdGVyLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBiZXR3ZWVuIHRoZSB0d28gbGVuZ3RocyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBqdW1sYWgga2FyYWt0ZXJueWEgaGFueWEgYmlzYSBhbnRhcmEgJHttaW59IGRhbiAke21heH0ga2FyYWt0ZXIuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsdWUgaXMgbm90IGEgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21hdGNoZXN9XG4gICAgICovXG4gICAgbWF0Y2hlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHZhbHVlcyBvciBSZWdFeHAgcGF0dGVybnMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5pbGFpbnlhIHRpZGFrIGRpaXppbmthbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFeGNlZWRzIG1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF4fVxuICAgICAqL1xuICAgIG1heCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgVGlkYWsgYmlzYSBtZW1pbGlraSBsZWJpaCBkYXJpICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaGFydXMgbGViaWgga2VjaWwgYXRhdSBzYW1hIGRlbmdhbiAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICdGb3JtYXQgZmlsZSB0aWRhayBkaWl6aW5rYW4nO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBtaW1lIHR5cGUgb2YgdXNlci1wcm92aWRlZCBmaWxlIGRvZXMgbm90IG1hdGNoIGFueSBtaW1lIHR5cGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGhhbnlhIGJpc2EgYmVydGlwZTogJHthcmdzWzBdfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGZ1bGZpbGwgbWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW59XG4gICAgICovXG4gICAgbWluKHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbiBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgVGlkYWsgYm9sZWgga3VyYW5nIGRhcmkgJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBzZXRpZGFrbnlhIGhhcnVzIGJlcmlzaSAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9IH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byAoYW5kIHRodXMgZGlzYWxsb3dlZCBieSkgdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg4oCcJHt2YWx1ZX3igJ0gYWRhbGFoIG5pbGFpIHlhbmcgdGlkYWsgZGlwZXJib2xlaGthbiB1bnR1ayAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGhhcnVzIGJlcnVwYSBhbmdrYS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCBmaWVsZC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3JlcXVpcmVkfVxuICAgICAqL1xuICAgIHJlcXVpcmVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGEgdXNlciBkb2VzIG5vdCBwcm92aWRlIGEgdmFsdWUgdG8gYSByZXF1aXJlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBoYXJ1cyBkaWlzaS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBzdGFydCB3aXRoIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jc3RhcnRzLXdpdGh9XG4gICAgICovXG4gICAgc3RhcnRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHRpZGFrIGRpbXVsYWkgZGVuZ2FuICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBgTW9ob24gdHVsaXNrYW4gdXJsIHlhbmcgYmVuYXIuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgaWQgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSRlLFxuICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24kZVxufSk7XG5cbi8qKlxuICogSGVyZSB3ZSBjYW4gaW1wb3J0IGFkZGl0aW9uYWwgaGVscGVyIGZ1bmN0aW9ucyB0byBhc3Npc3QgaW4gZm9ybWF0dGluZyBvdXJcbiAqIGxhbmd1YWdlLiBGZWVsIGZyZWUgdG8gYWRkIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgdG8gbGlicy9mb3JtYXRzIGlmIGl0XG4gKiBhc3Npc3RzIGluIGNyZWF0aW5nIGdvb2QgdmFsaWRhdGlvbiBtZXNzYWdlcyBmb3IgeW91ciBsb2NhbGUuXG4gKi9cbi8qKlxuICogU3RhbmRhcmQgbGFuZ3VhZ2UgZm9yIGludGVyZmFjZSBmZWF0dXJlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdWkkZCA9IHtcbiAgICAvKipcbiAgICAgKiBTaG93biBvbiBidXR0b25zIGZvciBhZGRpbmcgbmV3IGl0ZW1zLlxuICAgICAqL1xuICAgIGFkZDogJ0luc2VyaXNjaScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhIGJ1dHRvbiB0byByZW1vdmUgaXRlbXMgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmU6ICdSaW11b3ZpJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyB0byByZW1vdmUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6ICdSaW11b3ZpIHR1dHRpJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAnQ2kgZGlzcGlhY2UsIG5vbiB0dXR0aSBpIGNhbXBpIHNvbm8gY29tcGlsYXRpIGNvcnJldHRhbWVudGUuJyxcbiAgICAvKipcbiAgICAgKiBTaG93biBpbiBhIGJ1dHRvbiBpbnNpZGUgYSBmb3JtIHRvIHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzdWJtaXQ6ICdJbnZpYScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ05lc3N1biBmaWxlIHNlbGV6aW9uYXRvJyxcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgdGhlIHBvc3NpYmxlIHN0cmluZ3MgdGhhdCBwZXJ0YWluIHRvIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHZhbGlkYXRpb24kZCA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBTaSBwcmVnYSBkaSBhY2NldHRhcmUgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYWZ0ZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYWZ0ZXJ9XG4gICAgICovXG4gICAgZGF0ZV9hZnRlcih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYGxhIGRhdGEgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBlc3NlcmUgc3VjY2Vzc2l2YSAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBsYSBkYXRhICR7c2VudGVuY2UobmFtZSl9IGRldmUgZXNzZXJlIG5lbCBmdXR1cm8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIGxldHRlci5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhfVxuICAgICAqL1xuICAgIGFscGhhKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBwdcOyIGNvbnRlbmVyZSBzb2xvIGNhcmF0dGVyaSBhbGZhbnVtZXJpY2kuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHB1w7IgY29udGVuZXJlIHNvbG8gbGV0dGVyZSBlIG51bWVyaS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGxldHRlciBhbmQvb3Igc3BhY2VzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYS1zcGFjZXN9XG4gICAgICovXG4gICAgYWxwaGFfc3BhY2VzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgYW5kIG5vbi1zcGFjZSBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHB1w7IgY29udGVuZXJlIHNvbG8gbGV0dGVyZSBlIHNwYXppLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYGxhIGRhdGEgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBlc3NlcmUgYW50ZWNlZGVudGUgJHtkYXRlKGFyZ3NbMF0pfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRldmUgZXNzZXJlIG5lbCBwYXNzYXRvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYFF1ZXN0byBjYW1wbyDDqCBzdGF0byBjb25maWd1cmF0byBtYWxlIGUgbm9uIHB1w7IgZXNzZXJlIGludmlhdG8uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBlc3NlcmUgdHJhICR7YX0gZSAke2J9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjb25maXJtYXRpb24gZmllbGQgZG9lcyBub3QgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2NvbmZpcm19XG4gICAgICovXG4gICAgY29uZmlybSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlcXVhbCB0aGUgdmFsdWUgb2YgdGhlIG1hdGNoZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbm9uIGNvcnJpc3BvbmRlLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbm9uIMOoIHVuYSBkYXRhIHZhbGlkYSwgcGVyIGZhdm9yZSB1c2EgaWwgZm9ybWF0byAke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICdRdWVzdG8gY2FtcG8gw6ggc3RhdG8gY29uZmlndXJhdG8gaW4gbW9kbyBlcnJhdG8gZSBub24gcHXDsiBlc3NlcmUgaW52aWF0by4nO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3Qgd2l0aGluIGV4cGVjdGVkIGRhdGUgcmFuZ2VcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBkYXRlX2JldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBlc3NlcmUgdHJhICR7ZGF0ZShhcmdzWzBdKX0gZSAke2RhdGUoYXJnc1sxXSl9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICdQZXIgZmF2b3JlIGluc2VyaXJlIHVuIGluZGlyaXp6byBlbWFpbCB2YWxpZG8uJyxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbmRzLXdpdGh9XG4gICAgICovXG4gICAgZW5kc193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVuZCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbm9uIHRlcm1pbmEgY29uICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2lzfVxuICAgICAqL1xuICAgIGlzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBub24gw6ggdW4gdmFsb3JlIGNvbnNlbnRpdG8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IE51bWJlcihmaXJzdCkgPD0gTnVtYmVyKHNlY29uZCkgPyBmaXJzdCA6IHNlY29uZDtcbiAgICAgICAgY29uc3QgbWF4ID0gTnVtYmVyKHNlY29uZCkgPj0gTnVtYmVyKGZpcnN0KSA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICBpZiAobWluID09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYXQgbGVhc3Qgb25lIGNoYXJhY3Rlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBjb250ZW5lcmUgYWxtZW5vIHVuIGNhcmF0dGVyZS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gPT0gMCAmJiBtYXgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGZpcnN0IGFyZ3VtZW50IHN1cHBsaWVkIHRvIHRoZSBydWxlIGlzIDAsIGFuZCB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsb25nZXIgdGhhbiB0aGUgbWF4ICh0aGUgMm5kIGFyZ3VtZW50KSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBlc3NlcmUgbWlub3JlIG8gdWd1YWxlIGEgJHttYXh9IGNhcmF0dGVyaS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUgYW5kIHRoZXJlIGlzIG5vIG1heGltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRldmUgZXNzZXJlIG1hZ2dpb3JlIG8gdWd1YWxlIGEgJHttaW59IGNhcmF0dGVyaS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBlc3NlcmUgdHJhICR7bWlufSBlICR7bWF4fSBjYXJhdHRlcmkuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsdWUgaXMgbm90IGEgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21hdGNoZXN9XG4gICAgICovXG4gICAgbWF0Y2hlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHZhbHVlcyBvciBSZWdFeHAgcGF0dGVybnMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5vbiDDqCB1biB2YWxvcmUgY29uc2VudGl0by5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFeGNlZWRzIG1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF4fVxuICAgICAqL1xuICAgIG1heCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgTm9uIHB1w7IgYXZlcmUgcGnDuSBkaSAke2FyZ3NbMF19ICR7bmFtZX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRldmUgZXNzZXJlIG1pbm9yZSBvIHVndWFsZSBhICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChmaWVsZC1sZXZlbCkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWltZX1cbiAgICAgKi9cbiAgICBtaW1lKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZmlsZSBmb3JtYXRzIHdlcmUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gJ0Zvcm1hdG8gZmlsZSBub24gY29uc2VudGl0by4nO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBtaW1lIHR5cGUgb2YgdXNlci1wcm92aWRlZCBmaWxlIGRvZXMgbm90IG1hdGNoIGFueSBtaW1lIHR5cGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRldmUgZXNzZXJlIGRpIHRpcG86ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE5vbiBwdcOyIGF2ZXJlIG1lbm8gZGkgJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZXZlIGVzc2VyZSBhbG1lbm8gJHthcmdzWzBdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbm90fVxuICAgICAqL1xuICAgIG5vdCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gKGFuZCB0aHVzIGRpc2FsbG93ZWQgYnkpIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFwiJHt2YWx1ZX1cIiBub24gw6ggdW4gJHtuYW1lfSBjb25zZW50aXRvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRldmUgZXNzZXJlIHVuIG51bWVyby5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCBmaWVsZC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3JlcXVpcmVkfVxuICAgICAqL1xuICAgIHJlcXVpcmVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGEgdXNlciBkb2VzIG5vdCBwcm92aWRlIGEgdmFsdWUgdG8gYSByZXF1aXJlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDDqCByaWNoaWVzdG8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBub24gaW5pemlhIGNvbiAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhIHVybFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jdXJsfVxuICAgICAqL1xuICAgIHVybCgpIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgdXJsLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFBlciBmYXZvcmUgdXRpbGl6YXJlIHVuIHVybCB2YWxpZG8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgaXQgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSRkLFxuICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24kZFxufSk7XG5cbi8qKlxuICogSGVyZSB3ZSBjYW4gaW1wb3J0IGFkZGl0aW9uYWwgaGVscGVyIGZ1bmN0aW9ucyB0byBhc3Npc3QgaW4gZm9ybWF0dGluZyBvdXJcbiAqIGxhbmd1YWdlLiBGZWVsIGZyZWUgdG8gYWRkIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgdG8gbGlicy9mb3JtYXRzIGlmIGl0XG4gKiBhc3Npc3RzIGluIGNyZWF0aW5nIGdvb2QgdmFsaWRhdGlvbiBtZXNzYWdlcyBmb3IgeW91ciBsb2NhbGUuXG4gKi9cbi8qKlxuICogU3RhbmRhcmQgbGFuZ3VhZ2UgZm9yIGludGVyZmFjZSBmZWF0dXJlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdWkkYyA9IHtcbiAgICAvKipcbiAgICAgKiBTaG93biBvbiBidXR0b25zIGZvciBhZGRpbmcgbmV3IGl0ZW1zLlxuICAgICAqL1xuICAgIGFkZDogJ+i/veWKoCcsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhIGJ1dHRvbiB0byByZW1vdmUgaXRlbXMgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmU6ICfliYrpmaQnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHRvIHJlbW92ZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbDogJ+WFqOOBpuWJiumZpCcsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhbGwgZmllbGRzIGFyZSBub3QgZmlsbGVkIG91dCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaW5jb21wbGV0ZTogJ+mgheebruOBjOato+OBl+OBj+WFpeWKm+OBleOCjOOBpuOBhOOBvuOBm+OCk+OAgicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAn6YCB5L+hJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIG5vIGZpbGVzIGFyZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBub0ZpbGVzOiAn44OV44Kh44Kk44Or44GM6YG45oqe44GV44KM44Gm44GE44G+44Gb44KTJyxcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgdGhlIHBvc3NpYmxlIHN0cmluZ3MgdGhhdCBwZXJ0YWluIHRvIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHZhbGlkYXRpb24kYyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke25hbWV944Gu5ZCM5oSP44GM5b+F6KaB44Gn44GZ44CCYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGFmdGVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWFmdGVyfVxuICAgICAqL1xuICAgIGRhdGVfYWZ0ZXIoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeOBryR7ZGF0ZShhcmdzWzBdKX3jgojjgorlvozjga7ml6Xku5jjgafjgYLjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJgO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga/lsIbmnaXjga7ml6Xku5jjgafjgarjgZHjgozjgbDjgarjgorjgb7jgZvjgpPjgIJgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl944Gr44Gv6Iux5a2X44Gu44G/44KS5ZCr44KB44KL44GT44Go44GM44Gn44GN44G+44GZ44CCYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl944Gr44Gv44CB5paH5a2X44Go5pWw5a2X44Gu44G/44KS5ZCr44KB44KL44GT44Go44GM44Gn44GN44G+44GZ44CCYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeOBq+OBr+OAgeaWh+Wtl+OBqOOCueODmuODvOOCueOBruOBv+OCkuWQq+OCgeOCi+OBk+OBqOOBjOOBp+OBjeOBvuOBmeOAgmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl944GvJHtkYXRlKGFyZ3NbMF0pfeOCiOOCiuWJjeOBruaXpeS7mOOBp+OBguOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAgmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga/pgY7ljrvjga7ml6Xku5jjgafjgYLjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGDjgZPjga7jg5XjgqPjg7zjg6vjg4njga/mraPjgZfjgY/mp4vmiJDjgZXjgozjgabjgYTjgarjgYTjgZ/jgoHjgIHpgIHkv6HjgafjgY3jgb7jgZvjgpPjgIJgO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthLCBiXSA9IG9yZGVyKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeOBryR7YX3jgagke2J944Gu6ZaT44Gr44GC44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpcm1hdGlvbiBmaWVsZCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jY29uZmlybX1cbiAgICAgKi9cbiAgICBjb25maXJtKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgbWF0Y2hlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeOBjOS4gOiHtOOBl+OBvuOBm+OCk+OAgmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga/mnInlirnjgarml6Xku5jjgafjga/jgYLjgorjgb7jgZvjgpPjgIIke2FyZ3NbMF1944Gu5b2i5byP44KS5L2/55So44GX44Gm44GP44Gg44GV44GE44CCYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICfjgZPjga7jg5XjgqPjg7zjg6vjg4njga/mraPjgZfjgY/mp4vmiJDjgZXjgozjgabjgYrjgonjgZrjgIHpgIHkv6HjgafjgY3jgb7jgZvjgpPjgIInO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3Qgd2l0aGluIGV4cGVjdGVkIGRhdGUgcmFuZ2VcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBkYXRlX2JldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga8ke2RhdGUoYXJnc1swXSl944GoJHtkYXRlKGFyZ3NbMV0pfeOBrumWk+OBq+OBguOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAgmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VtYWlsfVxuICAgICAqL1xuICAgIGVtYWlsOiAn5pyJ5Yq544Gq44Oh44O844Or44Ki44OJ44Os44K544KS5YWl5Yqb44GX44Gm44GP44Gg44GV44GE44CCJyxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbmRzLXdpdGh9XG4gICAgICovXG4gICAgZW5kc193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVuZCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga8ke2xpc3QoYXJncyl944Gn57WC44KP44Gj44Gm44GE44G+44Gb44KT44CCYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2lzfVxuICAgICAqL1xuICAgIGlzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeOBr+ioseWPr+OBleOCjOOBn+WApOOBp+OBr+OBguOCiuOBvuOBm+OCk+OAgmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBsZW5ndGhcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2xlbmd0aH1cbiAgICAgKi9cbiAgICBsZW5ndGgoeyBuYW1lLCBhcmdzOiBbZmlyc3QgPSAwLCBzZWNvbmQgPSBJbmZpbml0eV0gfSkge1xuICAgICAgICBjb25zdCBtaW4gPSBOdW1iZXIoZmlyc3QpIDw9IE51bWJlcihzZWNvbmQpID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgICAgIGNvbnN0IG1heCA9IE51bWJlcihzZWNvbmQpID49IE51bWJlcihmaXJzdCkgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgaWYgKG1pbiA9PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl944Gv5bCR44Gq44GP44Go44KCMeaWh+Wtl+OBp+OBguOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAgmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeOBryR7bWF4feaWh+Wtl+S7peS4i+OBp+OBguOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAgmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBzdXBwbGllZCB0byB0aGUgcnVsZSBhbmQgdGhlcmUgaXMgbm8gbWF4aW11bSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga8ke21pbn3mloflrZfku6XkuIrjgafjgYLjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJgO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga8ke21pbn3jgYvjgokke21heH3mloflrZfjga7plpPjgafjgarjgZHjgozjgbDjgarjgorjgb7jgZvjgpPjgIJgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBpcyBub3QgYSBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF0Y2hlc31cbiAgICAgKi9cbiAgICBtYXRjaGVzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgdmFsdWVzIG9yIFJlZ0V4cCBwYXR0ZXJucyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga/oqLHlj6/jgZXjgozjgZ/lgKTjgafjga/jgYLjgorjgb7jgZvjgpPjgIJgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFeGNlZWRzIG1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF4fVxuICAgICAqL1xuICAgIG1heCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfeOBryR7YXJnc1swXX3jgpLotoXjgYjjgovjgZPjgajjga/jgafjgY3jgb7jgZvjgpPjgIJgO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga8ke2FyZ3NbMF195Lul5LiL44Gn44GC44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChmaWVsZC1sZXZlbCkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWltZX1cbiAgICAgKi9cbiAgICBtaW1lKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZmlsZSBmb3JtYXRzIHdlcmUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gJ+ODleOCoeOCpOODq+W9ouW8j+OBr+ioseWPr+OBleOCjOOBpuOBhOOBvuOBm+OCk+OAgic7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIG1pbWUgdHlwZSBvZiB1c2VyLXByb3ZpZGVkIGZpbGUgZG9lcyBub3QgbWF0Y2ggYW55IG1pbWUgdHlwZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga8ke2FyZ3NbMF1944Gn44GC44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZnVsZmlsbCBtaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbn1cbiAgICAgKi9cbiAgICBtaW4oeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke25hbWV944GvJHthcmdzWzBdfeacqua6gOOBq+OBmeOCi+OBk+OBqOOBr+OBp+OBjeOBvuOBm+OCk+OAgmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeOBr+WwkeOBquOBj+OBqOOCgiR7YXJnc1swXX3jgafjgYLjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbm90fVxuICAgICAqL1xuICAgIG5vdCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gKGFuZCB0aHVzIGRpc2FsbG93ZWQgYnkpIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYOKAnCR7dmFsdWV94oCd44Gv6Kix5Y+v44GV44KM44GfJHtuYW1lfeOBp+OBr+OBguOCiuOBvuOBm+OCk+OAgmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl944Gv5pWw5YCk44Gn44Gq44GR44KM44Gw44Gq44KK44G+44Gb44KT44CCYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3jga/lv4XpoIjjgafjgZnjgIJgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBzdGFydCB3aXRoIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jc3RhcnRzLXdpdGh9XG4gICAgICovXG4gICAgc3RhcnRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl944GvJHtsaXN0KGFyZ3MpfeOBp+Wni+OBvuOBo+OBpuOBhOOBvuOBm+OCk+OAgmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhIHVybFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jdXJsfVxuICAgICAqL1xuICAgIHVybCgpIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgdXJsLlwiPiAqL1xuICAgICAgICByZXR1cm4gYOacieWKueOBqlVSTOOCkuWQq+OCgeOBpuOBj+OBoOOBleOBhOOAgmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIGphID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkYyxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJGNcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJGIgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICfstpTqsIAnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYSBidXR0b24gdG8gcmVtb3ZlIGl0ZW1zIGlzIHZpc2libGUuXG4gICAgICovXG4gICAgcmVtb3ZlOiAn7KCc6rGwJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyB0byByZW1vdmUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6ICfrqqjrkZAg7KCc6rGwJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAn66qo65OgIOqwkuydhCDssYTsm4zso7zshLjsmpQnLFxuICAgIC8qKlxuICAgICAqIFNob3duIGluIGEgYnV0dG9uIGluc2lkZSBhIGZvcm0gdG8gc3VibWl0IHRoZSBmb3JtLlxuICAgICAqL1xuICAgIHN1Ym1pdDogJ+ygnOy2nO2VmOq4sCcsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ+yEoO2DneuQnCDtjIzsnbzsnbQg7JeG7Iq164uI64ukJyxcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgdGhlIHBvc3NpYmxlIHN0cmluZ3MgdGhhdCBwZXJ0YWluIHRvIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHZhbGlkYXRpb24kYiA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke25hbWV9IOyYrOuwlOuluCDqsJLsnYQg7ISg7YOdIO2VtOyjvOyEuOyalGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gJHtkYXRlKGFyZ3NbMF0pfSDsnbTtm4Tsl6zslbwg7ZWp64uI64ukYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOuvuOuemOydmCDrgqDsp5zsl6zslbztlanri4jri6RgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOyVjO2MjOuysyDrrLjsnpDrp4wg7Y+s7ZWo7ZWgIOyImCDsnojsirXri4jri6RgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFscGhhbnVtZXJpY1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGFudW1lcmljfVxuICAgICAqL1xuICAgIGFscGhhbnVtZXJpYyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g66y47J6Q7JmAIOyIq+yekOunjCDtj6ztlajrkKAg7IiYIOyeiOyKteuLiOuLpGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgbGV0dGVyIGFuZC9vciBzcGFjZXNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhLXNwYWNlc31cbiAgICAgKi9cbiAgICBhbHBoYV9zcGFjZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBhbmQgbm9uLXNwYWNlIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g66y47J6Q7JmAIOqzteuwseunjCDtj6ztlajtlaAg7IiYIOyeiOyKteuLiOuLpC5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYmVmb3JlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJlZm9yZX1cbiAgICAgKi9cbiAgICBkYXRlX2JlZm9yZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSAke2RhdGUoYXJnc1swXSl9IOydtOyghOyXrOyVvCDtlanri4jri6RgO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOqzvOqxsOydmCDrgqDsp5zsl6zslbztlanri4jri6RgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGDsnpjrqrvrkJwg6rWs7ISx7Jy866GcIOygnOy2nO2VoCDsiJgg7JeG7Iq164uI64ukYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gJHthfeyZgCAke2J9IOyCrOydtOyXrOyVvCDtlanri4jri6RgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOydvOy5mO2VmOyngCDslYrsirXri4jri6RgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1mb3JtYXR9XG4gICAgICovXG4gICAgZGF0ZV9mb3JtYXQoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgZG9lcyBub3Qgc2F0aXNmeSB0aGUgZGF0ZSBmb3JtYXQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOycoO2aqO2VnCDrgqDsp5zqsIAg7JWE64uZ64uI64ukLiAke2FyZ3NbMF196rO8IOqwmeydgCDtmJXsi53snYQg7IKs7Jqp7ZW07KO87IS47JqUYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICfsnpjrqrvrkJwg6rWs7ISx7Jy866GcIOygnOy2nO2VoCDsiJgg7JeG7Iq164uI64ukJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9ICR7ZGF0ZShhcmdzWzBdKX3sl5DshJwgJHtkYXRlKGFyZ3NbMV0pfSDsgqzsnbTsl6zslbwg7ZWp64uI64ukYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICfsmKzrsJTrpbgg7J2066mU7J28IOyjvOyGjOulvCDsnoXroKXtlbTso7zshLjsmpQnLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSAke2xpc3QoYXJncyl966GcIOuBneuCmOyngCDslYrsirXri4jri6RgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IO2XiOyaqeuQmOuKlCDqsJLsnbQg7JWE64uZ64uI64ukYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IE51bWJlcihmaXJzdCkgPD0gTnVtYmVyKHNlY29uZCkgPyBmaXJzdCA6IHNlY29uZDtcbiAgICAgICAgY29uc3QgbWF4ID0gTnVtYmVyKHNlY29uZCkgPj0gTnVtYmVyKGZpcnN0KSA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICBpZiAobWluID09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYXQgbGVhc3Qgb25lIGNoYXJhY3Rlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g7ZWY64KYIOydtOyDgeydmCDrrLjsnpDsl6zslbwg7ZWp64uI64ukYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9ICR7bWF4feyekCDsnbTtlZjsl6zslbwg7ZWp64uI64ukYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSAke21pbn0g66y47J6Q67O064ukIO2BrOqxsOuCmCDqsJnslYTslbwg7ZWp64uI64ukYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGJldHdlZW4gdGhlIHR3byBsZW5ndGhzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9ICR7bWlufeyXkOyEnCAke21heH3snpAg7IKs7J207Jes7JW8IO2VqeuLiOuLpGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDtl4jsmqnrkJjripQg6rCS7J20IOyVhOuLmeuLiOuLpGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke2FyZ3NbMF19ICR7bmFtZX0g7LSI6rO87ZWgIOyImCDsl4bsirXri4jri6RgO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gJHthcmdzWzBdfeuztOuLpCDsnpHqsbDrgpgg6rCZ7JWE7JW8IO2VqeuLiOuLpGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICftjIzsnbwg7ZiV7Iud7J20IO2XiOyaqeuQmOyngCDslYrsirXri4jri6QnO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBtaW1lIHR5cGUgb2YgdXNlci1wcm92aWRlZCBmaWxlIGRvZXMgbm90IG1hdGNoIGFueSBtaW1lIHR5cGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9ICR7YXJnc1swXX0g7Jyg7ZiV7J207Ja07JW8IO2VqeuLiOuLpGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGZ1bGZpbGwgbWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW59XG4gICAgICovXG4gICAgbWluKHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbiBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHthcmdzWzBdfSAke25hbWV967O064ukIOyekeydhCDsiJgg7JeG7Iq164uI64ukYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9ICR7YXJnc1swXX0g7J207IOB7J207Ja07JW8IO2VqeuLiOuLpGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9IH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byAoYW5kIHRodXMgZGlzYWxsb3dlZCBieSkgdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1cIiDtl4jsmqnrkJjsp4Ag7JWK64qUICR7bmFtZX3snoXri4jri6RgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgSXMgbm90IGEgbnVtYmVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDsiKvsnpDsl6zslbwg7ZWp64uI64ukYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g7ZWE7IiYIOqwkuyeheuLiOuLpGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gJHtsaXN0KGFyZ3MpfeuhnCDsi5zsnpHtlZjsp4Ag7JWK7Iq164uI64ukYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBg7Jis67CU66W4IFVSTOydhCDsnoXroKXtlbTso7zshLjsmpRgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbn07XG5cbnZhciBrbyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdWk6IHVpJGIsXG4gICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbiRiXG59KTtcblxuLyoqXG4gKiBIZXJlIHdlIGNhbiBpbXBvcnQgYWRkaXRpb25hbCBoZWxwZXIgZnVuY3Rpb25zIHRvIGFzc2lzdCBpbiBmb3JtYXR0aW5nIG91clxuICogbGFuZ3VhZ2UuIEZlZWwgZnJlZSB0byBhZGQgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyB0byBsaWJzL2Zvcm1hdHMgaWYgaXRcbiAqIGFzc2lzdHMgaW4gY3JlYXRpbmcgZ29vZCB2YWxpZGF0aW9uIG1lc3NhZ2VzIGZvciB5b3VyIGxvY2FsZS5cbiAqL1xuLyoqXG4gKiBTdGFuZGFyZCBsYW5ndWFnZSBmb3IgaW50ZXJmYWNlIGZlYXR1cmVzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB1aSRhID0ge1xuICAgIC8qKlxuICAgICAqIFNob3duIG9uIGJ1dHRvbnMgZm9yIGFkZGluZyBuZXcgaXRlbXMuXG4gICAgICovXG4gICAgYWRkOiAnVG9ldm9lZ2VuJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ1ZlcndpamRlcicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgdG8gcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiAnVmVyd2lqZGVyIGFsbGVzJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAnU29ycnksIG5pZXQgYWxsZSB2ZWxkZW4gemlqbiBjb3JyZWN0IGluZ2V2dWxkLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnVmVyc3R1cmVuJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIG5vIGZpbGVzIGFyZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBub0ZpbGVzOiAnR2VlbiBiZXN0YW5kIGdla296ZW4nLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiRhID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYEFjY2VwdGVlciBkZSAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9ldCBuYSAke2RhdGUoYXJnc1swXSl9IHppam4uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vZXQgaW4gZGUgdG9la29tc3QgbGlnZ2VuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSBsZXR0ZXIuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYX1cbiAgICAgKi9cbiAgICBhbHBoYSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbWFnIGFsbGVlbiBhbGZhYmV0aXNjaGUgdGVrZW5zIGJldmF0dGVuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtYWcgYWxsZWVuIGxldHRlcnMgZW4gY2lqZmVycyBiZXZhdHRlbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGxldHRlciBhbmQvb3Igc3BhY2VzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYS1zcGFjZXN9XG4gICAgICovXG4gICAgYWxwaGFfc3BhY2VzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgYW5kIG5vbi1zcGFjZSBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGt1bm5lbiBhbGxlZW4gbGV0dGVycyBlbiBzcGF0aWVzIGJldmF0dGVuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vZXQgdsOzw7NyICR7ZGF0ZShhcmdzWzBdKX0gdmFsbGVuLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9ldCBpbiBoZXQgdmVybGVkZW4gemlqbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBEaXQgdmVsZCBpcyBvbmp1aXN0IGdlY29uZmlndXJlZXJkIGVuIGthbiBuaWV0IHdvcmRlbiB2ZXJ6b25kZW4uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9ldCB0dXNzZW4gJHthfSBlbiAke2J9IGxpZ2dlbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGtvbXQgbmlldCBvdmVyZWVuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaXMgZ2VlbiBnZWxkaWdlIGRhdHVtLCBnZWJydWlrIGRlIG5vdGF0aWUgJHthcmdzWzBdfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAnRGl0IHZlbGQgaXMgb25qdWlzdCBnZWNvbmZpZ3VyZWVyZCBlbiBrYW4gbmlldCB3b3JkZW4gdmVyem9uZGVuJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vZXQgdHVzc2VuICR7ZGF0ZShhcmdzWzBdKX0gZW4gJHtkYXRlKGFyZ3NbMV0pfSBsaWdnZW5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbWFpbH1cbiAgICAgKi9cbiAgICBlbWFpbDogJ1Z1bCBlZW4gZ2VsZGlnIGUtbWFpbGFkcmVzIGluLicsXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZW5kIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW5kcy13aXRofVxuICAgICAqL1xuICAgIGVuZHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGVpbmRpZ3QgbmlldCBtZXQgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGlzIGdlZW4gdG9lZ2VzdGFuZSB3YWFyZGUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IE51bWJlcihmaXJzdCkgPD0gTnVtYmVyKHNlY29uZCkgPyBmaXJzdCA6IHNlY29uZDtcbiAgICAgICAgY29uc3QgbWF4ID0gTnVtYmVyKHNlY29uZCkgPj0gTnVtYmVyKGZpcnN0KSA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICBpZiAobWluID09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYXQgbGVhc3Qgb25lIGNoYXJhY3Rlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9ldCBtaW5pbWFhbCDDqcOpbiB0ZWtlbiB6aWpuLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb2V0IGtsZWluZXIgemlqbiBkYW4gb2YgZ2VsaWprIHppam4gYWFuICR7bWF4fSB0ZWtlbnMuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb2V0IGdyb3RlciB6aWpuIGRhbiBvZiBnZWxpamsgemlqbiBhYW4gJHttaW59IHRla2Vucy5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9ldCB0dXNzZW4gZGUgJHttaW59IGVuICR7bWF4fSB0ZWtlbnMgYmV2YXR0ZW4uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsdWUgaXMgbm90IGEgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21hdGNoZXN9XG4gICAgICovXG4gICAgbWF0Y2hlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHZhbHVlcyBvciBSZWdFeHAgcGF0dGVybnMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGlzIGdlZW4gdG9lZ2VzdGFuZSB3YWFyZGUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21heH1cbiAgICAgKi9cbiAgICBtYXgoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE1hZyBuaWV0IG1lZXIgZGFuICR7YXJnc1swXX0gJHtuYW1lfSBoZWJiZW4uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vZXQga2xlaW5lciB6aWpuIGRhbiBvZiBnZWxpamsgemlqbiBhYW4gJHthcmdzWzBdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgKGZpZWxkLWxldmVsKSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbWltZSB0eXBlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW1lfVxuICAgICAqL1xuICAgIG1pbWUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBmaWxlIGZvcm1hdHMgd2VyZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiAnR2VlbiBiZXN0YW5kc2Zvcm1hdGVuIHRvZWdlc3RhYW4uJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb2V0IHZhbiBoZXQgdHlwZTogJHthcmdzWzBdfSB6aWpuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZnVsZmlsbCBtaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbn1cbiAgICAgKi9cbiAgICBtaW4oeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBNYWcgbmlldCBtaW5kZXIgZGFuICR7YXJnc1swXX0gJHtuYW1lfSBoZWJiZW4uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vZXQgbWluaW1hYWwgJHthcmdzWzBdfSB6aWpuLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9IH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byAoYW5kIHRodXMgZGlzYWxsb3dlZCBieSkgdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiIGlzIGdlZW4gdG9lZ2VzdGFuZSAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vZXQgZWVuIGdldGFsIHppam4uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaXMgdmVycGxpY2h0LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gYmVnaW50IG5pZXQgbWV0ICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBgVm9lZyBlZW4gZ2VsZGlnZSB1cmwgdG9lLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIG5sID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkYSxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJGFcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJDkgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICdEb2RhaicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhIGJ1dHRvbiB0byByZW1vdmUgaXRlbXMgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmU6ICdVc3XFhCcsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgdG8gcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiAnVXN1xYQgd3N6eXN0a28nLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICdOaWUgd3N6eXN0a2llIHBvbGEgem9zdGHFgnkgd3lwZcWCbmlvbmUgcG9wcmF3bmllLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnV3nFm2xpaicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ05pZSB3eWJyYW5vIHBsaWt1Jyxcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgdGhlIHBvc3NpYmxlIHN0cmluZ3MgdGhhdCBwZXJ0YWluIHRvIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHZhbGlkYXRpb24kOSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQcm9zesSZIHphYWtjZXB0b3dhxIcgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYWZ0ZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYWZ0ZXJ9XG4gICAgICovXG4gICAgZGF0ZV9hZnRlcih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c2kgYnnEhyBwbyAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXNpIGJ5xIcgdyBwcnp5c3rFgm/Fm2NpLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSBsZXR0ZXIuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYX1cbiAgICAgKi9cbiAgICBhbHBoYSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgUG9sZSAke3NlbnRlbmNlKG5hbWUpfSBtb8W8ZSB6YXdpZXJhxIcgdHlsa28gem5ha2kgYWxmYWJldHljem5lLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQb2xlICR7c2VudGVuY2UobmFtZSl9IG1vxbxlIHphd2llcmHEhyB0eWxrbyB6bmFraSBhbGZhbnVtZXJ5Y3puZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGxldHRlciBhbmQvb3Igc3BhY2VzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYS1zcGFjZXN9XG4gICAgICovXG4gICAgYWxwaGFfc3BhY2VzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgYW5kIG5vbi1zcGFjZSBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFBvbGUgJHtzZW50ZW5jZShuYW1lKX0gbW9nxIUgemF3aWVyYcSHIHR5bGtvIGxpdGVyeSBpIHNwYWNqZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYmVmb3JlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJlZm9yZX1cbiAgICAgKi9cbiAgICBkYXRlX2JlZm9yZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXNpIGJ5xIcgcHJ6ZWQgJHtkYXRlKGFyZ3NbMF0pfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG11c2kgYnnEhyB3IHByemVzesWCb8WbY2kuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNiZXR3ZWVufVxuICAgICAqL1xuICAgIGJldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKGlzTmFOKGFyZ3NbMF0pIHx8IGlzTmFOKGFyZ3NbMV0pKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBzdXBwbGllZCB0byB0aGUgcnVsZSB3ZXJlIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgUG9sZSB6b3N0YcWCbyB3eXBlxYJuaW9uZSBuaWVwb3ByYXduaWUgaSBuaWUgbW/FvGUgem9zdGHEhyB3eXPFgmFuZS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthLCBiXSA9IG9yZGVyKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBXYXJ0b8WbxIcgcG9sYSAke3NlbnRlbmNlKG5hbWUpfSBtdXNpIGJ5xIcgcG9tacSZZHp5ICR7YX0gaSAke2J9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBjb25maXJtYXRpb24gZmllbGQgZG9lcyBub3QgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2NvbmZpcm19XG4gICAgICovXG4gICAgY29uZmlybSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlcXVhbCB0aGUgdmFsdWUgb2YgdGhlIG1hdGNoZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmllIHBva3J5d2Egc2nEmS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1mb3JtYXR9XG4gICAgICovXG4gICAgZGF0ZV9mb3JtYXQoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgZG9lcyBub3Qgc2F0aXNmeSB0aGUgZGF0ZSBmb3JtYXQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYFdhcnRvxZvEhyBwb2xhICR7c2VudGVuY2UobmFtZSl9IG5pZSBqZXN0IHBvcHJhd27EhSBkYXTEhSwgcHJvc3rEmSB1xbx5xIcgZm9ybWF0dSAke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICdUbyBwb2xlIHpvc3RhxYJvIHd5cGXFgm5pb25lIG5pZXBvcHJhd25pZSBpIG5pZSBtb8W8ZSB6b3N0YcSHIHd5c8WCYW5lJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYERhdGEgdyBwb2x1ICR7c2VudGVuY2UobmFtZSl9IG11c2kgYnnEhyBwb21pxJlkenkgJHtkYXRlKGFyZ3NbMF0pfSBpICR7ZGF0ZShhcmdzWzFdKX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbWFpbH1cbiAgICAgKi9cbiAgICBlbWFpbDogJ1Byb3N6xJkgd3Bpc2HEhyBwb3ByYXdueSBhZHJlcyBlbWFpbC4nLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQb2xlICR7c2VudGVuY2UobmFtZSl9IG5pZSBrb8WEY3p5IHNpxJkgbmEgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFBvbGUgJHtzZW50ZW5jZShuYW1lKX0gbmllIGplc3QgZG96d29sb27EhSB3YXJ0b8WbY2nEhS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNsZW5ndGh9XG4gICAgICovXG4gICAgbGVuZ3RoKHsgbmFtZSwgYXJnczogW2ZpcnN0ID0gMCwgc2Vjb25kID0gSW5maW5pdHldIH0pIHtcbiAgICAgICAgY29uc3QgbWluID0gTnVtYmVyKGZpcnN0KSA8PSBOdW1iZXIoc2Vjb25kKSA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBOdW1iZXIoc2Vjb25kKSA+PSBOdW1iZXIoZmlyc3QpID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgICAgIGlmIChtaW4gPT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBQb2xlICR7c2VudGVuY2UobmFtZSl9IG11c2kgcG9zaWFkYcSHIG1pbmltdW0gamVkZW4gem5hay5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gPT0gMCAmJiBtYXgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGZpcnN0IGFyZ3VtZW50IHN1cHBsaWVkIHRvIHRoZSBydWxlIGlzIDAsIGFuZCB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsb25nZXIgdGhhbiB0aGUgbWF4ICh0aGUgMm5kIGFyZ3VtZW50KSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgUG9sZSAke3NlbnRlbmNlKG5hbWUpfSBtdXNpIHphd2llcmHEhyAke21heH0gbHViIG1uaWVqIHpuYWvDs3cuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBQb2xlICR7c2VudGVuY2UobmFtZSl9IG11c2kgemF3aWVyYcSHICR7bWlufSBsdWIgd2nEmWNlaiB6bmFrw7N3LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBiZXR3ZWVuIHRoZSB0d28gbGVuZ3RocyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQb2xlICR7c2VudGVuY2UobmFtZSl9IG11c2kgbWllxIcgJHttaW59LSR7bWF4fSB6bmFrw7N3LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQb2xlICR7c2VudGVuY2UobmFtZSl9IHphd2llcmEgbmllZG96d29sb25lIHpuYWtpLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBOaWUgbW/FvG5hIG1pZcSHIHdpxJljZWogbmnFvCAke2FyZ3NbMF19ICR7bmFtZX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFdhcnRvxZvEhyBwb2xhICR7c2VudGVuY2UobmFtZSl9IG11c2kgYnnEhyBtbmllanN6YSBsdWIgcsOzd25hICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChmaWVsZC1sZXZlbCkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWltZX1cbiAgICAgKi9cbiAgICBtaW1lKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZmlsZSBmb3JtYXRzIHdlcmUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gJ05pZSBwb2Rhbm8gZG96d29sb255Y2ggdHlww7N3IHBsaWvDs3cuJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtdXNpIGJ5xIcgdHlwZW06ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE11c2lzeiBwb2RhxIcgd2nEmWNlaiBuacW8ICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgIE11c2lzeiBwb2RhxIcgY29uYWptbmllaiAke2FyZ3NbMF19ICR7c2VudGVuY2UobmFtZSl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gKGFuZCB0aHVzIGRpc2FsbG93ZWQgYnkpIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFdhcnRvxZvEhyBwb2xhICR7bmFtZX0gamVzdCBuaWVkb3p3b2xvbmEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogIElzIG5vdCBhIG51bWJlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlcih7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbXVzaSBiecSHIG51bWVyZW0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgUG9sZSAke3NlbnRlbmNlKG5hbWUpfSBqZXN0IHd5bWFnYW5lLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgV2FydG/Fm2MgcG9sYSAke3NlbnRlbmNlKG5hbWUpfSBuaWUgemFjenluYSBzacSZIG9kICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBgUHJvc3rEmSBwb2RhxIcgcHJhd2lkxYJvd3kgYWRyZXMgdXJsLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIHBsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkOSxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJDlcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJDggPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICdBZGljaW9uYXInLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYSBidXR0b24gdG8gcmVtb3ZlIGl0ZW1zIGlzIHZpc2libGUuXG4gICAgICovXG4gICAgcmVtb3ZlOiAnUmVtb3ZlcicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgdG8gcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiAnRGVsZXRhciB0dWRvJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAnRGVzY3VscGUsIG5lbSB0b2RvcyBvcyBjYW1wb3MgZm9yYW0gcHJlZW5jaGlkb3MgY29ycmV0YW1lbnRlLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnRW52aWFyJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIG5vIGZpbGVzIGFyZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBub0ZpbGVzOiAnTmVuaHVtIGFycXVpdm8nLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiQ4ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFBvciBmYXZvciBhY2VpdGUgbyAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBzZXIgcG9zdGVyaW9yIGEgJHtkYXRlKGFyZ3NbMF0pfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBzZXIgbm8gZnV0dXJvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSBsZXR0ZXIuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYX1cbiAgICAgKi9cbiAgICBhbHBoYSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gc8OzIHBvZGUgY29udGVyIGNhcmFjdGVyZXMgZG8gYWxmYWJldG8uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHPDsyBwb2RlIHRlciBsZXRyYXMgZSBuw7ptZXJvcy5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGxldHRlciBhbmQvb3Igc3BhY2VzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYS1zcGFjZXN9XG4gICAgICovXG4gICAgYWxwaGFfc3BhY2VzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgYW5kIG5vbi1zcGFjZSBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHPDsyBwb2RlbSBjb250ZXIgbGV0cmFzIGUgZXNwYcOnb3MuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGJlZm9yZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZWZvcmV9XG4gICAgICovXG4gICAgZGF0ZV9iZWZvcmUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBzZXIgYW50ZXJpb3IgYSAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBzZXIgYW50ZXJpb3IgYSBkYXRhIGF0dWFsLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE8gY2FtcG8gZm9pIGNvbmZpZ3VyYWRvIGluY29ycmV0YW1lbnRlIGUgbsOjbyBwb2RlIHNlciBlbnZpYWRvLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBlc3RhciBlbnRyZSAke2FyZ3NbMF19IGUgJHthcmdzWzFdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG7Do28gY29uZmVyZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1mb3JtYXR9XG4gICAgICovXG4gICAgZGF0ZV9mb3JtYXQoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgZG9lcyBub3Qgc2F0aXNmeSB0aGUgZGF0ZSBmb3JtYXQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG7Do28gw6kgdW1hIGRhdGEgdsOhbGlkYSwgcG9yIGZhdm9yIHVzZSBvIGZvcm1hdG8gJHthcmdzWzBdfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAnTyBjYW1wbyBmb2kgY29uZmlndXJhZG8gaW5jb3JyZXRhbWVudGUgZSBuw6NvIHBvZGUgc2VyIGVudmlhZG8uJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGRldmUgc2VyIGVudHJlICR7ZGF0ZShhcmdzWzBdKX0gZSAke2RhdGUoYXJnc1sxXSl9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICdQb3IgZmF2b3IgaW5mb3JtZSB1bSBlLW1haWwgdsOhbGlkby4nLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuw6NvIHRlcm1pbmEgY29tICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2lzfVxuICAgICAqL1xuICAgIGlzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuw6NvIMOpIHVtIHZhbG9yIHBlcm1pdGlkby5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNsZW5ndGh9XG4gICAgICovXG4gICAgbGVuZ3RoKHsgbmFtZSwgYXJnczogW2ZpcnN0ID0gMCwgc2Vjb25kID0gSW5maW5pdHldIH0pIHtcbiAgICAgICAgY29uc3QgbWluID0gZmlyc3QgPD0gc2Vjb25kID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgICAgIGNvbnN0IG1heCA9IHNlY29uZCA+PSBmaXJzdCA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICBpZiAobWluID09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYXQgbGVhc3Qgb25lIGNoYXJhY3Rlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSB0ZXIgYW8gbWVub3MgdW0gY2FyYWN0ZXJlLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuw6NvIHBvZGUgdGVyIG1haXMgcXVlICR7bWF4fSBjYXJhY3RlcmVzLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBzdXBwbGllZCB0byB0aGUgcnVsZSBhbmQgdGhlcmUgaXMgbm8gbWF4aW11bSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSB0ZXIgbm8gbcOtbmltbyAke21pbn0gY2FyYWN0ZXJlcy5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSB0ZXIgZW50cmUgJHttaW59IGUgJHttYXh9IGNhcmFjdGVyZXMuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsdWUgaXMgbm90IGEgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21hdGNoZXN9XG4gICAgICovXG4gICAgbWF0Y2hlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHZhbHVlcyBvciBSZWdFeHAgcGF0dGVybnMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG7Do28gw6kgdW0gdmFsb3IgcGVybWl0aWRvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBOw6NvIHBvZGUgdGVyIG1haXMgcXVlICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBzZXIgaWd1YWwgb3UgbWVub3IgcXVlICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChmaWVsZC1sZXZlbCkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWltZX1cbiAgICAgKi9cbiAgICBtaW1lKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZmlsZSBmb3JtYXRzIHdlcmUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gJ05lbmh1bSBmb3JtYXRvIGRlIGFycXVpdm8gcGVybWl0aWRvLic7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIG1pbWUgdHlwZSBvZiB1c2VyLXByb3ZpZGVkIGZpbGUgZG9lcyBub3QgbWF0Y2ggYW55IG1pbWUgdHlwZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZGV2ZSBzZXIgZG8gdGlwbzogJHthcmdzWzBdfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGZ1bGZpbGwgbWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW59XG4gICAgICovXG4gICAgbWluKHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbiBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgTsOjbyBwb2RlIHRlciBtZW5vcyBxdWUgJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZXZlIHRlciBwZWxvIG1lbm9zICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI25vdH1cbiAgICAgKi9cbiAgICBub3QoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0gfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIChhbmQgdGh1cyBkaXNhbGxvd2VkIGJ5KSB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDigJwke3ZhbHVlfeKAnSBuw6NvIHBlcm1pdGUgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgSXMgbm90IGEgbnVtYmVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBkZXZlIHNlciB1bSBuw7ptZXJvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZpZWxkLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jcmVxdWlyZWR9XG4gICAgICovXG4gICAgcmVxdWlyZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYSB2YWx1ZSB0byBhIHJlcXVpcmVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IMOpIG9icmlnYXTDs3Jpby5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBzdGFydCB3aXRoIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jc3RhcnRzLXdpdGh9XG4gICAgICovXG4gICAgc3RhcnRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG7Do28gY29tZcOnYSBjb20gJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYSB1cmxcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3VybH1cbiAgICAgKi9cbiAgICB1cmwoKSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHVybC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQb3IgZmF2b3IgaW5mb3JtZSB1bSB1cmwgdsOhbGlkby5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbn07XG5cbnZhciBwdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdWk6IHVpJDgsXG4gICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbiQ4XG59KTtcblxuLyoqXG4gKiBIZXJlIHdlIGNhbiBpbXBvcnQgYWRkaXRpb25hbCBoZWxwZXIgZnVuY3Rpb25zIHRvIGFzc2lzdCBpbiBmb3JtYXR0aW5nIG91clxuICogbGFuZ3VhZ2UuIEZlZWwgZnJlZSB0byBhZGQgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyB0byBsaWJzL2Zvcm1hdHMgaWYgaXRcbiAqIGFzc2lzdHMgaW4gY3JlYXRpbmcgZ29vZCB2YWxpZGF0aW9uIG1lc3NhZ2VzIGZvciB5b3VyIGxvY2FsZS5cbiAqL1xuLyoqXG4gKiBTdGFuZGFyZCBsYW5ndWFnZSBmb3IgaW50ZXJmYWNlIGZlYXR1cmVzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB1aSQ3ID0ge1xuICAgIC8qKlxuICAgICAqIFNob3duIG9uIGJ1dHRvbnMgZm9yIGFkZGluZyBuZXcgaXRlbXMuXG4gICAgICovXG4gICAgYWRkOiAnQWTEg3VnYXJlJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ0VsaW1pbsSDJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyB0byByZW1vdmUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6ICdFbGltaW7EgyB0b3QnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICdQYXJlIHLEg3UsIHVuZWxlIGPDom1wdXJpIG51IHN1bnQgY29yZWN0IGNvbXBsZXRhdGUuJyxcbiAgICAvKipcbiAgICAgKiBTaG93biBpbiBhIGJ1dHRvbiBpbnNpZGUgYSBmb3JtIHRvIHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzdWJtaXQ6ICdUcmltaXRlJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIG5vIGZpbGVzIGFyZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBub0ZpbGVzOiAnTnUgZXN0ZSBzZWxlY3RhdCBuaWNpIHVuIGZpyJlpZXInLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiQ3ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYFRlIHJvZyBhY2NlcHTEgyAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gdHJlYnVpZSBzxIMgZmllIGR1cMSDICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHRyZWJ1aWUgc2EgZmllIMOubiB2aWl0b3IuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIGxldHRlci5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhfVxuICAgICAqL1xuICAgIGFscGhhKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBwb2F0ZSBjb27Im2luZSBkb2FyIGNhcmFjdGVyZSBhbGFmZXRpY2UuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHBvYXRlIGNvbsibaW5lIGRvYXIgbGl0ZXJlIMiZaSBudW1lcmUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBwb2F0ZSBjb27Im2luZSBkb2FyIGxpdGVyZSDImWkgc3BhyJtpaS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYmVmb3JlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJlZm9yZX1cbiAgICAgKi9cbiAgICBkYXRlX2JlZm9yZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0cmVidWllIHPEgyBwcmVjZWFkxIMgJHtkYXRlKGFyZ3NbMF0pfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHRyZWJ1aWUgc8SDIGZpZSDDrm4gdHJlY3V0LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYEPDom1wdWwgYSBmb3N0IGNvbmZpZ3VyYXQgaW5jb3JlY3QgyJlpIG51IHBvYXRlIGZpIHRyaW1pcy5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthLCBiXSA9IG9yZGVyKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0cmVidWllIHPEgyBmaWUgw65udHJlICR7YX0gyJlpICR7Yn0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpcm1hdGlvbiBmaWVsZCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jY29uZmlybX1cbiAgICAgKi9cbiAgICBjb25maXJtKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgbWF0Y2hlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBudSBzZSBwb3RyaXZlyJl0ZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1mb3JtYXR9XG4gICAgICovXG4gICAgZGF0ZV9mb3JtYXQoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgZG9lcyBub3Qgc2F0aXNmeSB0aGUgZGF0ZSBmb3JtYXQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG51IGVzdGUgdmFsaWTEgywgdGUgcm9nIGZvbG/ImXRlIGZvcm1hdHVsICR7YXJnc1swXX1gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGRhdGUgYXJndW1lbnQgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gJ0PDom1wdWwgYSBmb3N0IGluY29yZWN0IGNvbmZpZ3VyYXQgyJlpIG51IHBvYXRlIGZpIHRyaW1pcy4nO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3Qgd2l0aGluIGV4cGVjdGVkIGRhdGUgcmFuZ2VcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBkYXRlX2JldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gdHJlYnVpZSBzxIMgZmllIMOubnRyZSAke2RhdGUoYXJnc1swXSl9IMiZaSAke2RhdGUoYXJnc1sxXSl9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICdUZSByb2cgZm9sb3NlyJl0ZSBvIGFkcmVzxIMgZGUgZW1haWwgdmFsaWTEgy4nLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBudSBzZSB0ZXJtaW7EgyBjdSAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNpc31cbiAgICAgKi9cbiAgICBpcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbnUgZXN0ZSBvIHZhbG9hcmUgYWNjZXB0YXTEgy5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNsZW5ndGh9XG4gICAgICovXG4gICAgbGVuZ3RoKHsgbmFtZSwgYXJnczogW2ZpcnN0ID0gMCwgc2Vjb25kID0gSW5maW5pdHldIH0pIHtcbiAgICAgICAgY29uc3QgbWluID0gTnVtYmVyKGZpcnN0KSA8PSBOdW1iZXIoc2Vjb25kKSA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBOdW1iZXIoc2Vjb25kKSA+PSBOdW1iZXIoZmlyc3QpID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgICAgIGlmIChtaW4gPT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0cmVidWllIHNhIGNvbsibaW7EgyBjZWwgcHXIm2luIHVuIGNhcmFjdGVyLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0cmVidWllIHNhIGFpYsSDIGNlbCBtdWx0ICR7bWF4fSBjYXJhY3RlcmUuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0cmVidWllIHPEgyBhaWLEgyBjZWwgcHXIm2luICR7bWlufSBjYXJhY3RlcmUuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGJldHdlZW4gdGhlIHR3byBsZW5ndGhzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHRyZWJ1aWUgc8SDIGFpYsSDIMOubnRyZSAke21pbn0gyJlpICR7bWF4fSBjYXJhY3RlcmUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsdWUgaXMgbm90IGEgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21hdGNoZXN9XG4gICAgICovXG4gICAgbWF0Y2hlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHZhbHVlcyBvciBSZWdFeHAgcGF0dGVybnMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG51IGVzdGUgbyB2YWxvYXJlIGFjY2VwdGF0xIMuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21heH1cbiAgICAgKi9cbiAgICBtYXgoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE51IHBvYXRlIGF2ZWEgbWFpIG11bHQgZGVjYXQgJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0cmVidWllIHPEgyBmaWUgY2VsIG11bHQgZWdhbCBjdSAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICdUaXB1bCBkZSBmaciZaWVyIG5lYWNjZXB0YXQuJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0cmVidWllIHPEgyBmaWUgZGUgdGlwdWw6ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE51IHBvYXRlIGF2ZWEgbWFpIHB1yJtpbiBkZWPDonQgJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB0cmVidWllIHPEgyBmaWUgY2VsIHB1yJtpbiAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9IH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byAoYW5kIHRodXMgZGlzYWxsb3dlZCBieSkgdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg4oCcJHt2YWx1ZX3igJ0gbnUgZXN0ZSBvIHZhbG9hcmUgYWNjZXB0xIMgcGVudHJ1ICR7bmFtZX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogIElzIG5vdCBhIG51bWJlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlcih7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gdHJlYnVpZSBzxIMgZmllIHVuIG51bcSDci5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCBmaWVsZC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3JlcXVpcmVkfVxuICAgICAqL1xuICAgIHJlcXVpcmVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGEgdXNlciBkb2VzIG5vdCBwcm92aWRlIGEgdmFsdWUgdG8gYSByZXF1aXJlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBlc3RlIG5lY2VzYXIuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBudSDDrm5jZXBlIGN1ICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBgVGUgcm9nIGluY2x1ZGUgbyBhZHJlc8SDIHdlYiB2YWxpZMSDYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgcm8gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSQ3LFxuICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24kN1xufSk7XG5cbi8qKlxuICogSGVyZSB3ZSBjYW4gaW1wb3J0IGFkZGl0aW9uYWwgaGVscGVyIGZ1bmN0aW9ucyB0byBhc3Npc3QgaW4gZm9ybWF0dGluZyBvdXJcbiAqIGxhbmd1YWdlLiBGZWVsIGZyZWUgdG8gYWRkIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgdG8gbGlicy9mb3JtYXRzIGlmIGl0XG4gKiBhc3Npc3RzIGluIGNyZWF0aW5nIGdvb2QgdmFsaWRhdGlvbiBtZXNzYWdlcyBmb3IgeW91ciBsb2NhbGUuXG4gKi9cbi8qKlxuICogU3RhbmRhcmQgbGFuZ3VhZ2UgZm9yIGludGVyZmFjZSBmZWF0dXJlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdWkkNiA9IHtcbiAgICAvKipcbiAgICAgKiBTaG93biBvbiBidXR0b25zIGZvciBhZGRpbmcgbmV3IGl0ZW1zLlxuICAgICAqL1xuICAgIGFkZDogJ9CU0L7QsdCw0LLQuNGC0YwnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYSBidXR0b24gdG8gcmVtb3ZlIGl0ZW1zIGlzIHZpc2libGUuXG4gICAgICovXG4gICAgcmVtb3ZlOiAn0KPQtNCw0LvQuNGC0YwnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHRvIHJlbW92ZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbDogJ9Cj0LHRgNCw0YLRjCDQstGB0LUnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICfQmNC30LLQuNC90LjRgtC1LCDQvdC1INCy0YHQtSDQv9C+0LvRjyDQt9Cw0L/QvtC70L3QtdC90Ysg0LLQtdGA0L3Qvi4nLFxuICAgIC8qKlxuICAgICAqIFNob3duIGluIGEgYnV0dG9uIGluc2lkZSBhIGZvcm0gdG8gc3VibWl0IHRoZSBmb3JtLlxuICAgICAqL1xuICAgIHN1Ym1pdDogJ9Ce0YLQv9GA0LDQstC40YLRjCcsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ9Ck0LDQudC7INC90LUg0LLRi9Cx0YDQsNC9Jyxcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgdGhlIHBvc3NpYmxlIHN0cmluZ3MgdGhhdCBwZXJ0YWluIHRvIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHZhbGlkYXRpb24kNiA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDQn9C+0LbQsNC70YPQudGB0YLQsCwg0L/RgNC40LzQuNGC0LUgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYWZ0ZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYWZ0ZXJ9XG4gICAgICovXG4gICAgZGF0ZV9hZnRlcih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYNCU0LDRgtCwICR7c2VudGVuY2UobmFtZSl9INC00L7Qu9C20L3QsCDQsdGL0YLRjCDQv9C+0LfQttC1ICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCU0LDRgtCwICR7c2VudGVuY2UobmFtZSl9INC00L7Qu9C20L3QsCDQsdGL0YLRjCDQsiDQsdGD0LTRg9GJ0LXQvC5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCf0L7Qu9C1ICR7c2VudGVuY2UobmFtZSl9INC80L7QttC10YIg0YHQvtC00LXRgNC20LDRgtGMINGC0L7Qu9GM0LrQviDQsdGD0LrQstGLLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDQn9C+0LvQtSAke3NlbnRlbmNlKG5hbWUpfSDQvNC+0LbQtdGCINGB0L7QtNC10YDQttCw0YLRjCDRgtC+0LvRjNC60L4g0LHRg9C60LLRiyDQuCDRhtC40YTRgNGLLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgbGV0dGVyIGFuZC9vciBzcGFjZXNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhLXNwYWNlc31cbiAgICAgKi9cbiAgICBhbHBoYV9zcGFjZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBhbmQgbm9uLXNwYWNlIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g0LzQvtCz0YPRgiDRgdC+0LTQtdGA0LbQsNGC0Ywg0YLQvtC70YzQutC+INCx0YPQutCy0Ysg0Lgg0L/RgNC+0LHQtdC70YsuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGJlZm9yZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZWZvcmV9XG4gICAgICovXG4gICAgZGF0ZV9iZWZvcmUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJlZm9yZSB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBg0JTQsNGC0LAgJHtzZW50ZW5jZShuYW1lKX0g0LTQvtC70LbQvdCwINCx0YvRgtGMINGA0LDQvdGM0YjQtSAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg0JTQsNGC0LAgJHtzZW50ZW5jZShuYW1lKX0g0LTQvtC70LbQvdCwINCx0YvRgtGMINCyINC/0YDQvtGI0LvQvtC8LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYNCt0YLQviDQv9C+0LvQtSDQt9Cw0L/QvtC70L3QtdC90L4g0L3QtdCy0LXRgNC90L4g0Lgg0L3QtSDQvNC+0LbQtdGCINCx0YvRgtGMINC+0YLQv9GA0LDQstC70LXQvdC+LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2EsIGJdID0gb3JkZXIoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCf0L7Qu9C1ICR7c2VudGVuY2UobmFtZSl9INC00L7Qu9C20L3QviDQsdGL0YLRjCDQvNC10LbQtNGDICR7YX0g0LggJHtifS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCf0L7Qu9C1ICR7c2VudGVuY2UobmFtZSl9INC90LUg0YHQvtCy0L/QsNC00LDQtdGCLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBg0J/QvtC70LUgJHtzZW50ZW5jZShuYW1lKX0g0LjQvNC10LXRgiDQvdC10LLQtdGA0L3Rg9GOINC00LDRgtGDLiDQn9C+0LbQsNC70YPQudGB0YLQsCwg0LjRgdC/0L7Qu9GM0LfRg9C50YLQtSDRhNC+0YDQvNCw0YIgJHthcmdzWzBdfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAn0K3RgtC+INC/0L7Qu9C1INC30LDQv9C+0LvQvdC10L3QviDQvdC10LLQtdGA0L3QviDQuCDQvdC1INC80L7QttC10YIg0LHRi9GC0Ywg0L7RgtC/0YDQsNCy0LvQtdC90L4uJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYNCU0LDRgtCwICR7c2VudGVuY2UobmFtZSl9INC00L7Qu9C20L3QsCDQsdGL0YLRjCDQvNC10LbQtNGDICR7ZGF0ZShhcmdzWzBdKX0g0LggJHtkYXRlKGFyZ3NbMV0pfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VtYWlsfVxuICAgICAqL1xuICAgIGVtYWlsOiAn0J/QvtC20LDQu9GD0LnRgdGC0LAsINCy0LLQtdC00LjRgtC1INC00LXQudGB0YLQstC40YLQtdC70YzQvdGL0Lkg0Y3Qu9C10LrRgtGA0L7QvdC90YvQuSDQsNC00YDQtdGBLicsXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZW5kIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW5kcy13aXRofVxuICAgICAqL1xuICAgIGVuZHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCf0L7Qu9C1ICR7c2VudGVuY2UobmFtZSl9INC90LUg0LTQvtC70LbQvdC+INC30LDQutCw0L3Rh9C40LLQsNGC0YzRgdGPINC90LAgJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCf0L7Qu9C1ICR7c2VudGVuY2UobmFtZSl9INC40LzQtdC10YIg0L3QtdC/0L7QtNGD0YHRgtC40LzQvtC1INC30L3QsNGH0LXQvdC40LUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IE51bWJlcihmaXJzdCkgPD0gTnVtYmVyKHNlY29uZCkgPyBmaXJzdCA6IHNlY29uZDtcbiAgICAgICAgY29uc3QgbWF4ID0gTnVtYmVyKHNlY29uZCkgPj0gTnVtYmVyKGZpcnN0KSA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICBpZiAobWluID09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYXQgbGVhc3Qgb25lIGNoYXJhY3Rlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBg0J/QvtC70LUgJHtzZW50ZW5jZShuYW1lKX0g0LTQvtC70LbQvdC+INGB0L7QtNC10YDQttCw0YLRjCDQvNC40L3QuNC80YPQvCDQvtC00LjQvSDRgdC40LzQstC+0LsuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYNCU0LvQuNC90LAg0L/QvtC70Y8gJHtzZW50ZW5jZShuYW1lKX0g0LTQvtC70LbQvdCwINCx0YvRgtGMINC80LXQvdGM0YjQtSDQuNC70Lgg0YDQsNCy0L3QsCAke21heH0g0YHQuNC80LLQvtC70LDQvC5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUgYW5kIHRoZXJlIGlzIG5vIG1heGltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYNCU0LvQuNC90LAg0L/QvtC70Y8gJHtzZW50ZW5jZShuYW1lKX0g0LTQvtC70LbQvdCwINCx0YvRgtGMINCx0L7Qu9GM0YjQtSDQuNC70Lgg0YDQsNCy0L3QsCAke21pbn0g0YHQuNC80LLQvtC70LDQvC5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg0JTQu9C40L3QsCDQv9C+0LvRjyAke3NlbnRlbmNlKG5hbWUpfSDQtNC+0LvQttC90LAg0LHRi9GC0Ywg0LzQtdC20LTRgyAke21pbn0g0LggJHttYXh9INGB0LjQvNCy0L7Qu9Cw0LzQuC5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBpcyBub3QgYSBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF0Y2hlc31cbiAgICAgKi9cbiAgICBtYXRjaGVzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgdmFsdWVzIG9yIFJlZ0V4cCBwYXR0ZXJucyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBg0J/QvtC70LUgJHtzZW50ZW5jZShuYW1lKX0g0LjQvNC10LXRgiDQvdC10LTQvtC/0YPRgdGC0LjQvNC+0LUg0LfQvdCw0YfQtdC90LjQtS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFeGNlZWRzIG1heGltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF4fVxuICAgICAqL1xuICAgIG1heCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBg0J3QtSDQvNC+0LbQtdGCINCx0YvRgtGMINCy0YvQsdGA0LDQvdC+INCx0L7Qu9GM0YjQtSwg0YfQtdC8ICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg0J/QvtC70LUgJHtzZW50ZW5jZShuYW1lKX0g0LTQvtC70LbQvdC+INCx0YvRgtGMINC80LXQvdGM0YjQtSDQuNC70Lgg0YDQsNCy0L3QviAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICfQndC1INGD0LrQsNC30LDQvdGLINC/0L7QtNC00LXRgNC20LjQsNCy0LXQvNGL0LUg0YTQvtGA0LzQsNGC0Ysg0YTQsNC50LvQsC4nO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBtaW1lIHR5cGUgb2YgdXNlci1wcm92aWRlZCBmaWxlIGRvZXMgbm90IG1hdGNoIGFueSBtaW1lIHR5cGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCk0L7RgNC80LDRgiDRhNCw0LnQu9CwINCyINC/0L7Qu9C1ICR7c2VudGVuY2UobmFtZSl9INC00L7Qu9C20LXQvSDQsdGL0YLRjDogJHthcmdzWzBdfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYNCd0LUg0LzQvtC20LXRgiDQsdGL0YLRjCDQstGL0LHRgNCw0L3QviDQvNC10L3RjNGI0LUsINGH0LXQvCAke2FyZ3NbMF19ICR7bmFtZX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCf0L7Qu9C1ICR7c2VudGVuY2UobmFtZSl9INC00L7Qu9C20L3QviDQsdGL0YLRjCDQvdC1INC80LXQvdC10LUsINGH0LXQvCAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9IH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byAoYW5kIHRodXMgZGlzYWxsb3dlZCBieSkgdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg4oCcJHt2YWx1ZX3igJ0g0L3QtSDQv9C+0LTQtNC10YDQttC40LLQsNC10YLRgdGPINCyINC/0L7Qu9C1ICR7bmFtZX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogIElzIG5vdCBhIG51bWJlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlcih7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgIHJldHVybiBg0J/QvtC70LUgJHtzZW50ZW5jZShuYW1lKX0g0LTQvtC70LbQvdC+INCx0YvRgtGMINGH0LjRgdC70L7QvC5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCBmaWVsZC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3JlcXVpcmVkfVxuICAgICAqL1xuICAgIHJlcXVpcmVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGEgdXNlciBkb2VzIG5vdCBwcm92aWRlIGEgdmFsdWUgdG8gYSByZXF1aXJlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDQn9C+0LvQtSAke3NlbnRlbmNlKG5hbWUpfSDQvtCx0Y/Qt9Cw0YLQtdC70YzQvdC+INC00LvRjyDQt9Cw0L/QvtC70L3QtdC90LjRjy5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBzdGFydCB3aXRoIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jc3RhcnRzLXdpdGh9XG4gICAgICovXG4gICAgc3RhcnRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCf0L7Qu9C1ICR7c2VudGVuY2UobmFtZSl9INC00L7Qu9C20L3QviDQvdCw0YfQuNC90LDRgtGM0YHRjyDRgSAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhIHVybFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jdXJsfVxuICAgICAqL1xuICAgIHVybCgpIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgdXJsLlwiPiAqL1xuICAgICAgICByZXR1cm4gYNCf0L7QttCw0LvRg9C50YHRgtCwLCDQstCy0LXQtNC40YLQtSDQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3Ri9C5IFVSTCDQsNC00YDQtdGBLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIHJ1ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkNixcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJDZcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJDUgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICdEb2RhaicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhIGJ1dHRvbiB0byByZW1vdmUgaXRlbXMgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmU6ICdPZHN0cmFuaScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgdG8gcmVtb3ZlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsOiAnT2RzdHJhbmkgdnNlJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAnTmVrYXRlcmEgcG9samEgbmlzbyBwcmF2aWxubyBpenBvbG5qZW5hLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnUG/FoWxqaScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ05vYmVuYSBkYXRvdGVrYSBuaSBpemJyYW5hJyxcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBhbGwgdGhlIHBvc3NpYmxlIHN0cmluZ3MgdGhhdCBwZXJ0YWluIHRvIHZhbGlkYXRpb24gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHZhbGlkYXRpb24kNSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBQcm9zaW1vIHBvcHJhdml0ZSAke25hbWV9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBhZnRlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1hZnRlcn1cbiAgICAgKi9cbiAgICBkYXRlX2FmdGVyKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0aGUgZGF0ZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9yYSBiaXRpIHBvICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgYml0aSB2IHByaWhvZG5vc3RpLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSBsZXR0ZXIuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYX1cbiAgICAgKi9cbiAgICBhbHBoYSh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbGFoa28gdnNlYnVqZSBzYW1vIHpuYWtlIGFiZWNlZGUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGxhaGtvIHZzZWJ1amUgc2FtbyDEjXJrZSBpbiDFoXRldmlsa2UuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBsYWhrbyB2c2VidWplIHNhbW8gxI1ya2UgaW4gcHJlc2xlZGtlLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgYml0aSBwcmVkICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb3JhIGJpdGkgdiBwcmV0ZWtsb3N0aS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBUbyBwb2xqZSBqZSBuYXJvYmUgbmFzdGF2bGplbm8gaW4gbmUgbW9yYSBiaXRpIGl6cG9sbmplbm8uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9yYSBiaXRpIG1lZCAke2F9IGluICR7Yn0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpcm1hdGlvbiBmaWVsZCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jY29uZmlybX1cbiAgICAgKi9cbiAgICBjb25maXJtKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgbWF0Y2hlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBzZSBuZSB1amVtYS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1mb3JtYXR9XG4gICAgICovXG4gICAgZGF0ZV9mb3JtYXQoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgZG9lcyBub3Qgc2F0aXNmeSB0aGUgZGF0ZSBmb3JtYXQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG5pIHByYXZpbGVuIGRhdHVtLCBwcm9zaW1vIHVwb3JhYml0ZSBmb3JtYXQgJHthcmdzWzBdfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZGF0ZSBhcmd1bWVudCB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiAnVG8gcG9samUgamUgbmFyb2JlIG5hc3RhdmxqZW5vIGluIG5lIG1vcmEgYml0aSBpenBvbG5qZW5vLic7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCB3aXRoaW4gZXhwZWN0ZWQgZGF0ZSByYW5nZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZXR3ZWVufVxuICAgICAqL1xuICAgIGRhdGVfYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGRhdGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb3JhIGJpdGkgbWVkICR7ZGF0ZShhcmdzWzBdKX0gaW4gJHtkYXRlKGFyZ3NbMV0pfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VtYWlsfVxuICAgICAqL1xuICAgIGVtYWlsOiAnVm5lc2l0ZSB2ZWxqYXZlbiBlLXBvxaF0bmkgbmFzbG92LicsXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZW5kIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW5kcy13aXRofVxuICAgICAqL1xuICAgIGVuZHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNlIG1vcmEga2/EjWF0aSB6ICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2lzfVxuICAgICAqL1xuICAgIGlzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBuaSBkb3ZvbGplbmEgdnJlZG5vc3QuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IE51bWJlcihmaXJzdCkgPD0gTnVtYmVyKHNlY29uZCkgPyBmaXJzdCA6IHNlY29uZDtcbiAgICAgICAgY29uc3QgbWF4ID0gTnVtYmVyKHNlY29uZCkgPj0gTnVtYmVyKGZpcnN0KSA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICBpZiAobWluID09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYXQgbGVhc3Qgb25lIGNoYXJhY3Rlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9yYSB2c2Vib3ZhdGkgdnNhaiBlbiB6bmFrLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb3JhIHZzZWJvdmF0aSBuYWp2ZcSNICR7bWF4fSB6bmFrb3YuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtb3JhIHZzZWJvdmF0aSB2c2FqICR7bWlufSB6bmFrb3YuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGJldHdlZW4gdGhlIHR3byBsZW5ndGhzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgdnNlYm92YXRpIG1lZCAke21pbn0gaW4gJHttYXh9IHpuYWtvdi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBpcyBub3QgYSBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF0Y2hlc31cbiAgICAgKi9cbiAgICBtYXRjaGVzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgdmFsdWVzIG9yIFJlZ0V4cCBwYXR0ZXJucyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbmkgZG92b2xqZW5hIHZyZWRub3N0LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGBOYWp2ZcSNIGplICR7YXJnc1swXX0gJHtuYW1lfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gamUgbGFoa28gbmFqdmXEjSAke2FyZ3NbMF19LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICdOb2JlbmEgdnJzdGEgZGF0b3Rla2UgbmkgZG92b2xqZW5hLic7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIG1pbWUgdHlwZSBvZiB1c2VyLXByb3ZpZGVkIGZpbGUgZG9lcyBub3QgbWF0Y2ggYW55IG1pbWUgdHlwZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9yYSBiaXRpIHRpcGE6ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYE5ham1hbmogJHthcmdzWzBdfSAke25hbWV9IGplIGRvdm9samVuaWguYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG1vcmEgYml0aSB2c2FqICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI25vdH1cbiAgICAgKi9cbiAgICBub3QoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0gfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIChhbmQgdGh1cyBkaXNhbGxvd2VkIGJ5KSB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDigJwke3ZhbHVlfeKAnSBuaSBkb3ZvbGplbihhL28pICR7bmFtZX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogIElzIG5vdCBhIG51bWJlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlcih7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbW9yYSBiaXRpIMWhdGV2aWxrYS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCBmaWVsZC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3JlcXVpcmVkfVxuICAgICAqL1xuICAgIHJlcXVpcmVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGEgdXNlciBkb2VzIG5vdCBwcm92aWRlIGEgdmFsdWUgdG8gYSByZXF1aXJlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBqZSB6YWh0ZXZhbihvL2EpLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gc2UgbW9yYSB6YcSNZXRpIHogJHtsaXN0KGFyZ3MpfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYSB1cmxcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3VybH1cbiAgICAgKi9cbiAgICB1cmwoKSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHVybC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBWbmVzaXRlIHZlbGphdm5vIHBvdmV6YXZvLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIHNsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkNSxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJDVcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJDQgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhIGJ1dHRvbiB0byByZW1vdmUgaXRlbXMgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmU6ICdUYSBib3J0JyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyB0byByZW1vdmUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6ICdUYSBib3J0IGFsbGEnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICdUeXbDpHJyIMOkciBpbnRlIGFsbGEgZsOkbHQga29ycmVrdCBpZnlsbGRhJyxcbiAgICAvKipcbiAgICAgKiBTaG93biBpbiBhIGJ1dHRvbiBpbnNpZGUgYSBmb3JtIHRvIHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzdWJtaXQ6ICdTa2lja2EnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gbm8gZmlsZXMgYXJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIG5vRmlsZXM6ICdJbmdlbiBmaWwgdmFsZCcsXG59O1xuLyoqXG4gKiBUaGVzZSBhcmUgYWxsIHRoZSBwb3NzaWJsZSBzdHJpbmdzIHRoYXQgcGVydGFpbiB0byB2YWxpZGF0aW9uIG1lc3NhZ2VzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB2YWxpZGF0aW9uJDQgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbiBhY2NlcHRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FjY2VwdGVkfVxuICAgICAqL1xuICAgIGFjY2VwdGVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkICdhY2NlcHRlZCcgdmFsdWUuXCI+ICovXG4gICAgICAgIHJldHVybiBgVmFyIGdvZCBhY2NlcHRlcmEgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYWZ0ZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYWZ0ZXJ9XG4gICAgICovXG4gICAgZGF0ZV9hZnRlcih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG3DpXN0ZSB2YXJhIGVmdGVyICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG3DpXN0ZSB2YXJhIGZyYW3DpXQgaSB0aWRlbi5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGthbiBlbmJhcnQgaW5uZWjDpWxsYSBib2tzdMOkdmVyIGkgYWxmYWJldGV0LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBrYW4gYmFyYSBpbm5laMOlbGxhIGJva3N0w6R2ZXIgb2NoIHNpZmZyb3IuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBrYW4gYmFyYSBpbm5laMOlbGxhIGJva3N0w6R2ZXIgb2NoIGJsYW5rc3RlZy5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBpcyBub3QgYmVmb3JlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJlZm9yZX1cbiAgICAgKi9cbiAgICBkYXRlX2JlZm9yZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtw6VzdGUgdmFyYSBmw7ZyZSAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbcOlc3RlIHZhcmEgYmFrw6V0IGkgdGlkZW4uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNiZXR3ZWVufVxuICAgICAqL1xuICAgIGJldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKGlzTmFOKGFyZ3NbMF0pIHx8IGlzTmFOKGFyZ3NbMV0pKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBzdXBwbGllZCB0byB0aGUgcnVsZSB3ZXJlIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgRGV0IGjDpHIgZsOkbHRldCBzdMOkbGxkZXMgaW50ZSBpbiBrb3JyZWt0IG9jaCBrYW4gaW50ZSBhbnbDpG5kYXMuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbcOlc3RlIHZhcmEgbWVsbGFuICR7YX0gb2NoICR7Yn0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpcm1hdGlvbiBmaWVsZCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jY29uZmlybX1cbiAgICAgKi9cbiAgICBjb25maXJtKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgbWF0Y2hlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtYXRjaGFyIGludGUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGRhdGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtZm9ybWF0fVxuICAgICAqL1xuICAgIGRhdGVfZm9ybWF0KHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGRvZXMgbm90IHNhdGlzZnkgdGhlIGRhdGUgZm9ybWF0IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDDpHIgaW50ZSBldHQgZ2lsdGlndCBkYXR1bSwgdmFyIGdvZCBhbnbDpG5kIGZvcm1hdGV0ICR7YXJnc1swXX1gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGRhdGUgYXJndW1lbnQgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gJ0RldCBow6RyIGbDpGx0ZXQgc3TDpGxsZGVzIGludGUgaW4ga29ycmVrdCBvY2gga2FuIGludGUgYW52w6RuZGFzJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG3DpXN0ZSB2YXJhIG1lbGxhbiAke2RhdGUoYXJnc1swXSl9IG9jaCAke2RhdGUoYXJnc1sxXSl9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICdWYXIgZ29kIGZ5bGwgaSBlbiBnaWx0aWcgZS1wb3N0YWRyZXNzLicsXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZW5kIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW5kcy13aXRofVxuICAgICAqL1xuICAgIGVuZHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNsdXRhciBpbnRlIG1lZCAke2xpc3QoYXJncyl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNpc31cbiAgICAgKi9cbiAgICBpcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gw6RyIGludGUgZXR0IGdvZGvDpG50IHbDpHJkZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbGVuZ3RoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNsZW5ndGh9XG4gICAgICovXG4gICAgbGVuZ3RoKHsgbmFtZSwgYXJnczogW2ZpcnN0ID0gMCwgc2Vjb25kID0gSW5maW5pdHldIH0pIHtcbiAgICAgICAgY29uc3QgbWluID0gTnVtYmVyKGZpcnN0KSA8PSBOdW1iZXIoc2Vjb25kKSA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBOdW1iZXIoc2Vjb25kKSA+PSBOdW1iZXIoZmlyc3QpID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgICAgIGlmIChtaW4gPT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtw6VzdGUgaGEgbWluc3QgZXR0IHRlY2tlbi5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gPT0gMCAmJiBtYXgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGZpcnN0IGFyZ3VtZW50IHN1cHBsaWVkIHRvIHRoZSBydWxlIGlzIDAsIGFuZCB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsb25nZXIgdGhhbiB0aGUgbWF4ICh0aGUgMm5kIGFyZ3VtZW50KSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gbcOlc3RlIHZhcmEgJHttYXh9IHRlY2tlbiBlbGxlciBmw6RycmUuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtw6VzdGUgdmFyYSAke21pbn0gdGVja2VuIGVsbGVyIGZsZXIuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGJldHdlZW4gdGhlIHR3byBsZW5ndGhzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG3DpXN0ZSB2YXJhIG1lbGxhbiAke21pbn0gb2NoICR7bWF4fSB0ZWNrZW4uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsdWUgaXMgbm90IGEgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21hdGNoZXN9XG4gICAgICovXG4gICAgbWF0Y2hlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHZhbHVlcyBvciBSZWdFeHAgcGF0dGVybnMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IMOkciBpbnRlIGV0dCBnb2Rrw6RudCB2w6RyZGUuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21heH1cbiAgICAgKi9cbiAgICBtYXgoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0sIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG9mIHVzZXItcHJvdmlkZWQgdmFsdWVzIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYEthbiBpbnRlIGhhIG1lciDDpG4gJHthcmdzWzBdfSAke25hbWV9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtw6VzdGUgdmFyYSAke2FyZ3NbMF19IGVsbGVyIG1pbmRyZS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgKGZpZWxkLWxldmVsKSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbWltZSB0eXBlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW1lfVxuICAgICAqL1xuICAgIG1pbWUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBmaWxlIGZvcm1hdHMgd2VyZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiAnSW5nYSBmaWx0eXBlciB0aWxsw6V0bmEuJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtw6VzdGUgdmFyYSBhdiBmaWx0eXBlbjogJHthcmdzWzBdfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGZ1bGZpbGwgbWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW59XG4gICAgICovXG4gICAgbWluKHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbiBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgS2FuIGludGUgaGEgbWluZHJlIMOkbiAke2FyZ3NbMF19ICR7bmFtZX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IG3DpXN0ZSB2YXJhIG1pbnN0ICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI25vdH1cbiAgICAgKi9cbiAgICBub3QoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0gfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIChhbmQgdGh1cyBkaXNhbGxvd2VkIGJ5KSB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDigJwke3ZhbHVlfeKAnSDDpHIgaW50ZSBldHQgZ29ka8OkbnQgJHtuYW1lfS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgSXMgbm90IGEgbnVtYmVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBtw6VzdGUgdmFyYSBlbiBzaWZmcmEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgZmllbGQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNyZXF1aXJlZH1cbiAgICAgKi9cbiAgICByZXF1aXJlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhIHZhbHVlIHRvIGEgcmVxdWlyZWQgaW5wdXQuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gw6RyIG9ibGlnYXRvcmlza3QuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBiw7ZyamFyIGludGUgbWVkICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBgVmFyIGdvZCBmeWxsIGkgZW4gZ2lsdGlnIGzDpG5rLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxufTtcblxudmFyIHN2ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1aTogdWkkNCxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uJDRcbn0pO1xuXG4vKipcbiAqIEhlcmUgd2UgY2FuIGltcG9ydCBhZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgdG8gYXNzaXN0IGluIGZvcm1hdHRpbmcgb3VyXG4gKiBsYW5ndWFnZS4gRmVlbCBmcmVlIHRvIGFkZCBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIHRvIGxpYnMvZm9ybWF0cyBpZiBpdFxuICogYXNzaXN0cyBpbiBjcmVhdGluZyBnb29kIHZhbGlkYXRpb24gbWVzc2FnZXMgZm9yIHlvdXIgbG9jYWxlLlxuICovXG4vKipcbiAqIFN0YW5kYXJkIGxhbmd1YWdlIGZvciBpbnRlcmZhY2UgZmVhdHVyZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVpJDMgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICfguYDguJ7guLTguYjguKEnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYSBidXR0b24gdG8gcmVtb3ZlIGl0ZW1zIGlzIHZpc2libGUuXG4gICAgICovXG4gICAgcmVtb3ZlOiAn4LmA4Lit4Liy4Lit4Lit4LiBJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyB0byByZW1vdmUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6ICfguYDguK3guLLguK3guK3guIHguJfguLHguYnguIfguKvguKHguJQnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICfguILguK3guK3guKDguLHguKIg4LiC4LmJ4Lit4Lih4Li54Lil4Lia4Liy4LiH4LiK4LmI4Lit4LiH4LiX4Li14LmI4LiB4Lij4Lit4LiB4LmE4Lih4LmI4LiW4Li54LiB4LiV4LmJ4Lit4LiHJyxcbiAgICAvKipcbiAgICAgKiBTaG93biBpbiBhIGJ1dHRvbiBpbnNpZGUgYSBmb3JtIHRvIHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzdWJtaXQ6ICfguKrguYjguIcnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gbm8gZmlsZXMgYXJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIG5vRmlsZXM6ICfguKLguLHguIfguYTguKHguYjguYTguJTguYnguYDguKXguLfguK3guIHguYTguJ/guKXguYwnLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiQzID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYW4gYWNjZXB0ZWQgdmFsdWUuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhY2NlcHRlZH1cbiAgICAgKi9cbiAgICBhY2NlcHRlZCh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCAnYWNjZXB0ZWQnIHZhbHVlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYOC4geC4o+C4uOC4k+C4suC4ouC4reC4oeC4o+C4seC4miAke25hbWV9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGFmdGVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWFmdGVyfVxuICAgICAqL1xuICAgIGRhdGVfYWZ0ZXIoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDguIjguLDguJXguYnguK3guIfguYDguJvguYfguJnguKfguLHguJnguJfguLXguYjguKvguKXguLHguIfguIjguLLguIEgJHtkYXRlKGFyZ3NbMF0pfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYWZ0ZXIgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDguIjguLDguJXguYnguK3guIfguYDguJvguYfguJnguKfguLHguJnguJfguLXguYjguJfguLXguYjguKLguLHguIfguYTguKHguYjguKHguLLguJbguLbguIdgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOC4quC4suC4oeC4suC4o+C4luC5gOC4m+C5h+C4meC5hOC4lOC5ieC5geC4hOC5iOC4leC4seC4p+C4reC4seC4geC4qeC4o+C5gOC4l+C5iOC4suC4meC4seC5ieC4mWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDguKrguLLguKHguLLguKPguJbguYDguJvguYfguJnguYTguJTguYnguYHguITguYjguJXguLHguKfguK3guLHguIHguKnguKPguYHguKXguLDguJXguLHguKfguYDguKXguILguYDguJfguYjguLLguJnguLHguYnguJlgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGxldHRlciBhbmQvb3Igc3BhY2VzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYS1zcGFjZXN9XG4gICAgICovXG4gICAgYWxwaGFfc3BhY2VzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgYW5kIG5vbi1zcGFjZSBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOC4quC4suC4oeC4suC4o+C4luC5gOC4m+C5h+C4meC5hOC4lOC5ieC5geC4hOC5iOC4leC4seC4p+C4reC4seC4geC4qeC4o+C5geC4peC4sOC5gOC4p+C5ieC4meC4p+C4o+C4o+C4hOC5gOC4l+C5iOC4suC4meC4seC5ieC4mWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOC4iOC4sOC4leC5ieC4reC4h+C5gOC4m+C5h+C4meC4p+C4seC4meC4l+C4teC5iOC4l+C4teC5iOC4oeC4suC4geC5iOC4reC4mSAke2RhdGUoYXJnc1swXSl9YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdG9kYXkncyBkYXRlLCBzaW5jZSBubyBkYXRlIHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDguIjguLDguJXguYnguK3guIfguYDguJvguYfguJnguKfguLHguJnguJfguLXguYjguJfguLXguYjguJzguYjguLLguJnguKHguLLguYHguKXguYnguKdgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGDguIrguYjguK3guIfguJnguLXguYnguJbguLnguIHguJXguLHguYnguIfguITguYjguLLguK3guKLguYjguLLguIfguYTguKHguYjguJbguLnguIHguJXguYnguK3guIcg4LmB4Lil4Liw4LiI4Liw4LmE4Lih4LmI4Liq4Liy4Lih4Liy4Lij4LiW4Liq4LmI4LiH4LiC4LmJ4Lit4Lih4Li54Lil4LmE4LiU4LmJYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYSwgYl0gPSBvcmRlcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnMuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g4LiI4Liw4LiV4LmJ4Lit4LiH4LmA4Lib4LmH4LiZ4LiE4LmI4Liy4Lij4Liw4Lir4Lin4LmI4Liy4LiHICR7YX0g4LmB4Lil4LiwICR7Yn1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOC5hOC4oeC5iOC4leC4o+C4h+C4geC4seC4mWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g4LmE4Lih4LmI4Lit4Lii4Li54LmI4LmD4LiZ4Lij4Li54Lib4LmB4Lia4Lia4Lin4Lix4LiZ4LiX4Li14LmI4LiX4Li14LmI4LiW4Li54LiB4LiV4LmJ4Lit4LiHIOC4geC4o+C4uOC4k+C4suC4geC4o+C4reC4geC4leC4suC4oeC4o+C4ueC4m+C5geC4muC4miAke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBkYXRlIGFyZ3VtZW50IHdhcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuICfguIrguYjguK3guIfguJnguLXguYnguJbguLnguIHguJXguLHguYnguIfguITguYjguLLguK3guKLguYjguLLguIfguYTguKHguYjguJbguLnguIHguJXguYnguK3guIcg4LmB4Lil4Liw4LiI4Liw4LmE4Lih4LmI4Liq4Liy4Lih4Liy4Lij4LiW4Liq4LmI4LiH4LiC4LmJ4Lit4Lih4Li54Lil4LmE4LiU4LmJJztcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IHdpdGhpbiBleHBlY3RlZCBkYXRlIHJhbmdlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWJldHdlZW59XG4gICAgICovXG4gICAgZGF0ZV9iZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOC4iOC4sOC4leC5ieC4reC4h+C5gOC4m+C5h+C4meC4p+C4seC4meC4l+C4teC5iOC4o+C4sOC4q+C4p+C5iOC4suC4hyAke2RhdGUoYXJnc1swXSl9IOC5geC4peC4sCAke2RhdGUoYXJnc1sxXSl9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICfguIHguKPguLjguJPguLLguIHguKPguK3guIHguJfguLXguYjguK3guKLguLnguYjguK3guLXguYDguKHguKXguJfguLXguJbguLnguIHguJXguYnguK3guIcnLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDguIjguLDguJXguYnguK3guIfguKXguIfguJfguYnguLLguKLguJTguYnguKfguKIgJHtsaXN0KGFyZ3MpfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNpc31cbiAgICAgKi9cbiAgICBpcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g4LmE4Lih4LmI4LmD4LiK4LmI4LiE4LmI4Liy4LiX4Li14LmI4Lit4LiZ4Li44LiN4Liy4LiV4LmD4Lir4LmJ4LiB4Lij4Lit4LiBYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IE51bWJlcihmaXJzdCkgPD0gTnVtYmVyKHNlY29uZCkgPyBmaXJzdCA6IHNlY29uZDtcbiAgICAgICAgY29uc3QgbWF4ID0gTnVtYmVyKHNlY29uZCkgPj0gTnVtYmVyKGZpcnN0KSA/IHNlY29uZCA6IGZpcnN0O1xuICAgICAgICBpZiAobWluID09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYXQgbGVhc3Qgb25lIGNoYXJhY3Rlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g4LiI4Liw4LiV4LmJ4Lit4LiH4Lih4Li14LiE4Lin4Liy4Lih4Lii4Liy4Lin4Lit4Lii4LmI4Liy4LiH4LiZ4LmJ4Lit4Lii4Lir4LiZ4Li24LmI4LiH4LiV4Lix4Lin4Lit4Lix4LiB4Lip4LijYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOC4iOC4sOC4leC5ieC4reC4h+C4oeC4teC4hOC4p+C4suC4oeC4ouC4suC4p+C5hOC4oeC5iOC5gOC4geC4tOC4mSAke21heH0g4LiV4Lix4Lin4Lit4Lix4LiB4Lip4LijYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDguIjguLDguJXguYnguK3guIfguKHguLXguITguKfguLLguKHguKLguLLguKcgJHttaW59IOC4leC4seC4p+C4reC4seC4geC4qeC4o+C4guC4tuC5ieC4meC5hOC4m2A7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBiZXR3ZWVuIHRoZSB0d28gbGVuZ3RocyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDguIjguLDguJXguYnguK3guIfguKHguLXguITguKfguLLguKHguKLguLLguKfguKPguLDguKvguKfguYjguLLguIcgJHttaW59IOC5geC4peC4sCAke21heH0g4LiV4Lix4Lin4Lit4Lix4LiB4Lip4LijYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsdWUgaXMgbm90IGEgbWF0Y2hcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21hdGNoZXN9XG4gICAgICovXG4gICAgbWF0Y2hlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHZhbHVlcyBvciBSZWdFeHAgcGF0dGVybnMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuIFwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOC5hOC4oeC5iOC5g+C4iuC5iOC4hOC5iOC4suC4l+C4teC5iOC4reC4meC4uOC4jeC4suC4leC5g+C4q+C5ieC4geC4o+C4reC4gWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGDguYTguKHguYjguKrguLLguKHguLLguKPguJbguYDguKXguLfguK3guIHguKHguLLguIHguIHguKfguYjguLIgJHthcmdzWzBdfSAke25hbWV9IOC5hOC4lOC5iWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDguIjguLDguJXguYnguK3guIfguKHguLXguITguYjguLLguYTguKHguYjguYDguIHguLTguJkgJHthcmdzWzBdfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICfguYTguKHguYjguKHguLXguJvguKPguLDguYDguKDguJfguILguK3guIfguYTguJ/guKXguYzguJfguLXguYjguK3guJnguLjguI3guLLguJUnO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBtaW1lIHR5cGUgb2YgdXNlci1wcm92aWRlZCBmaWxlIGRvZXMgbm90IG1hdGNoIGFueSBtaW1lIHR5cGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOC4iOC4sOC4leC5ieC4reC4h+C5gOC4m+C5h+C4meC5hOC4n+C4peC5jOC4m+C4o+C4sOC5gOC4oOC4lyAke2FyZ3NbMF19IOC5gOC4l+C5iOC4suC4meC4seC5ieC4mWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGZ1bGZpbGwgbWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW59XG4gICAgICovXG4gICAgbWluKHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbiBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBg4LmE4Lih4LmI4Liq4Liy4Lih4Liy4Lij4LiW4LmA4Lil4Li34Lit4LiB4LiZ4LmJ4Lit4Lii4LiB4Lin4LmI4LiyICR7YXJnc1swXX0gJHtuYW1lfSDguYTguJTguYlgO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g4LiI4Liw4LiV4LmJ4Lit4LiH4Lih4Li14LiE4LmI4Liy4Lit4Lii4LmI4Liy4LiH4LiZ4LmJ4Lit4LiiICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbm90fVxuICAgICAqL1xuICAgIG5vdCh7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIG1hdGNoZXMgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gKGFuZCB0aHVzIGRpc2FsbG93ZWQgYnkpIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYOKAnCR7dmFsdWV94oCdIOC5hOC4oeC5iOC5g+C4iuC5iOC4hOC5iOC4siAke25hbWV9IOC4l+C4teC5iOC4reC4meC4uOC4jeC4suC4leC5g+C4q+C5ieC4geC4o+C4reC4gWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqICBJcyBub3QgYSBudW1iZXJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IOC4iOC4sOC4leC5ieC4reC4h+C5gOC4m+C5h+C4meC4leC4seC4p+C5gOC4peC4guC5gOC4l+C5iOC4suC4meC4seC5ieC4mWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZpZWxkLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jcmVxdWlyZWR9XG4gICAgICovXG4gICAgcmVxdWlyZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYSB2YWx1ZSB0byBhIHJlcXVpcmVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYOC4geC4o+C4uOC4k+C4suC4geC4o+C4reC4gSAke3NlbnRlbmNlKG5hbWUpfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0g4LiI4Liw4LiV4LmJ4Lit4LiH4LmA4Lij4Li04LmI4Lih4LiV4LmJ4LiZ4LiU4LmJ4Lin4LiiICR7bGlzdChhcmdzKX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYSB1cmxcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3VybH1cbiAgICAgKi9cbiAgICB1cmwoKSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHVybC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDguIHguKPguLjguJPguLLguKPguLDguJrguLjguJfguLXguYjguK3guKLguLnguYjguKXguLTguIfguIHguYzguYPguKvguYnguJbguLnguIHguJXguYnguK3guIdgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbn07XG5cbnZhciB0aCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdWk6IHVpJDMsXG4gICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbiQzXG59KTtcblxuLyoqXG4gKiBIZXJlIHdlIGNhbiBpbXBvcnQgYWRkaXRpb25hbCBoZWxwZXIgZnVuY3Rpb25zIHRvIGFzc2lzdCBpbiBmb3JtYXR0aW5nIG91clxuICogbGFuZ3VhZ2UuIEZlZWwgZnJlZSB0byBhZGQgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyB0byBsaWJzL2Zvcm1hdHMgaWYgaXRcbiAqIGFzc2lzdHMgaW4gY3JlYXRpbmcgZ29vZCB2YWxpZGF0aW9uIG1lc3NhZ2VzIGZvciB5b3VyIGxvY2FsZS5cbiAqL1xuLyoqXG4gKiBTdGFuZGFyZCBsYW5ndWFnZSBmb3IgaW50ZXJmYWNlIGZlYXR1cmVzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB1aSQyID0ge1xuICAgIC8qKlxuICAgICAqIFNob3duIG9uIGJ1dHRvbnMgZm9yIGFkZGluZyBuZXcgaXRlbXMuXG4gICAgICovXG4gICAgYWRkOiAnRWtsZScsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhIGJ1dHRvbiB0byByZW1vdmUgaXRlbXMgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmU6ICdLYWxkxLFyJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBpdGVtcyB0byByZW1vdmUgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6ICdIZXBzaW5pIGthbGTEsXInLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYWxsIGZpZWxkcyBhcmUgbm90IGZpbGxlZCBvdXQgY29ycmVjdGx5LlxuICAgICAqL1xuICAgIGluY29tcGxldGU6ICdNYWFsZXNlZiwgdMO8bSBhbGFubGFyIGRvxJ9ydSBkb2xkdXJ1bG1hZMSxLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnR8O2bmRlcicsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBubyBmaWxlcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgbm9GaWxlczogJ0Rvc3lhIHlvaycsXG59O1xuLyoqXG4gKiBUaGVzZSBhcmUgYWxsIHRoZSBwb3NzaWJsZSBzdHJpbmdzIHRoYXQgcGVydGFpbiB0byB2YWxpZGF0aW9uIG1lc3NhZ2VzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB2YWxpZGF0aW9uJDIgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbiBhY2NlcHRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FjY2VwdGVkfVxuICAgICAqL1xuICAgIGFjY2VwdGVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkICdhY2NlcHRlZCcgdmFsdWUuXCI+ICovXG4gICAgICAgIHJldHVybiBgTMO8dGZlbiAke25hbWV9J3lpIGthYnVsIGVkaW4uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGFmdGVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWFmdGVyfVxuICAgICAqL1xuICAgIGRhdGVfYWZ0ZXIoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSAke2RhdGUoYXJnc1swXSl9J2RlbiBzb25yYSBvbG1hbMSxZMSxci5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZ2VsZWNla3RlIGJpciB6YW1hbiBvbG1hbMSxZMSxci5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNhZGVjZSBhbGZhYmV0aWsga2FyYWt0ZXJsZXIgacOnZXJlYmlsaXIuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHNhZGVjZSBhbGZhYmV0aWsga2FyYWt0ZXJsZXIgdmUgc2F5xLEgacOnZXJlYmlsaXIuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSB5YWxuxLF6Y2EgaGFyZiB2ZSBib8WfbHVrIGnDp2VyZWJpbGlyLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9ICR7ZGF0ZShhcmdzWzBdKX0gdGFyaWhpbmRlbiDDtm5jZSBvbG1hbMSxLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gZ2XDp21pxZ90ZSBvbG1hbMSxLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYmV0d2VlbiB0d28gbnVtYmVyc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBiZXR3ZWVuKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCBpc05hTihhcmdzWzFdKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYW55IG9mIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgd2VyZSBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYEFsYW4geWFubMSxxZ8geWFwxLFsYW5kxLFyxLFsbcSxxZ8gdmUgZ8O2bmRlcmlsZW1lei5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9ICR7YXJnc1swXX0gdmUgJHthcmdzWzFdfSBhcmFsxLHEn8SxbmRhIG9sbWFsxLEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpcm1hdGlvbiBmaWVsZCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jY29uZmlybX1cbiAgICAgKi9cbiAgICBjb25maXJtKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgbWF0Y2hlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBlxZ9sZcWfbWl5b3IuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGRhdGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtZm9ybWF0fVxuICAgICAqL1xuICAgIGRhdGVfZm9ybWF0KHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGRvZXMgbm90IHNhdGlzZnkgdGhlIGRhdGUgZm9ybWF0IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBnZcOnZXJsaSBiaXIgdGFyaWggZGXEn2lsLCBsw7x0ZmVuICR7YXJnc1swXX0gYmnDp2ltaW5pIGt1bGxhbsSxbi5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGRhdGUgYXJndW1lbnQgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gJ0FsYW4geWFubMSxxZ8geWFwxLFsYW5kxLFyxLFsbcSxxZ8gdmUgZ8O2bmRlcmlsZW1lei4nO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3Qgd2l0aGluIGV4cGVjdGVkIGRhdGUgcmFuZ2VcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBkYXRlX2JldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0sICR7ZGF0ZShhcmdzWzBdKX0gdmUgJHtkYXRlKGFyZ3NbMV0pfSBhcmFsxLHEn8SxbmRhIG9sbWFsxLEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICdMw7x0ZmVuIGdlw6dlcmxpIGJpciBlLW1haWwgYWRyZXNpIGdpcmluLicsXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgZW5kIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW5kcy13aXRofVxuICAgICAqL1xuICAgIGVuZHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3Vic3RyaW5nIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9ICR7bGlzdChhcmdzKX0gaWxlIGJpdG1peW9yLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNpc31cbiAgICAgKi9cbiAgICBpcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaXppbiB2ZXJpbGVuIGJpciBkZcSfZXIgZGXEn2lsLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBsZW5ndGhcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2xlbmd0aH1cbiAgICAgKi9cbiAgICBsZW5ndGgoeyBuYW1lLCBhcmdzOiBbZmlyc3QgPSAwLCBzZWNvbmQgPSBJbmZpbml0eV0gfSkge1xuICAgICAgICBjb25zdCBtaW4gPSBmaXJzdCA8PSBzZWNvbmQgPyBmaXJzdCA6IHNlY29uZDtcbiAgICAgICAgY29uc3QgbWF4ID0gc2Vjb25kID49IGZpcnN0ID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgICAgIGlmIChtaW4gPT0gMSAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBlbiBhesSxbmRhbiBiaXIga2FyYWt0ZXIgdXp1bmx1xJ91bmRhIG9sbWFsxLEuYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9ICR7bWF4fSdlIGXFn2l0IHZleWEgZGFoYSBrw7zDp8O8ayBvbG1hbMSxLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiAmJiBtYXggPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBzdXBwbGllZCB0byB0aGUgcnVsZSBhbmQgdGhlcmUgaXMgbm8gbWF4aW11bSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gJHttaW59J2UgZcWfaXQgdmV5YSBkYWhhIGLDvHnDvGsgb2xtYWzEsS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0sICR7bWlufSB2ZSAke21heH0ga2FyYWt0ZXIgdXp1bmx1xJ91IGFyYWzEscSfxLFuZGEgb2xtYWzEsS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBpcyBub3QgYSBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWF0Y2hlc31cbiAgICAgKi9cbiAgICBtYXRjaGVzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgdmFsdWVzIG9yIFJlZ0V4cCBwYXR0ZXJucyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gaXppbiB2ZXJpbGVuIGJpciBkZcSfZXIgZGXEn2lsLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke25hbWV9J2luIHV6dW5sdcSfdSAke2FyZ3NbMF19J2RhbiBkYWhhIHV6dW4gb2xhbWF6LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBlbiBhesSxbmRhbiAke2FyZ3NbMF19IHV6dW5sdcSfdW5kYSB2ZXlhIG9uYSBlxZ9pdCBvbG1hbMSxLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSAoZmllbGQtbGV2ZWwpIHZhbHVlIGRvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI21pbWV9XG4gICAgICovXG4gICAgbWltZSh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoIWFyZ3NbMF0pIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGZpbGUgZm9ybWF0cyB3ZXJlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuICdIacOnYmlyIGRvc3lhIHTDvHLDvG5lIGl6aW4gdmVyaWxtZXouJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSDFn3UgdGlwbGVyZGVuIGJpcmkgb2xtYWzEsTogJHthcmdzWzBdfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGZ1bGZpbGwgbWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW59XG4gICAgICovXG4gICAgbWluKHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbiBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfSdpbiB1enVubHXEn3UgJHthcmdzWzBdfSdkYW4gZGFoYSBrxLFzYSBvbGFtYXouYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGVuIGF6xLFuZGFuICR7YXJnc1swXX0gdXp1bmx1xJ91bmRhIG9sbWFsxLEuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI25vdH1cbiAgICAgKi9cbiAgICBub3QoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0gfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIChhbmQgdGh1cyBkaXNhbGxvd2VkIGJ5KSB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDigJwke3ZhbHVlfeKAnSAke25hbWV9IG9sYW1hei5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgSXMgbm90IGEgbnVtYmVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNudW1iZXJ9XG4gICAgICovXG4gICAgbnVtYmVyKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBzYXnEsSBvbG1hbMSxLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZpZWxkLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jcmVxdWlyZWR9XG4gICAgICovXG4gICAgcmVxdWlyZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYSB2YWx1ZSB0byBhIHJlcXVpcmVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGdlcmVrbGkuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSAke2xpc3QoYXJncyl9IGlsZSBiYcWfbGFtxLF5b3IuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBgTMO8dGZlbiBnZcOnZXJsaSBiaXIgdXJsIGRhaGlsIGVkaW4uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgdHIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSQyLFxuICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24kMlxufSk7XG5cbi8qKlxuICogSGVyZSB3ZSBjYW4gaW1wb3J0IGFkZGl0aW9uYWwgaGVscGVyIGZ1bmN0aW9ucyB0byBhc3Npc3QgaW4gZm9ybWF0dGluZyBvdXJcbiAqIGxhbmd1YWdlLiBGZWVsIGZyZWUgdG8gYWRkIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgdG8gbGlicy9mb3JtYXRzIGlmIGl0XG4gKiBhc3Npc3RzIGluIGNyZWF0aW5nIGdvb2QgdmFsaWRhdGlvbiBtZXNzYWdlcyBmb3IgeW91ciBsb2NhbGUuXG4gKi9cbi8qKlxuICogU3RhbmRhcmQgbGFuZ3VhZ2UgZm9yIGludGVyZmFjZSBmZWF0dXJlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdWkkMSA9IHtcbiAgICAvKipcbiAgICAgKiBTaG93biBvbiBidXR0b25zIGZvciBhZGRpbmcgbmV3IGl0ZW1zLlxuICAgICAqL1xuICAgIGFkZDogJ1Row6ptJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGEgYnV0dG9uIHRvIHJlbW92ZSBpdGVtcyBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZTogJ1hvw6EnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHRvIHJlbW92ZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbDogJ1hvw6EgdOG6pXQgY+G6oycsXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiBhbGwgZmllbGRzIGFyZSBub3QgZmlsbGVkIG91dCBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgaW5jb21wbGV0ZTogJ1hpbiBs4buXaSwga2jDtG5nIHBo4bqjaSB04bqldCBj4bqjIGPDoWMgdHLGsOG7nW5nIMSR4buBdSDEkcaw4bujYyBuaOG6rXAgxJHDum5nLicsXG4gICAgLyoqXG4gICAgICogU2hvd24gaW4gYSBidXR0b24gaW5zaWRlIGEgZm9ybSB0byBzdWJtaXQgdGhlIGZvcm0uXG4gICAgICovXG4gICAgc3VibWl0OiAnR+G7rWknLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gbm8gZmlsZXMgYXJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIG5vRmlsZXM6ICdDaMawYSBjaOG7jW4gZmlsZScsXG59O1xuLyoqXG4gKiBUaGVzZSBhcmUgYWxsIHRoZSBwb3NzaWJsZSBzdHJpbmdzIHRoYXQgcGVydGFpbiB0byB2YWxpZGF0aW9uIG1lc3NhZ2VzLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB2YWxpZGF0aW9uJDEgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbiBhY2NlcHRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FjY2VwdGVkfVxuICAgICAqL1xuICAgIGFjY2VwdGVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkICdhY2NlcHRlZCcgdmFsdWUuXCI+ICovXG4gICAgICAgIHJldHVybiBgSMOjeSDEkeG7k25nIMO9IHbhu5tpICR7bmFtZX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGFmdGVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWFmdGVyfVxuICAgICAqL1xuICAgIGRhdGVfYWZ0ZXIoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBwaOG6o2kgc2F1ICR7ZGF0ZShhcmdzWzBdKX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBhZnRlciB0b2RheSdzIGRhdGUsIHNpbmNlIG5vIGRhdGUgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHBo4bqjaSB0cm9uZyB0xrDGoW5nIGxhaS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGPDsyB0aOG7gyBjaOG7iSBiYW8gZ+G7k20gY8OhYyBjaOG7ryBjw6FpIGFscGhhYmV0LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYWxwaGFudW1lcmljXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYW51bWVyaWN9XG4gICAgICovXG4gICAgYWxwaGFudW1lcmljKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBjw7MgdGjhu4MgY2jhu4kgYmFvIGfhu5NtIGPDoWMgY2jhu68gY8OhaSB2w6AgY2jhu68gc+G7kS5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGxldHRlciBhbmQvb3Igc3BhY2VzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNhbHBoYS1zcGFjZXN9XG4gICAgICovXG4gICAgYWxwaGFfc3BhY2VzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGNvbnRhaW5zIG5vbi1hbHBoYWJldGljYWwgYW5kIG5vbi1zcGFjZSBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGNo4buJIGPDsyB0aOG7gyBjaOG7qWEgY8OhYyBjaOG7ryBjw6FpIHbDoCBraG/huqNuZyB0cuG6r25nLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHBo4bqjaSB0csaw4bubYyAke2RhdGUoYXJnc1swXSl9LmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gcGjhuqNpIHRyb25nIHF1w6Ega2jhu6kuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNiZXR3ZWVufVxuICAgICAqL1xuICAgIGJldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKGlzTmFOKGFyZ3NbMF0pIHx8IGlzTmFOKGFyZ3NbMV0pKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBhbnkgb2YgdGhlIGFyZ3VtZW50cyBzdXBwbGllZCB0byB0aGUgcnVsZSB3ZXJlIG5vdCBhIG51bWJlci5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgVHLGsOG7nW5nIG7DoHkgxJHDoyDEkcaw4bujYyB0aGnhur90IGzhuq1wIHNhaSB2w6Aga2jDtG5nIHRo4buDIGfhu61pLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2EsIGJdID0gb3JkZXIoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHBo4bqjaSDhu58gZ2nhu69hICR7YX0gdsOgICR7Yn0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpcm1hdGlvbiBmaWVsZCBkb2VzIG5vdCBtYXRjaFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jY29uZmlybX1cbiAgICAgKi9cbiAgICBjb25maXJtKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVxdWFsIHRoZSB2YWx1ZSBvZiB0aGUgbWF0Y2hlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBraMO0bmcga2jhu5twLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWZvcm1hdH1cbiAgICAgKi9cbiAgICBkYXRlX2Zvcm1hdCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBkYXRlIGZvcm1hdCBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0ga2jDtG5nIHBo4bqjaSBuZ8OgeSBo4bujcCBs4buHLCBow6N5IHPhu60gZOG7pW5nIMSR4buLbmggZOG6oW5nICR7YXJnc1swXX1gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGRhdGUgYXJndW1lbnQgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gJ1RyxrDhu51uZyBuw6B5IMSRw6MgxJHGsOG7o2MgdGhp4bq/dCBs4bqtcCBzYWkgdsOgIGtow7RuZyB0aOG7gyBn4butaS4nO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3Qgd2l0aGluIGV4cGVjdGVkIGRhdGUgcmFuZ2VcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmV0d2Vlbn1cbiAgICAgKi9cbiAgICBkYXRlX2JldHdlZW4oeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBzdXBwbGllZCB0byB0aGUgcnVsZS4gXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gcGjhuqNpIOG7nyBnaeG7r2Ega2hv4bqjbmcgdOG7qyAke2RhdGUoYXJnc1swXSl9IMSR4bq/biAke2RhdGUoYXJnc1sxXSl9LmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VtYWlsfVxuICAgICAqL1xuICAgIGVtYWlsOiAnSMOjeSBuaOG6rXAgbeG7mXQgxJHhu4thIGNo4buJIGVtYWlsIGjhu6NwIGzhu4cuJyxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBlbmQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNlbmRzLXdpdGh9XG4gICAgICovXG4gICAgZW5kc193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGVuZCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0ga2jDtG5nIGvhur90IHRow7pjIHbhu5tpICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2lzfVxuICAgICAqL1xuICAgIGlzKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBraMO0bmcgcGjhuqNpIG3hu5l0IGdpw6EgdHLhu4sgxJHGsOG7o2MgY2hvIHBow6lwLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IG1hdGNoIHNwZWNpZmllZCBsZW5ndGhcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2xlbmd0aH1cbiAgICAgKi9cbiAgICBsZW5ndGgoeyBuYW1lLCBhcmdzOiBbZmlyc3QgPSAwLCBzZWNvbmQgPSBJbmZpbml0eV0gfSkge1xuICAgICAgICBjb25zdCBtaW4gPSBOdW1iZXIoZmlyc3QpIDw9IE51bWJlcihzZWNvbmQpID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgICAgIGNvbnN0IG1heCA9IE51bWJlcihzZWNvbmQpID49IE51bWJlcihmaXJzdCkgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgaWYgKG1pbiA9PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHBo4bqjaSBjw7MgxJHhu5kgZMOgaSB04buRaSB0aGnhu4N1IG3hu5l0IGvDvSB04buxLmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA9PSAwICYmIG1heCkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gZmlyc3QgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIHJ1bGUgaXMgMCwgYW5kIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoZSBtYXggKHRoZSAybmQgYXJndW1lbnQpIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBwaOG6o2kgY8OzIMSR4buZIGTDoGkgdOG7kWkgxJFhICR7bWF4fSBrw70gdOG7sS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUgYW5kIHRoZXJlIGlzIG5vIG1heGltdW0gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHBo4bqjaSBjw7MgxJHhu5kgZMOgaSB04buRaSB0aGnhu4N1ICR7bWlufSBrw70gdOG7sS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgYmV0d2VlbiB0aGUgdHdvIGxlbmd0aHMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gcGjhuqNpIGPDsyDEkeG7mSBkw6BpIHThu5FpIMSRYSB0cm9uZyBraG/huqNuZyB04burICR7bWlufSDEkeG6v24gJHttYXh9IGvDvSB04buxLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBraMO0bmcgcGjhuqNpIG3hu5l0IGdpw6EgdHLhu4sgxJHGsOG7o2MgY2hvIHBow6lwLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke25hbWV9IGtow7RuZyB0aOG7gyBs4bubbiBoxqFuICR7YXJnc1swXX0uYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHBo4bqjaSB04buRaSDEkWEgYuG6sW5nICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIChmaWVsZC1sZXZlbCkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWltZX1cbiAgICAgKi9cbiAgICBtaW1lKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmICghYXJnc1swXSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gbm8gZmlsZSBmb3JtYXRzIHdlcmUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gJ8SQ4buLbmggZOG6oW5nIHThu4dwIHRpbiBuw6B5IGtow7RuZyDEkcaw4bujYyBwaMOpcC4nO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBtaW1lIHR5cGUgb2YgdXNlci1wcm92aWRlZCBmaWxlIGRvZXMgbm90IG1hdGNoIGFueSBtaW1lIHR5cGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IHBo4bqjaSBsw6AgbeG7mXQgdHJvbmcgY8OhYyBk4bqhbmc6ICR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX0ga2jDtG5nIHRo4buDIG5o4buPIGjGoW4gJHthcmdzWzBdfS5gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBudW1iZXIgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gcGjhuqNpIHThu5FpIHRoaeG7g3UgYuG6sW5nICR7YXJnc1swXX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGFuIGFsbG93ZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI25vdH1cbiAgICAgKi9cbiAgICBub3QoeyBuYW1lLCBub2RlOiB7IHZhbHVlIH0gfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBtYXRjaGVzIG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIChhbmQgdGh1cyBkaXNhbGxvd2VkIGJ5KSB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCIga2jDtG5nIHBo4bqjaSBnacOhIHRy4buLICR7bmFtZX0gxJHGsOG7o2MgcGjDqXAuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogIElzIG5vdCBhIG51bWJlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlcih7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX0gcGjhuqNpIGzDoCBt4buZdCBz4buRLmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGZpZWxkLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jcmVxdWlyZWR9XG4gICAgICovXG4gICAgcmVxdWlyZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gYSB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYSB2YWx1ZSB0byBhIHJlcXVpcmVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl9IGzDoCBi4bqvdCBideG7mWMuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3Qgc3RhcnQgd2l0aCBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3N0YXJ0cy13aXRofVxuICAgICAqL1xuICAgIHN0YXJ0c193aXRoKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfSBraMO0bmcgYuG6r3QgxJHhuqd1IHbhu5tpICR7bGlzdChhcmdzKX0uYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBgSMOjeSBuaOG6rXAgbeG7mXQgVVJMIGjhu6NwIGzhu4cuYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgdmkgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSQxLFxuICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24kMVxufSk7XG5cbi8qKlxuICogSGVyZSB3ZSBjYW4gaW1wb3J0IGFkZGl0aW9uYWwgaGVscGVyIGZ1bmN0aW9ucyB0byBhc3Npc3QgaW4gZm9ybWF0dGluZyBvdXJcbiAqIGxhbmd1YWdlLiBGZWVsIGZyZWUgdG8gYWRkIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgdG8gbGlicy9mb3JtYXRzIGlmIGl0XG4gKiBhc3Npc3RzIGluIGNyZWF0aW5nIGdvb2QgdmFsaWRhdGlvbiBtZXNzYWdlcyBmb3IgeW91ciBsb2NhbGUuXG4gKi9cbi8qKlxuICogU3RhbmRhcmQgbGFuZ3VhZ2UgZm9yIGludGVyZmFjZSBmZWF0dXJlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdWkgPSB7XG4gICAgLyoqXG4gICAgICogU2hvd24gb24gYnV0dG9ucyBmb3IgYWRkaW5nIG5ldyBpdGVtcy5cbiAgICAgKi9cbiAgICBhZGQ6ICfmt7vliqAnLFxuICAgIC8qKlxuICAgICAqIFNob3duIHdoZW4gYSBidXR0b24gdG8gcmVtb3ZlIGl0ZW1zIGlzIHZpc2libGUuXG4gICAgICovXG4gICAgcmVtb3ZlOiAn56e76ZmkJyxcbiAgICAvKipcbiAgICAgKiBTaG93biB3aGVuIGFsbCBmaWVsZHMgYXJlIG5vdCBmaWxsZWQgb3V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpbmNvbXBsZXRlOiAn5a+55LiN6LW377yM5pyJ5Lqb5a2X5q615pyq6KKr5q2j56Gu5aGr5YaZJyxcbiAgICAvKipcbiAgICAgKiBTaG93biBpbiBhIGJ1dHRvbiBpbnNpZGUgYSBmb3JtIHRvIHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgKi9cbiAgICBzdWJtaXQ6ICfmj5DkuqQnLFxufTtcbi8qKlxuICogVGhlc2UgYXJlIGFsbCB0aGUgcG9zc2libGUgc3RyaW5ncyB0aGF0IHBlcnRhaW4gdG8gdmFsaWRhdGlvbiBtZXNzYWdlcy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdmFsaWRhdGlvbiA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGFuIGFjY2VwdGVkIHZhbHVlLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWNjZXB0ZWR9XG4gICAgICovXG4gICAgYWNjZXB0ZWQoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgJ2FjY2VwdGVkJyB2YWx1ZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGDor7fmjqXlj5cke25hbWV9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGUgaXMgbm90IGFmdGVyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNkYXRlLWFmdGVyfVxuICAgICAqL1xuICAgIGRhdGVfYWZ0ZXIoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRoZSBkYXRlIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeW/hemhu+aZmuS6jiR7ZGF0ZShhcmdzWzBdKX1gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIGRhdGUgaXMgbm90IGFmdGVyIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3lv4XpobvmmK/mnKrmnaXnmoTml6XmnJ9gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGEgbGV0dGVyLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGF9XG4gICAgICovXG4gICAgYWxwaGEoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhYmV0aWNhbCBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl95LuF6IO95YyF5ZCr5a2X5q+N5a2X56ymYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhbHBoYW51bWVyaWNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2FscGhhbnVtZXJpY31cbiAgICAgKi9cbiAgICBhbHBoYW51bWVyaWMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgY29udGFpbnMgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl95LuF6IO95YyF5ZCr5a2X5q+N5ZKM5pWw5a2XYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBsZXR0ZXIgYW5kL29yIHNwYWNlc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jYWxwaGEtc3BhY2VzfVxuICAgICAqL1xuICAgIGFscGhhX3NwYWNlcyh7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBjb250YWlucyBub24tYWxwaGFiZXRpY2FsIGFuZCBub24tc3BhY2UgY2hhcmFjdGVycy5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeWPquiDveWMheWQq+Wtl+avjeWSjOepuuagvGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIGlzIG5vdCBiZWZvcmVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtYmVmb3JlfVxuICAgICAqL1xuICAgIGRhdGVfYmVmb3JlKHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZWZvcmUgdGhlIGRhdGUgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl95b+F6aG75pep5LqOJHtkYXRlKGFyZ3NbMF0pfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgZGF0ZSBpcyBub3QgYmVmb3JlIHRvZGF5J3MgZGF0ZSwgc2luY2Ugbm8gZGF0ZSB3YXMgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3lv4XpobvmmK/ov4fljrvnmoTml6XmnJ9gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgaXMgbm90IGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2JldHdlZW59XG4gICAgICovXG4gICAgYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgaXNOYU4oYXJnc1sxXSkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGFueSBvZiB0aGUgYXJndW1lbnRzIHN1cHBsaWVkIHRvIHRoZSBydWxlIHdlcmUgbm90IGEgbnVtYmVyLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGDor6XlrZfmrrXmnKrooqvmraPnoa7orr7nva7ogIzml6Dms5Xooqvmj5DkuqRgO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlIGlzIG5vdCBiZXR3ZWVuIHR3byBudW1iZXJzLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl95b+F6aG75ZyoJHthcmdzWzBdfeWSjCR7YXJnc1sxXX3kuYvpl7RgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlybWF0aW9uIGZpZWxkIGRvZXMgbm90IG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNjb25maXJtfVxuICAgICAqL1xuICAgIGNvbmZpcm0oeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBtYXRjaGVkIGlucHV0LlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl95LiN5Yy56YWNYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGRhdGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2RhdGUtZm9ybWF0fVxuICAgICAqL1xuICAgIGRhdGVfZm9ybWF0KHsgbmFtZSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGRvZXMgbm90IHNhdGlzZnkgdGhlIGRhdGUgZm9ybWF0IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeS4jeaYr+S4gOS4quWQiOazleaXpeacn++8jOivt+S9v+eUqOatpOagvOW8jyR7YXJnc1swXX1gO1xuICAgICAgICAgICAgLyogPC9pMThuPiAqL1xuICAgICAgICB9XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIG5vIGRhdGUgYXJndW1lbnQgd2FzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gJ+ivpeWtl+auteacquiiq+ato+ehruiuvue9ruiAjOaXoOazleiiq+aPkOS6pCc7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCB3aXRoaW4gZXhwZWN0ZWQgZGF0ZSByYW5nZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZGF0ZS1iZXR3ZWVufVxuICAgICAqL1xuICAgIGRhdGVfYmV0d2Vlbih7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCBkYXRlIGlzIG5vdCBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGRhdGVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeW/hemhu+WcqCR7ZGF0ZShhcmdzWzBdKX3lkowke2RhdGUoYXJnc1sxXSl95LmL6Ze0YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jZW1haWx9XG4gICAgICovXG4gICAgZW1haWw6ICfor7fovpPlhaXkuIDkuKrlkIjms5XnmoTnlLXlrZDpgq7ku7blnLDlnYAnLFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IGVuZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI2VuZHMtd2l0aH1cbiAgICAgKi9cbiAgICBlbmRzX3dpdGgoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgZW5kIHdpdGggdGhlIHN1YnN0cmluZyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeW5tuacquS7pSR7bGlzdChhcmdzKX3nu5PlsL5gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJcyBub3QgYW4gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jaXN9XG4gICAgICovXG4gICAgaXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9uZSBvZiB0aGUgdmFsdWVzIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl95LiN5piv5LiA5Liq5YWB6K645YC8YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRG9lcyBub3QgbWF0Y2ggc3BlY2lmaWVkIGxlbmd0aFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbGVuZ3RofVxuICAgICAqL1xuICAgIGxlbmd0aCh7IG5hbWUsIGFyZ3M6IFtmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5XSB9KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IGZpcnN0IDw9IHNlY29uZCA/IGZpcnN0IDogc2Vjb25kO1xuICAgICAgICBjb25zdCBtYXggPSBzZWNvbmQgPj0gZmlyc3QgPyBzZWNvbmQgOiBmaXJzdDtcbiAgICAgICAgaWYgKG1pbiA9PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbm90IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl96Iez5bCR6KaB5pyJ5LiA5Liq5a2X56ymYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09IDAgJiYgbWF4KSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBmaXJzdCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUgcnVsZSBpcyAwLCBhbmQgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heCAodGhlIDJuZCBhcmd1bWVudCkgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl95b+F6aG75bCR5LqO5oiW562J5LqOJHttYXh95Liq5a2X56ymYDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIHRoZSBsZW5ndGggb2YgdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlIGFuZCB0aGVyZSBpcyBubyBtYXhpbXVtIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeW/hemhu+WkmuS6juaIluetieS6jiR7bWlufeS4quWtl+espmA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBiZXR3ZWVuIHRoZSB0d28gbGVuZ3RocyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeW/hemhu+aciSR7bWlufeiHsyR7bWF4feS4quWtl+espmA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGlzIG5vdCBhIG1hdGNoXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXRjaGVzfVxuICAgICAqL1xuICAgIG1hdGNoZXMoeyBuYW1lIH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSB2YWx1ZXMgb3IgUmVnRXhwIHBhdHRlcm5zIHN1cHBsaWVkIHRvIHRoZSBydWxlLiBcIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeS4jeaYr+S4gOS4quWFgeiuuOWAvGA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtYXh9XG4gICAgICovXG4gICAgbWF4KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9LCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBvZiB1c2VyLXByb3ZpZGVkIHZhbHVlcyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICAgICAgcmV0dXJuIGAke25hbWV95LiN6IO96LaF6L+HJHthcmdzWzBdfWA7XG4gICAgICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgICAgIH1cbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeW/hemhu+Wwj+S6juaIluetieS6jiR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgKGZpZWxkLWxldmVsKSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBzcGVjaWZpZWQgbWltZSB0eXBlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNtaW1lfVxuICAgICAqL1xuICAgIG1pbWUoeyBuYW1lLCBhcmdzIH0pIHtcbiAgICAgICAgaWYgKCFhcmdzWzBdKSB7XG4gICAgICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiBubyBmaWxlIGZvcm1hdHMgd2VyZSBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgICAgIHJldHVybiAn5peg5YWB6K6455qE5paH5Lu25qC85byPJztcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgbWltZSB0eXBlIG9mIHVzZXItcHJvdmlkZWQgZmlsZSBkb2VzIG5vdCBtYXRjaCBhbnkgbWltZSB0eXBlcyBzdXBwbGllZCB0byB0aGUgcnVsZS5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeW/hemhu+S4uuatpOexu+Wei++8miR7YXJnc1swXX1gO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBmdWxmaWxsIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbWlufVxuICAgICAqL1xuICAgIG1pbih7IG5hbWUsIG5vZGU6IHsgdmFsdWUgfSwgYXJncyB9KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgb2YgdXNlci1wcm92aWRlZCB2YWx1ZXMgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW4gc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX3kuI3og73lsJHkuo4ke2FyZ3NbMF19YDtcbiAgICAgICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICAgICAgfVxuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbnVtYmVyIHN1cHBsaWVkIHRvIHRoZSBydWxlLlwiPiAqL1xuICAgICAgICByZXR1cm4gYCR7c2VudGVuY2UobmFtZSl95LiN6IO95bCP5LqOJHthcmdzWzBdfWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzIG5vdCBhbiBhbGxvd2VkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNub3R9XG4gICAgICovXG4gICAgbm90KHsgbmFtZSwgbm9kZTogeyB2YWx1ZSB9IH0pIHtcbiAgICAgICAgLyogPGkxOG4gY2FzZT1cIlNob3duIHdoZW4gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhbHVlcyBzdXBwbGllZCB0byAoYW5kIHRodXMgZGlzYWxsb3dlZCBieSkgdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBg4oCcJHt2YWx1ZX3igJ3kuI3mmK/kuIDkuKrooqvlhYHorrjnmoQke25hbWV9YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogIElzIG5vdCBhIG51bWJlclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5mb3Jta2l0LmNvbS9lc3NlbnRpYWxzL3ZhbGlkYXRpb24jbnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlcih7IG5hbWUgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3lv4XpobvmmK/kuIDkuKrmlbDlrZdgO1xuICAgICAgICAvKiA8L2kxOG4+ICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCBmaWVsZC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MuZm9ybWtpdC5jb20vZXNzZW50aWFscy92YWxpZGF0aW9uI3JlcXVpcmVkfVxuICAgICAqL1xuICAgIHJlcXVpcmVkKHsgbmFtZSB9KSB7XG4gICAgICAgIC8qIDxpMThuIGNhc2U9XCJTaG93biB3aGVuIGEgdXNlciBkb2VzIG5vdCBwcm92aWRlIGEgdmFsdWUgdG8gYSByZXF1aXJlZCBpbnB1dC5cIj4gKi9cbiAgICAgICAgcmV0dXJuIGAke3NlbnRlbmNlKG5hbWUpfeW/hemhu+Whq+WGmWA7XG4gICAgICAgIC8qIDwvaTE4bj4gKi9cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERvZXMgbm90IHN0YXJ0IHdpdGggc3BlY2lmaWVkIHZhbHVlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiNzdGFydHMtd2l0aH1cbiAgICAgKi9cbiAgICBzdGFydHNfd2l0aCh7IG5hbWUsIGFyZ3MgfSkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBzdWJzdHJpbmcgc3VwcGxpZWQgdG8gdGhlIHJ1bGUuXCI+ICovXG4gICAgICAgIHJldHVybiBgJHtzZW50ZW5jZShuYW1lKX3msqHmnInku6Uke2xpc3QoYXJncyl95byA5aS0YDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSXMgbm90IGEgdXJsXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmZvcm1raXQuY29tL2Vzc2VudGlhbHMvdmFsaWRhdGlvbiN1cmx9XG4gICAgICovXG4gICAgdXJsKCkge1xuICAgICAgICAvKiA8aTE4biBjYXNlPVwiU2hvd24gd2hlbiB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCB1cmwuXCI+ICovXG4gICAgICAgIHJldHVybiBg6K+35YyF5ZCr5LiA5Liq5ZCI5rOV55qEdXJsYDtcbiAgICAgICAgLyogPC9pMThuPiAqL1xuICAgIH0sXG59O1xuXG52YXIgemggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHVpOiB1aSxcbiAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uXG59KTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW50ZXJuYXRpb25hbGl6YXRpb24gcGx1Z2luIGZvciBGb3JtS2l0LlxuICogQHBhcmFtIGxvY2FsZXMgLSBDcmVhdGVzIHRoZSBpMThuIHBsdWdpbi5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSTE4blBsdWdpbihyZWdpc3RyeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpMThuUGx1Z2luKG5vZGUpIHtcbiAgICAgICAgbGV0IGxvY2FsZUtleSA9IHBhcnNlTG9jYWxlKG5vZGUuY29uZmlnLmxvY2FsZSwgcmVnaXN0cnkpO1xuICAgICAgICBsZXQgbG9jYWxlID0gbG9jYWxlS2V5ID8gcmVnaXN0cnlbbG9jYWxlS2V5XSA6IHt9O1xuICAgICAgICAvKiBJZiB0aGUgbG9jYWxlIHByb3AgY2hhbmdlcywgdXBkYXRlIHRoZSBhY3RpdmUgbG9jYWxlICovXG4gICAgICAgIG5vZGUub24oJ3Byb3A6bG9jYWxlJywgKHsgcGF5bG9hZDogbGFuZyB9KSA9PiB7XG4gICAgICAgICAgICBsb2NhbGVLZXkgPSBwYXJzZUxvY2FsZShsYW5nLCByZWdpc3RyeSk7XG4gICAgICAgICAgICBsb2NhbGUgPSBsb2NhbGVLZXkgPyByZWdpc3RyeVtsb2NhbGVLZXldIDoge307XG4gICAgICAgICAgICAvLyBSdW4gdGhyb3VnaCBhbGwgdGhlIG1lc3NhZ2VzIGluIHRoZSBzdG9yZSBhbmQgdXBkYXRlIHdpdGggbmV3IGxvY2FsZVxuICAgICAgICAgICAgbm9kZS5zdG9yZS50b3VjaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5vbigncHJvcDpsYWJlbCcsICgpID0+IG5vZGUuc3RvcmUudG91Y2goKSk7XG4gICAgICAgIG5vZGUub24oJ3Byb3A6dmFsaWRhdGlvbkxhYmVsJywgKCkgPT4gbm9kZS5zdG9yZS50b3VjaCgpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvb2sgaW50byB0aGUgY29yZSB0ZXh0IG9yIHQoKSBob29rIHRvIHBlcmZvcm0gbG9jYWxpemF0aW9uIG9uIHRoZVxuICAgICAgICAgKiBvdXRwdXQgb2YgY29yZSBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZS5ob29rLnRleHQoKGZyYWdtZW50LCBuZXh0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gKChfYSA9IGZyYWdtZW50Lm1ldGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlS2V5KSB8fCBmcmFnbWVudC5rZXk7XG4gICAgICAgICAgICBpZiAoaGFzKGxvY2FsZSwgZnJhZ21lbnQudHlwZSkgJiYgaGFzKGxvY2FsZVtmcmFnbWVudC50eXBlXSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBsb2NhbGVbZnJhZ21lbnQudHlwZV1ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQudmFsdWUgPSBBcnJheS5pc0FycmF5KChfYiA9IGZyYWdtZW50Lm1ldGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pMThuQXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdCguLi5mcmFnbWVudC5tZXRhLmkxOG5BcmdzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC52YWx1ZSA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHQoZnJhZ21lbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0gbG9jYWxlIC0gQW4gSVNPIDYzOS0xIGFuZCAob3B0aW9uYWxseSkgSVNPIDYzOS0yIGxhbmd1YWdlIHRhZy4gRm9yXG4gKiBleGFtcGxlIHRoZXNlIGFyZSB2YWxpZCBsb2NhbGUga2V5czpcbiAqIHpoXG4gKiB6aC1DTlxuICogemgtSEtcbiAqIGVuXG4gKiBlbi1HQlxuICogQHBhcmFtIGF2YWlsYWJsZUxvY2FsZXMgLSBBbiBhcnJheSBvZiBsb2NhbGVzIHRoYXQgbWF5IGJlIHZhbGlkLlxuICovXG5mdW5jdGlvbiBwYXJzZUxvY2FsZShsb2NhbGUsIGF2YWlsYWJsZUxvY2FsZXMpIHtcbiAgICBpZiAoaGFzKGF2YWlsYWJsZUxvY2FsZXMsIGxvY2FsZSkpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICB9XG4gICAgY29uc3QgW2xhbmddID0gbG9jYWxlLnNwbGl0KCctJyk7XG4gICAgaWYgKGhhcyhhdmFpbGFibGVMb2NhbGVzLCBsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZztcbiAgICB9XG4gICAgZm9yIChjb25zdCBsb2NhbGUgaW4gYXZhaWxhYmxlTG9jYWxlcykge1xuICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogRXhwb3J0IGFsbCB0aGUgYXZhaWxhYmxlIGxvY2FsZXMgYXQgb25jZS5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgbG9jYWxlcyA9IHtcbiAgICBhcixcbiAgICBjcyxcbiAgICBkYSxcbiAgICBkZSxcbiAgICBlbixcbiAgICBlcyxcbiAgICBmYSxcbiAgICBmaSxcbiAgICBmcixcbiAgICBmeSxcbiAgICBoZSxcbiAgICBocixcbiAgICBpZCxcbiAgICBpdCxcbiAgICBqYSxcbiAgICBrbyxcbiAgICBubCxcbiAgICBwbCxcbiAgICBwdCxcbiAgICBybyxcbiAgICBydSxcbiAgICBzbCxcbiAgICBzdixcbiAgICB0aCxcbiAgICB0cixcbiAgICB2aSxcbiAgICB6aCxcbn07XG5cbmV4cG9ydCB7IGFyLCBjcmVhdGVJMThuUGx1Z2luLCBjcywgZGEsIGRhdGUsIGRlLCBlbiwgZXMsIGZhLCBmaSwgZnIsIGZ5LCBoZSwgaHIsIGlkLCBpdCwgamEsIGtvLCBsaXN0LCBsb2NhbGVzLCBubCwgb3JkZXIsIHBsLCBwdCwgcm8sIHJ1LCBzZW50ZW5jZSwgc2wsIHN2LCB0aCwgdHIsIHZpLCB6aCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formkit/i18n/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/@formkit/inputs/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@formkit/inputs/dist/index.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"button\": function() { return /* binding */ button; },\n/* harmony export */   \"checkbox\": function() { return /* binding */ checkbox; },\n/* harmony export */   \"color\": function() { return /* binding */ color; },\n/* harmony export */   \"composable\": function() { return /* binding */ composable; },\n/* harmony export */   \"createLibraryPlugin\": function() { return /* binding */ createLibraryPlugin; },\n/* harmony export */   \"date\": function() { return /* binding */ date; },\n/* harmony export */   \"datetimeLocal\": function() { return /* binding */ datetimeLocal; },\n/* harmony export */   \"email\": function() { return /* binding */ email; },\n/* harmony export */   \"extendSchema\": function() { return /* binding */ extendSchema; },\n/* harmony export */   \"features\": function() { return /* binding */ index; },\n/* harmony export */   \"file\": function() { return /* binding */ file; },\n/* harmony export */   \"form\": function() { return /* binding */ form; },\n/* harmony export */   \"group\": function() { return /* binding */ group; },\n/* harmony export */   \"hidden\": function() { return /* binding */ hidden; },\n/* harmony export */   \"inputs\": function() { return /* binding */ inputs; },\n/* harmony export */   \"list\": function() { return /* binding */ list; },\n/* harmony export */   \"localize\": function() { return /* binding */ localize; },\n/* harmony export */   \"month\": function() { return /* binding */ month; },\n/* harmony export */   \"number\": function() { return /* binding */ number; },\n/* harmony export */   \"password\": function() { return /* binding */ password; },\n/* harmony export */   \"radio\": function() { return /* binding */ radio; },\n/* harmony export */   \"range\": function() { return /* binding */ range; },\n/* harmony export */   \"search\": function() { return /* binding */ search; },\n/* harmony export */   \"select\": function() { return /* binding */ select; },\n/* harmony export */   \"submit\": function() { return /* binding */ submit; },\n/* harmony export */   \"tel\": function() { return /* binding */ tel; },\n/* harmony export */   \"text\": function() { return /* binding */ text; },\n/* harmony export */   \"textarea\": function() { return /* binding */ textarea; },\n/* harmony export */   \"time\": function() { return /* binding */ time; },\n/* harmony export */   \"url\": function() { return /* binding */ url; },\n/* harmony export */   \"useSchema\": function() { return /* binding */ useSchema; },\n/* harmony export */   \"week\": function() { return /* binding */ week; }\n/* harmony export */ });\n/* harmony import */ var _formkit_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formkit/utils */ \"./node_modules/@formkit/utils/dist/index.mjs\");\n/* harmony import */ var _formkit_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formkit/core */ \"./node_modules/@formkit/core/dist/index.mjs\");\n\n\n\nconst outer = composable('outer', () => ({\n    $el: 'div',\n    attrs: {\n        class: '$classes.outer',\n        'data-type': '$type',\n        'data-multiple': '$attrs.multiple',\n        'data-disabled': '$disabled || undefined',\n        'data-complete': '$state.complete || undefined',\n        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',\n        'data-errors': '$state.errors || undefined',\n        'data-submitted': '$state.submitted || undefined',\n    },\n}));\n\nconst wrapper$2 = composable('wrapper', () => ({\n    $el: 'div',\n    attrs: {\n        class: '$classes.wrapper',\n    },\n}));\n\nconst inner = composable('inner', () => ({\n    $el: 'div',\n    attrs: {\n        class: '$classes.inner',\n    },\n}));\n\nconst help = (schema = {}, children = [], target = 'help', cond = '$help') => ({\n    if: `$slots.${target}`,\n    then: `$slots.${target}`,\n    else: (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.extend)({\n        $el: 'div',\n        attrs: {\n            id: `$: \"help-\" + ${target == 'optionHelp' ? '$option.attrs.id' : '$id'}`,\n            class: `$classes.${target}`,\n        },\n        if: cond,\n        children,\n    }, schema),\n});\n\nconst messages = composable('messages', () => ({\n    $el: 'ul',\n    if: '$fns.length($messages)',\n    attrs: {\n        class: '$classes.messages',\n        'aria-live': '$type === \"form\" && \"assertive\" || \"polite\"',\n    },\n}));\n\nconst message = composable('message', () => ({\n    $el: 'li',\n    for: ['message', '$messages'],\n    attrs: {\n        key: '$message.key',\n        class: '$classes.message',\n        id: `$id + '-' + $message.key`,\n        'data-message-type': '$message.type',\n    },\n}));\n\nconst prefix = composable('prefix', () => ({ $el: null }));\n\nconst suffix = composable('suffix', () => ({ $el: null }));\n\n/**\n * Type guard for schema objects.\n * @param schema - returns true if the node is a schema node but not a string or conditional.\n */\nfunction isSchemaObject(schema) {\n    return (typeof schema === 'object' &&\n        ('$el' in schema || '$cmp' in schema || '$formkit' in schema));\n}\n/**\n * Extends a single schema node with an extension. The extension can be any partial node including strings.\n * @param schema - Extend a base schema node.\n * @param extension - The values to extend on the base schema node.\n * @returns\n * @public\n */\nfunction extendSchema(schema, extension = {}) {\n    if (typeof schema === 'string') {\n        return isSchemaObject(extension) || typeof extension === 'string'\n            ? extension\n            : schema;\n    }\n    else if (Array.isArray(schema)) {\n        return isSchemaObject(extension) ? extension : schema;\n    }\n    return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(schema, extension);\n}\n/**\n * Creates a new section key.\n *\n * @param key - A new section key name.\n * @param schema - The default schema in this composable slot.\n * @returns\n * @public\n */\nfunction composable(key, schema) {\n    return (extendWith = {}, children = undefined) => {\n        const root = typeof schema === 'function'\n            ? schema(children)\n            : typeof schema === 'object'\n                ? (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.clone)(schema)\n                : schema;\n        const isObj = isSchemaObject(root);\n        if (isObj && !('children' in root) && children) {\n            if (Array.isArray(children)) {\n                if (children.length) {\n                    root.children = children;\n                }\n            }\n            else {\n                root.children = [children];\n            }\n        }\n        const extended = extendSchema(root, extendWith);\n        return {\n            if: `$slots.${key}`,\n            then: `$slots.${key}`,\n            else: Array.isArray(extended) ? extended : [extended],\n        };\n    };\n}\n/**\n * Creates an input schema with all of the wrapping base schema.\n * @param inputSchema - Content to store in the input section key location.\n * @public\n */\nfunction useSchema(inputSchema) {\n    return (extensions = {}) => {\n        const input = composable('input', inputSchema)(extensions.input);\n        return [\n            outer(extensions.outer, [\n                wrapper$2(extensions.wrapper, [\n                    label(extensions.label, '$label'),\n                    inner(extensions.inner, [\n                        prefix(extensions.prefix),\n                        ...(Array.isArray(input) ? input : [input]),\n                        suffix(extensions.suffix),\n                    ]),\n                ]),\n                help(extensions.help, '$help'),\n                messages(extensions.messages, [\n                    message(extensions.message, '$message.value'),\n                ]),\n            ]),\n        ];\n    };\n}\n\nconst label = composable('label', () => ({\n    $el: 'label',\n    if: '$label',\n    attrs: {\n        for: '$id',\n        class: '$classes.label',\n    },\n}));\n\nconst text$1 = composable('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        onInput: '$handlers.DOMInput',\n        onBlur: '$handlers.blur',\n        value: '$_value',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst textSchema$1 = (extensions = {}) => [\n    outer(extensions.outer, [\n        wrapper$2(extensions.wrapper, [\n            label(extensions.label, '$label'),\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                text$1(extensions.input),\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n    ]),\n];\n\nconst file$1 = composable('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: 'file',\n        foo: 'bar',\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        onChange: '$handlers.files',\n        onBlur: '$handlers.blur',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n}));\n\nconst fileList = composable('fileList', () => ({\n    $el: 'ul',\n    if: '$value.length',\n    attrs: {\n        class: '$classes.fileList',\n        'data-has-multiple': {\n            if: '$value.length > 1',\n            then: 'true',\n        },\n    },\n}));\n\nconst fileItem = composable('fileItem', () => ({\n    $el: 'li',\n    for: ['file', '$value'],\n    attrs: {\n        class: '$classes.fileItem',\n    },\n}));\n\nconst fileName = composable('fileName', () => ({\n    $el: 'span',\n    attrs: {\n        class: '$classes.fileName',\n    },\n}));\n\nconst noFiles = composable('noFiles', () => ({\n    $el: 'span',\n    if: '$value.length == 0',\n    attrs: {\n        class: '$classes.noFiles',\n    },\n}));\n\nconst removeFiles = composable('removeFiles', () => ({\n    $el: 'a',\n    attrs: {\n        href: '#',\n        class: '$classes.removeFiles',\n        onClick: '$handlers.resetFiles',\n    },\n}));\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst fileSchema = (extensions = {}) => [\n    outer(extensions.outer, [\n        wrapper$2(extensions.wrapper, [\n            label(extensions.label, '$label'),\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                file$1(extensions.input),\n                fileList(extensions.fileList, [\n                    fileItem(extensions.file, [\n                        fileName(extensions.fileName, '$file.name'),\n                        {\n                            if: '$value.length == 1',\n                            then: removeFiles(extensions.removeFiles, '$ui.remove.value'),\n                        },\n                    ]),\n                ]),\n                {\n                    if: '$value.length > 1',\n                    then: removeFiles(extensions.removeFiles, '$ui.removeAll.value'),\n                },\n                noFiles(extensions.noFiles, '$ui.noFiles.value'),\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n    ]),\n];\n\nconst textarea$1 = composable('input', () => ({\n    $el: 'textarea',\n    bind: '$attrs',\n    attrs: {\n        class: '$classes.input',\n        disabled: '$disabled',\n        name: '$node.name',\n        onInput: '$handlers.DOMInput',\n        onBlur: '$handlers.blur',\n        value: '$_value',\n        id: '$id',\n        'aria-describedby': '$describedBy',\n    },\n    children: '$initialValue',\n}));\n\n/**\n * The schema for textarea classifications.\n * @public\n */\nconst textareaSchema = (extensions = {}) => [\n    outer(extensions.outer, [\n        wrapper$2(extensions.wrapper, [\n            label(extensions.label, '$label'),\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                textarea$1(extensions.input),\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n    ]),\n];\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst hiddenSchema = (extensions = {}) => [\n    text$1(extensions.input),\n];\n\nconst fragment = (schema = {}, children = []) => (Object.keys(schema).length || typeof children !== 'string'\n    ? (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.extend)({ $el: 'div', children }, schema)\n    : children);\n\nconst groupSchema = (extensions = {}) => {\n    return [fragment(extensions.wrapper, '$slots.default')];\n};\n\nconst listSchema = (extensions = {}) => {\n    return [fragment(extensions.wrapper, '$slots.default')];\n};\n\nconst select$2 = composable('input', (children) => ({\n    $el: 'select',\n    bind: '$attrs',\n    attrs: {\n        id: '$id',\n        'data-placeholder': {\n            if: '$placeholder',\n            then: {\n                if: '$value',\n                then: undefined,\n                else: 'true',\n            },\n        },\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        onInput: '$handlers.selectInput',\n        onBlur: '$handlers.blur',\n        'aria-describedby': '$describedBy',\n    },\n    children: {\n        if: '$slots.default',\n        then: '$slots.default',\n        else: children,\n    },\n}));\n\nconst option = (schema = {}, children = []) => ({\n    if: '$slots.option',\n    then: [\n        {\n            $el: 'text',\n            if: '$options.length',\n            for: ['option', '$options'],\n            children: '$slots.option',\n        },\n    ],\n    else: (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.extend)({\n        $el: 'option',\n        if: '$options.length',\n        for: ['option', '$options'],\n        bind: '$option.attrs',\n        attrs: {\n            class: '$classes.option',\n            value: '$option.value',\n            selected: '$fns.isSelected($option.value)',\n        },\n        children,\n    }, schema),\n});\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst textSchema = (extensions = {}) => [\n    outer(extensions.outer, [\n        wrapper$2(extensions.wrapper, [\n            label(extensions.label, '$label'),\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                select$2(extensions.input, [option(extensions.option, '$option.label')]),\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n    ]),\n];\n\nconst boxLabel = composable('label', (children) => ({\n    $el: 'span',\n    if: typeof children === 'string' ? children : '$: true',\n    attrs: {\n        class: '$classes.label',\n    },\n}));\n\nconst wrapper$1 = composable('wrapper', () => ({\n    $el: 'label',\n    attrs: {\n        class: '$classes.wrapper',\n        'data-disabled': {\n            if: '$options.length',\n            then: undefined,\n            else: '$disabled',\n        },\n    },\n}));\n\nconst box = composable('input', () => ({\n    $el: 'input',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        class: '$classes.input',\n        name: '$node.props.altName || $node.name',\n        disabled: '$option.attrs.disabled || $disabled',\n        onInput: '$handlers.toggleChecked',\n        checked: '$fns.eq($_value, $onValue)',\n        onBlur: '$handlers.blur',\n        value: '$: true',\n        id: '$id',\n        'aria-describedby': {\n            if: '$options.length',\n            then: {\n                if: '$option.help',\n                then: '$: \"help-\" + $option.attrs.id',\n                else: undefined,\n            },\n            else: {\n                if: '$help',\n                then: '$: \"help-\" + $id',\n                else: undefined,\n            },\n        },\n    },\n}));\n\nconst fieldset = composable('fieldset', () => ({\n    $el: 'fieldset',\n    attrs: {\n        id: '$id',\n        class: '$classes.fieldset',\n        'aria-describedby': {\n            if: '$help',\n            then: '$: \"help-\" + $id',\n            else: undefined,\n        },\n    },\n}));\n\nconst legend = composable('legend', () => ({\n    $el: 'legend',\n    if: '$label',\n    attrs: {\n        class: '$classes.legend',\n    },\n}));\n\nconst boxes = composable('option', () => ({\n    $el: 'li',\n    for: ['option', '$options'],\n    attrs: {\n        class: '$classes.option',\n        'data-disabled': '$option.attrs.disabled || $disabled',\n    },\n}));\n\nconst wrapper = composable('options', () => ({\n    $el: 'ul',\n    attrs: {\n        class: '$classes.options',\n    },\n}));\n\nconst decorator = composable('decorator', () => ({\n    $el: 'span',\n    attrs: {\n        class: '$classes.decorator',\n        'aria-hidden': 'true',\n    },\n}));\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst boxSchema = (extensions = {}) => {\n    const singleCheckbox = [\n        wrapper$1(extensions.wrapper, [\n            inner(extensions.inner, [\n                prefix(extensions.prefix),\n                box(extensions.input),\n                decorator(extensions.decorator),\n                suffix(extensions.suffix),\n            ]),\n            boxLabel(extensions.label, '$label'),\n        ]),\n        help(extensions.help, '$help'),\n    ];\n    const multiCheckbox = fieldset(extensions.fieldset, [\n        legend(extensions.legend, '$label'),\n        help(extensions.help, '$help'),\n        wrapper(extensions.options, [\n            boxes(extensions.option, [\n                wrapper$1(extensions.wrapper, [\n                    inner(extensions.inner, [\n                        prefix(extensions.prefix),\n                        box((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.extend)({\n                            bind: '$option.attrs',\n                            attrs: {\n                                id: '$option.attrs.id',\n                                value: '$option.value',\n                                checked: '$fns.isChecked($option.value)',\n                            },\n                        }, extensions.input || {})),\n                        decorator(extensions.decorator),\n                        suffix(extensions.suffix),\n                    ]),\n                    boxLabel(extensions.label, '$option.label'),\n                ]),\n                help(extensions.optionHelp, '$option.help', 'optionHelp', '$option.help'),\n            ]),\n        ]),\n    ]);\n    return [\n        outer(extensions.outer, [\n            {\n                if: '$options.length',\n                then: multiCheckbox,\n                else: singleCheckbox,\n            },\n            messages(extensions.messages, [\n                message(extensions.message, '$message.value'),\n            ]),\n        ]),\n    ];\n};\n\nconst actions = composable('actions', () => ({\n    $el: 'div',\n    if: '$actions',\n    attrs: {\n        class: '$classes.actions',\n    },\n}));\n\nconst form$2 = composable('form', () => ({\n    $el: 'form',\n    bind: '$attrs',\n    attrs: {\n        id: '$id',\n        class: '$classes.form',\n        name: '$node.name',\n        onSubmit: '$handlers.submit',\n        'data-loading': '$state.loading || undefined',\n    },\n}));\n\nconst submit$1 = composable('submit', () => ({\n    $cmp: 'FormKit',\n    bind: '$submitAttrs',\n    props: {\n        ignore: true,\n        type: 'submit',\n        disabled: '$disabled',\n        label: '$submitLabel',\n    },\n}));\n\nconst formSchema = (extensions = {}) => {\n    return [\n        form$2(extensions.form, [\n            '$slots.default',\n            messages(extensions.messages, [\n                message(extensions.message, '$message.value'),\n            ]),\n            actions(extensions.actions, [submit$1(extensions.submit)]),\n        ]),\n    ];\n};\n\nconst button$1 = composable('input', () => ({\n    $el: 'button',\n    bind: '$attrs',\n    attrs: {\n        type: '$type',\n        disabled: '$disabled',\n        class: '$classes.input',\n        name: '$node.name',\n        id: '$id',\n    },\n}));\n\n/**\n * The schema for text classifications.\n * @public\n */\nconst buttonSchema = (extensions = {}) => [\n    outer(extensions.outer, [\n        messages(extensions.messages, [\n            message(extensions.message, '$message.value'),\n        ]),\n        wrapper$2(extensions.wrapper, [\n            button$1(extensions.input, [\n                prefix(extensions.prefix),\n                {\n                    if: '$slots.default',\n                    then: '$slots.default',\n                    else: {\n                        if: '$label',\n                        then: '$label',\n                        else: '$ui.submit.value',\n                    },\n                },\n                suffix(extensions.suffix),\n            ]),\n        ]),\n        help(extensions.help, '$help'),\n    ]),\n];\n\n/**\n * Accepts an array of objects, array of strings, or object of key-value pairs.\n * and returns an array of objects with value and label properties.\n * @param options -\n */\nfunction normalizeOptions(options) {\n    let i = 1;\n    if (Array.isArray(options)) {\n        return options.map((option) => {\n            if (typeof option === 'string' || typeof option === 'number') {\n                return {\n                    label: option,\n                    value: option,\n                };\n            }\n            if (typeof option == 'object') {\n                if ('value' in option && typeof option.value !== 'string') {\n                    Object.assign(option, {\n                        value: `__mask_${i++}`,\n                        __original: option.value,\n                    });\n                }\n            }\n            return option;\n        });\n    }\n    return Object.keys(options).map((value) => {\n        return {\n            label: options[value],\n            value,\n        };\n    });\n}\n/**\n * Given an option list, find the \"true\" value in the options.\n * @param options - The options to check for a given value\n * @param value - The value to return\n * @returns\n */\nfunction optionValue(options, value) {\n    if (Array.isArray(options)) {\n        for (const option of options) {\n            if (value == option.value) {\n                return '__original' in option ? option.__original : option.value;\n            }\n        }\n    }\n    return value;\n}\n/**\n * Determines if the value should be selected.\n * @param valueA - Any type of value\n * @param valueB - Any type of value\n */\nfunction shouldSelect(valueA, valueB) {\n    if (valueA == valueB)\n        return true;\n    if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.isPojo)(valueA) && (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.isPojo)(valueB))\n        return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.eq)(valueA, valueB);\n    return false;\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nfunction options(node) {\n    node.hook.prop((prop, next) => {\n        if (prop.prop === 'options') {\n            const options = normalizeOptions(prop.value);\n            prop.value = options;\n        }\n        return next(prop);\n    });\n}\n\n/**\n * Checks if a the given option should have the selected attribute.\n * @param node - The node being evaluated.\n * @param option - The option value to check\n * @returns\n */\nfunction isSelected(node, option) {\n    // Here we trick reactivity (if at play) to watch this function.\n    node.context && node.context.value;\n    const value = optionValue(node.props.options, option);\n    return Array.isArray(node._value)\n        ? node._value.some((optionA) => shouldSelect(optionA, value))\n        : (node.value === undefined && !option) || shouldSelect(value, node._value);\n}\n/**\n * Select the correct values.\n * @param e - The input event emitted by the select.\n */\nfunction selectInput(node, e) {\n    const target = e.target;\n    const value = target.hasAttribute('multiple')\n        ? Array.from(target.selectedOptions).map((o) => optionValue(node.props.options, o.value))\n        : optionValue(node.props.options, target.value);\n    node.input(value);\n}\n/**\n * Appends a placeholder to the options list.\n * @param options - An options list\n * @param placeholder - A placeholder string to append\n * @returns\n */\nfunction applyPlaceholder(options, placeholder) {\n    if (!options.some((option) => option.attrs && option.attrs['data-is-placeholder'])) {\n        return [\n            {\n                label: placeholder,\n                value: '',\n                attrs: {\n                    hidden: true,\n                    disabled: true,\n                    'data-is-placeholder': 'true',\n                },\n            },\n            ...options,\n        ];\n    }\n    return options;\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nfunction select$1(node) {\n    // Set the initial value of a multi-input\n    node.on('created', () => {\n        var _a, _b, _c;\n        const isMultiple = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.undefine)((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple);\n        if (!isMultiple &&\n            node.props.placeholder &&\n            Array.isArray(node.props.options)) {\n            node.hook.prop(({ prop, value }, next) => {\n                if (prop === 'options') {\n                    value = applyPlaceholder(value, node.props.placeholder);\n                }\n                return next({ prop, value });\n            });\n            node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);\n        }\n        if (isMultiple) {\n            if (node.value === undefined) {\n                node.input([], false);\n            }\n        }\n        else if (node.context && !node.context.options) {\n            // If this input is (probably) using the default slot, we need to add a\n            // \"value\" attribute to get bound\n            node.props.attrs = Object.assign({}, node.props.attrs, {\n                value: node._value,\n            });\n            node.on('input', ({ payload }) => {\n                node.props.attrs = Object.assign({}, node.props.attrs, {\n                    value: payload,\n                });\n            });\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {\n            node.context.handlers.selectInput = selectInput.bind(null, node);\n        }\n        if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {\n            node.context.fns.isSelected = isSelected.bind(null, node);\n        }\n    });\n    node.hook.input((value, next) => {\n        var _a, _b, _c;\n        if (!node.props.placeholder &&\n            value === undefined &&\n            Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) &&\n            node.props.options.length &&\n            !(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.undefine)((_c = (_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.multiple)) {\n            value =\n                '__original' in node.props.options[0]\n                    ? node.props.options[0].__original\n                    : node.props.options[0].value;\n        }\n        return next(value);\n    });\n}\n\n/**\n * Normalize the boxes.\n * @param node - The node\n * @returns\n * @public\n */\nfunction normalizeBoxes(node) {\n    return function (prop, next) {\n        if (prop.prop === 'options' && Array.isArray(prop.value)) {\n            prop.value = prop.value.map((option) => {\n                var _a;\n                if (!((_a = option.attrs) === null || _a === void 0 ? void 0 : _a.id)) {\n                    return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(option, {\n                        attrs: { id: `${node.name}-option-${(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.kebab)(String(option.value))}` },\n                    });\n                }\n                return option;\n            });\n            if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {\n                if (node.isCreated) {\n                    node.input([], false);\n                }\n                else {\n                    node.on('created', () => {\n                        if (!Array.isArray(node.value)) {\n                            node.input([], false);\n                        }\n                    });\n                }\n            }\n        }\n        return next(prop);\n    };\n}\n\n/**\n * Event handler when an input is toggled.\n * @param node - The node being toggled\n * @param e - The input even related to the toggling\n */\nfunction toggleChecked$1(node, e) {\n    const el = e.target;\n    if (el instanceof HTMLInputElement) {\n        const value = Array.isArray(node.props.options)\n            ? optionValue(node.props.options, el.value)\n            : el.value;\n        if (Array.isArray(node.props.options) && node.props.options.length) {\n            if (!Array.isArray(node._value)) {\n                // There is no array value set\n                node.input([value]);\n            }\n            else if (!node._value.some((existingValue) => shouldSelect(value, existingValue))) {\n                // The value is not in the current set\n                node.input([...node._value, value]);\n            }\n            else {\n                // Filter out equivalent values\n                node.input(node._value.filter((existingValue) => !shouldSelect(value, existingValue)));\n            }\n        }\n        else {\n            if (el.checked) {\n                node.input(node.props.onValue);\n            }\n            else {\n                node.input(node.props.offValue);\n            }\n        }\n    }\n}\n/**\n * Checks if a given option is present in the node value.\n * @param node - The node being checked\n * @param value - The value of any option\n * @returns\n */\nfunction isChecked$1(node, value) {\n    var _a, _b;\n    // We need to force vue’s reactivity to respond when the value is run:\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\n    if (Array.isArray(node._value)) {\n        return node._value.some((existingValue) => shouldSelect(optionValue(node.props.options, value), existingValue));\n    }\n    return false;\n}\n/**\n * Adds checkbox selection support\n * @param node - Node the feature is added to\n * @public\n */\nfunction checkboxes(node) {\n    node.on('created', () => {\n        var _a, _b;\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\n            node.context.fns.isChecked = isChecked$1.bind(null, node);\n        }\n        // Configure our default onValue and offValue\n        if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(node.props, 'onValue'))\n            node.props.onValue = true;\n        if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(node.props, 'offValue'))\n            node.props.offValue = false;\n    });\n    node.hook.prop(normalizeBoxes(node));\n}\n\n/**\n * Sets the value of a radio button when checked.\n * @param node - FormKitNode\n * @param value - Value\n */\nfunction toggleChecked(node, event) {\n    if (event.target instanceof HTMLInputElement) {\n        node.input(optionValue(node.props.options, event.target.value));\n    }\n}\n/**\n * Checks if the value being checked is the current value.\n * @param node - The node to check against.\n * @param value - The value to check\n * @returns\n */\nfunction isChecked(node, value) {\n    var _a, _b;\n    // We need to force vue’s reactivity to respond when the value is run:\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\n    return shouldSelect(optionValue(node.props.options, value), node._value);\n}\n/**\n * Determines if a given radio input is being evaluated.\n * @param node - The radio input group.\n * @public\n */\nfunction radios(node) {\n    node.on('created', () => {\n        var _a, _b;\n        if (!Array.isArray(node.props.options)) {\n            (0,_formkit_core__WEBPACK_IMPORTED_MODULE_1__.warn)(350, node);\n        }\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.toggleChecked = toggleChecked.bind(null, node);\n        }\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\n            node.context.fns.isChecked = isChecked.bind(null, node);\n        }\n    });\n    node.hook.prop(normalizeBoxes(node));\n}\n\n/**\n * Allows disabling children of this.\n * @param node - The FormKitNode of the form/group/list\n * @public\n */\nfunction disables(node) {\n    node.on('created', () => {\n        node.props.disabled = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.undefine)(node.props.disabled);\n    });\n    node.hook.prop(({ prop, value }, next) => {\n        value = prop === 'disabled' ? (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.undefine)(value) : value;\n        return next({ prop, value });\n    });\n    node.on('prop:disabled', ({ payload: value }) => {\n        node.config.disabled = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.undefine)(value);\n    });\n    node.on('created', () => {\n        node.config.disabled = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.undefine)(node.props.disabled);\n    });\n}\n\n/**\n * Handle the submit event.\n * @param e - The event\n */\nasync function handleSubmit(node, submitEvent) {\n    submitEvent.preventDefault();\n    await node.settled;\n    // Set the submitted state on all children\n    node.walk((n) => {\n        n.store.set((0,_formkit_core__WEBPACK_IMPORTED_MODULE_1__.createMessage)({\n            key: 'submitted',\n            value: true,\n            visible: false,\n        }));\n    });\n    if (typeof node.props.onSubmitRaw === 'function') {\n        node.props.onSubmitRaw(submitEvent, node);\n    }\n    if (node.ledger.value('blocking')) {\n        // There is still a blocking message in the store.\n        if (node.props.incompleteMessage !== false) {\n            node.store.set((0,_formkit_core__WEBPACK_IMPORTED_MODULE_1__.createMessage)({\n                blocking: false,\n                key: `incomplete`,\n                meta: {\n                    localize: node.props.incompleteMessage === undefined,\n                    i18nArgs: [{ node }],\n                    showAsMessage: true,\n                },\n                type: 'ui',\n                value: node.props.incompleteMessage || 'Form incomplete.',\n            }));\n        }\n    }\n    else {\n        // No blocking messages\n        if (typeof node.props.onSubmit === 'function') {\n            // call onSubmit\n            const retVal = node.props.onSubmit((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.clone)(node.value), node);\n            if (retVal instanceof Promise) {\n                const autoDisable = node.props.disabled === undefined &&\n                    node.props.submitBehavior !== 'live';\n                if (autoDisable)\n                    node.props.disabled = true;\n                node.store.set((0,_formkit_core__WEBPACK_IMPORTED_MODULE_1__.createMessage)({\n                    key: 'loading',\n                    value: true,\n                    visible: false,\n                }));\n                await retVal;\n                if (autoDisable)\n                    node.props.disabled = false;\n                node.store.remove('loading');\n            }\n        }\n        else {\n            if (submitEvent.target instanceof HTMLFormElement) {\n                submitEvent.target.submit();\n            }\n        }\n    }\n}\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nfunction form$1(node) {\n    node.props.isForm = true;\n    node.on('created', () => {\n        var _a;\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\n            node.context.handlers.submit = handleSubmit.bind(null, node);\n        }\n        if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(node.props, 'actions')) {\n            node.props.actions = true;\n        }\n    });\n    node.on('settled:blocking', () => node.store.remove('incomplete'));\n}\n\n/**\n * Creates a new feature that generates a localization message of type ui\n * for use on a given component.\n *\n * @param key - The key of the message\n * @param value - The value of the message\n * @returns\n * @public\n */\nfunction localize(key, value) {\n    return (node) => {\n        node.store.set((0,_formkit_core__WEBPACK_IMPORTED_MODULE_1__.createMessage)({\n            key,\n            type: 'ui',\n            value: value || key,\n            meta: {\n                localize: true,\n                i18nArgs: [node],\n            },\n        }));\n    };\n}\n\nconst isBrowser = typeof window !== 'undefined';\n/**\n * Remove the data-file-hover attribute from the target.\n * @param e - Event\n */\nfunction removeHover(e) {\n    if (e.target instanceof HTMLElement &&\n        e.target.hasAttribute('data-file-hover')) {\n        e.target.removeAttribute('data-file-hover');\n    }\n}\n/**\n * Prevent stray drag/drop events from navigating the window.\n * @param e - Event\n * @public\n */\nfunction preventStrayDrop(type, e) {\n    if (!(e.target instanceof HTMLInputElement)) {\n        e.preventDefault();\n    }\n    else if (type === 'dragover') {\n        e.target.setAttribute('data-file-hover', 'true');\n    }\n    if (type === 'drop') {\n        removeHover(e);\n    }\n}\nfunction files(node) {\n    // Localize our content:\n    localize('noFiles', 'Select file')(node);\n    localize('removeAll', 'Remove all')(node);\n    localize('remove')(node);\n    if (isBrowser) {\n        if (!window._FormKit_File_Drop) {\n            window.addEventListener('dragover', preventStrayDrop.bind(null, 'dragover'));\n            window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'));\n            window.addEventListener('dragleave', removeHover);\n            window._FormKit_File_Drop = true;\n        }\n    }\n    node.on('created', () => {\n        if (!Array.isArray(node.value)) {\n            node.input([], false);\n        }\n        if (!node.context)\n            return;\n        node.context.handlers.resetFiles = (e) => {\n            e.preventDefault();\n            node.input([]);\n            if (node.props.id && isBrowser) {\n                const el = document.getElementById(node.props.id);\n                if (el)\n                    el.value = '';\n            }\n        };\n        node.context.handlers.files = (e) => {\n            var _a, _b;\n            const files = [];\n            if (e.target instanceof HTMLInputElement && e.target.files) {\n                for (let i = 0; i < e.target.files.length; i++) {\n                    let file;\n                    if ((file = e.target.files.item(i))) {\n                        files.push({ name: file.name, file });\n                    }\n                }\n                node.input(files);\n            }\n            if (node.context)\n                node.context.files = files;\n            // Call the original listener if there is one.\n            if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {\n                (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);\n            }\n        };\n    });\n}\n\n/**\n * Applies ignore=\"true\" by default.\n * @param node - The node\n * @public\n */\nfunction ignore(node) {\n    if (node.props.ignore === undefined) {\n        node.props.ignore = true;\n        node.parent = null;\n    }\n}\n\nfunction initialValue(node) {\n    node.on('created', () => {\n        if (node.context) {\n            node.context.initialValue = node.value || '';\n        }\n    });\n}\n\n/**\n * Default classifications that are available.\n */\nconst textClassification = {\n    type: 'input',\n    schema: textSchema$1,\n};\n/**\n * The color input.\n * @public\n */\nconst color = textClassification;\n/**\n * The date input.\n * @public\n */\nconst date = textClassification;\n/**\n * The datetime-local input.\n * @public\n */\nconst datetimeLocal = textClassification;\n/**\n * The email input.\n * @public\n */\nconst email = textClassification;\n/**\n * The month input.\n * @public\n */\nconst month = textClassification;\n/**\n * The number input.\n * @public\n */\nconst number = textClassification;\n/**\n * The password input.\n * @public\n */\nconst password = textClassification;\n/**\n * The search input.\n * @public\n */\nconst search = textClassification;\n/**\n * The tel input.\n * @public\n */\nconst tel = textClassification;\n/**\n * The time input.\n * @public\n */\nconst time = textClassification;\n/**\n * The text input.\n * @public\n */\nconst text = textClassification;\n/**\n * The url input.\n * @public\n */\nconst url = textClassification;\n/**\n * The week input.\n * @public\n */\nconst week = textClassification;\n/**\n * The range input.\n * @public\n */\nconst range = textClassification;\n/**\n * The textarea input.\n * @public\n */\nconst textarea = {\n    type: 'input',\n    schema: textareaSchema,\n    features: [initialValue],\n};\n/**\n * Buttons are all this classification:\n */\nconst buttonClassification = {\n    type: 'input',\n    schema: buttonSchema,\n    features: [localize('submit'), ignore],\n};\n/**\n * The submit input.\n * @public\n */\nconst submit = buttonClassification;\n/**\n * The button classification.\n * @public\n */\nconst button = buttonClassification;\n/**\n * The hidden input.\n * @public\n */\nconst hidden = {\n    type: 'input',\n    schema: hiddenSchema,\n};\n/**\n * The select input type.\n * @public\n */\nconst select = {\n    type: 'input',\n    schema: textSchema,\n    props: ['options', 'placeholder'],\n    features: [options, select$1],\n};\n/**\n * The checkbox input type.\n * @public\n */\nconst checkbox = {\n    type: 'input',\n    schema: boxSchema,\n    props: ['options', 'onValue', 'offValue'],\n    features: [options, checkboxes],\n};\n/**\n * The radio input type.\n * @public\n */\nconst radio = {\n    type: 'input',\n    schema: boxSchema,\n    props: ['options'],\n    features: [options, radios],\n};\n/**\n * The group input type.\n * @public\n */\nconst group = {\n    type: 'group',\n    schema: groupSchema,\n    features: [disables],\n};\n/**\n * The form input type.\n * @public\n */\nconst form = {\n    type: 'group',\n    schema: formSchema,\n    props: [\n        'actions',\n        'submit',\n        'submitLabel',\n        'submitAttrs',\n        'submitBehavior',\n        'incompleteMessage',\n    ],\n    features: [form$1, disables],\n};\n/**\n * The list input type.\n * @public\n */\nconst list = {\n    type: 'list',\n    schema: listSchema,\n    features: [disables],\n};\n/**\n * The file input.\n * @public\n */\nconst file = {\n    type: 'input',\n    schema: fileSchema,\n    features: [files],\n    props: ['files'],\n};\n\nvar inputs = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    color: color,\n    date: date,\n    datetimeLocal: datetimeLocal,\n    email: email,\n    month: month,\n    number: number,\n    password: password,\n    search: search,\n    tel: tel,\n    time: time,\n    text: text,\n    url: url,\n    week: week,\n    range: range,\n    textarea: textarea,\n    submit: submit,\n    button: button,\n    hidden: hidden,\n    select: select,\n    checkbox: checkbox,\n    radio: radio,\n    group: group,\n    form: form,\n    list: list,\n    file: file\n});\n\n/**\n *\n * @param libraries - One or many formkit urls.\n * @returns\n * @public\n */\nfunction createLibraryPlugin(...libraries) {\n    /**\n     * Merge all provided library items.\n     */\n    const library = libraries.reduce((merged, lib) => (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.extend)(merged, lib), {});\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n    const plugin = () => { };\n    /**\n     * Enables the hook that exposes all library inputs.\n     * @param node - The primary plugin\n     */\n    plugin.library = function (node) {\n        const type = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.camel)(node.props.type);\n        if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(library, type)) {\n            node.define(library[type]);\n        }\n    };\n    return plugin;\n}\n\n/**\n * Export all features (#188):\n * @public\n */\nvar index = {\n    checkbox: checkboxes,\n    disables,\n    files,\n    form: form$1,\n    ignore,\n    initialValue,\n    localize,\n    normalizeBoxes,\n    options,\n    radios,\n    select: select$1,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvaW5wdXRzL2Rpc3QvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvaW5wdXRzL2Rpc3QvaW5kZXgubWpzP2QwYzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXh0ZW5kLCBjbG9uZSwgaXNQb2pvLCBlcSwgdW5kZWZpbmUsIGtlYmFiLCBoYXMsIGNhbWVsIH0gZnJvbSAnQGZvcm1raXQvdXRpbHMnO1xuaW1wb3J0IHsgd2FybiwgY3JlYXRlTWVzc2FnZSB9IGZyb20gJ0Bmb3Jta2l0L2NvcmUnO1xuXG5jb25zdCBvdXRlciA9IGNvbXBvc2FibGUoJ291dGVyJywgKCkgPT4gKHtcbiAgICAkZWw6ICdkaXYnLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIGNsYXNzOiAnJGNsYXNzZXMub3V0ZXInLFxuICAgICAgICAnZGF0YS10eXBlJzogJyR0eXBlJyxcbiAgICAgICAgJ2RhdGEtbXVsdGlwbGUnOiAnJGF0dHJzLm11bHRpcGxlJyxcbiAgICAgICAgJ2RhdGEtZGlzYWJsZWQnOiAnJGRpc2FibGVkIHx8IHVuZGVmaW5lZCcsXG4gICAgICAgICdkYXRhLWNvbXBsZXRlJzogJyRzdGF0ZS5jb21wbGV0ZSB8fCB1bmRlZmluZWQnLFxuICAgICAgICAnZGF0YS1pbnZhbGlkJzogJyRzdGF0ZS52YWxpZCA9PT0gZmFsc2UgJiYgJHN0YXRlLnZhbGlkYXRpb25WaXNpYmxlIHx8IHVuZGVmaW5lZCcsXG4gICAgICAgICdkYXRhLWVycm9ycyc6ICckc3RhdGUuZXJyb3JzIHx8IHVuZGVmaW5lZCcsXG4gICAgICAgICdkYXRhLXN1Ym1pdHRlZCc6ICckc3RhdGUuc3VibWl0dGVkIHx8IHVuZGVmaW5lZCcsXG4gICAgfSxcbn0pKTtcblxuY29uc3Qgd3JhcHBlciQyID0gY29tcG9zYWJsZSgnd3JhcHBlcicsICgpID0+ICh7XG4gICAgJGVsOiAnZGl2JyxcbiAgICBhdHRyczoge1xuICAgICAgICBjbGFzczogJyRjbGFzc2VzLndyYXBwZXInLFxuICAgIH0sXG59KSk7XG5cbmNvbnN0IGlubmVyID0gY29tcG9zYWJsZSgnaW5uZXInLCAoKSA9PiAoe1xuICAgICRlbDogJ2RpdicsXG4gICAgYXR0cnM6IHtcbiAgICAgICAgY2xhc3M6ICckY2xhc3Nlcy5pbm5lcicsXG4gICAgfSxcbn0pKTtcblxuY29uc3QgaGVscCA9IChzY2hlbWEgPSB7fSwgY2hpbGRyZW4gPSBbXSwgdGFyZ2V0ID0gJ2hlbHAnLCBjb25kID0gJyRoZWxwJykgPT4gKHtcbiAgICBpZjogYCRzbG90cy4ke3RhcmdldH1gLFxuICAgIHRoZW46IGAkc2xvdHMuJHt0YXJnZXR9YCxcbiAgICBlbHNlOiBleHRlbmQoe1xuICAgICAgICAkZWw6ICdkaXYnLFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaWQ6IGAkOiBcImhlbHAtXCIgKyAke3RhcmdldCA9PSAnb3B0aW9uSGVscCcgPyAnJG9wdGlvbi5hdHRycy5pZCcgOiAnJGlkJ31gLFxuICAgICAgICAgICAgY2xhc3M6IGAkY2xhc3Nlcy4ke3RhcmdldH1gLFxuICAgICAgICB9LFxuICAgICAgICBpZjogY29uZCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSwgc2NoZW1hKSxcbn0pO1xuXG5jb25zdCBtZXNzYWdlcyA9IGNvbXBvc2FibGUoJ21lc3NhZ2VzJywgKCkgPT4gKHtcbiAgICAkZWw6ICd1bCcsXG4gICAgaWY6ICckZm5zLmxlbmd0aCgkbWVzc2FnZXMpJyxcbiAgICBhdHRyczoge1xuICAgICAgICBjbGFzczogJyRjbGFzc2VzLm1lc3NhZ2VzJyxcbiAgICAgICAgJ2FyaWEtbGl2ZSc6ICckdHlwZSA9PT0gXCJmb3JtXCIgJiYgXCJhc3NlcnRpdmVcIiB8fCBcInBvbGl0ZVwiJyxcbiAgICB9LFxufSkpO1xuXG5jb25zdCBtZXNzYWdlID0gY29tcG9zYWJsZSgnbWVzc2FnZScsICgpID0+ICh7XG4gICAgJGVsOiAnbGknLFxuICAgIGZvcjogWydtZXNzYWdlJywgJyRtZXNzYWdlcyddLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIGtleTogJyRtZXNzYWdlLmtleScsXG4gICAgICAgIGNsYXNzOiAnJGNsYXNzZXMubWVzc2FnZScsXG4gICAgICAgIGlkOiBgJGlkICsgJy0nICsgJG1lc3NhZ2Uua2V5YCxcbiAgICAgICAgJ2RhdGEtbWVzc2FnZS10eXBlJzogJyRtZXNzYWdlLnR5cGUnLFxuICAgIH0sXG59KSk7XG5cbmNvbnN0IHByZWZpeCA9IGNvbXBvc2FibGUoJ3ByZWZpeCcsICgpID0+ICh7ICRlbDogbnVsbCB9KSk7XG5cbmNvbnN0IHN1ZmZpeCA9IGNvbXBvc2FibGUoJ3N1ZmZpeCcsICgpID0+ICh7ICRlbDogbnVsbCB9KSk7XG5cbi8qKlxuICogVHlwZSBndWFyZCBmb3Igc2NoZW1hIG9iamVjdHMuXG4gKiBAcGFyYW0gc2NoZW1hIC0gcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgc2NoZW1hIG5vZGUgYnV0IG5vdCBhIHN0cmluZyBvciBjb25kaXRpb25hbC5cbiAqL1xuZnVuY3Rpb24gaXNTY2hlbWFPYmplY3Qoc2NoZW1hKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAoJyRlbCcgaW4gc2NoZW1hIHx8ICckY21wJyBpbiBzY2hlbWEgfHwgJyRmb3Jta2l0JyBpbiBzY2hlbWEpKTtcbn1cbi8qKlxuICogRXh0ZW5kcyBhIHNpbmdsZSBzY2hlbWEgbm9kZSB3aXRoIGFuIGV4dGVuc2lvbi4gVGhlIGV4dGVuc2lvbiBjYW4gYmUgYW55IHBhcnRpYWwgbm9kZSBpbmNsdWRpbmcgc3RyaW5ncy5cbiAqIEBwYXJhbSBzY2hlbWEgLSBFeHRlbmQgYSBiYXNlIHNjaGVtYSBub2RlLlxuICogQHBhcmFtIGV4dGVuc2lvbiAtIFRoZSB2YWx1ZXMgdG8gZXh0ZW5kIG9uIHRoZSBiYXNlIHNjaGVtYSBub2RlLlxuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kU2NoZW1hKHNjaGVtYSwgZXh0ZW5zaW9uID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGlzU2NoZW1hT2JqZWN0KGV4dGVuc2lvbikgfHwgdHlwZW9mIGV4dGVuc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gZXh0ZW5zaW9uXG4gICAgICAgICAgICA6IHNjaGVtYTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBpc1NjaGVtYU9iamVjdChleHRlbnNpb24pID8gZXh0ZW5zaW9uIDogc2NoZW1hO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKHNjaGVtYSwgZXh0ZW5zaW9uKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzZWN0aW9uIGtleS5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gQSBuZXcgc2VjdGlvbiBrZXkgbmFtZS5cbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgZGVmYXVsdCBzY2hlbWEgaW4gdGhpcyBjb21wb3NhYmxlIHNsb3QuXG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb21wb3NhYmxlKGtleSwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIChleHRlbmRXaXRoID0ge30sIGNoaWxkcmVuID0gdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0eXBlb2Ygc2NoZW1hID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHNjaGVtYShjaGlsZHJlbilcbiAgICAgICAgICAgIDogdHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICA/IGNsb25lKHNjaGVtYSlcbiAgICAgICAgICAgICAgICA6IHNjaGVtYTtcbiAgICAgICAgY29uc3QgaXNPYmogPSBpc1NjaGVtYU9iamVjdChyb290KTtcbiAgICAgICAgaWYgKGlzT2JqICYmICEoJ2NoaWxkcmVuJyBpbiByb290KSAmJiBjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByb290LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdC5jaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ZW5kZWQgPSBleHRlbmRTY2hlbWEocm9vdCwgZXh0ZW5kV2l0aCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZjogYCRzbG90cy4ke2tleX1gLFxuICAgICAgICAgICAgdGhlbjogYCRzbG90cy4ke2tleX1gLFxuICAgICAgICAgICAgZWxzZTogQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF0sXG4gICAgICAgIH07XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnB1dCBzY2hlbWEgd2l0aCBhbGwgb2YgdGhlIHdyYXBwaW5nIGJhc2Ugc2NoZW1hLlxuICogQHBhcmFtIGlucHV0U2NoZW1hIC0gQ29udGVudCB0byBzdG9yZSBpbiB0aGUgaW5wdXQgc2VjdGlvbiBrZXkgbG9jYXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVNjaGVtYShpbnB1dFNjaGVtYSkge1xuICAgIHJldHVybiAoZXh0ZW5zaW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gY29tcG9zYWJsZSgnaW5wdXQnLCBpbnB1dFNjaGVtYSkoZXh0ZW5zaW9ucy5pbnB1dCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvdXRlcihleHRlbnNpb25zLm91dGVyLCBbXG4gICAgICAgICAgICAgICAgd3JhcHBlciQyKGV4dGVuc2lvbnMud3JhcHBlciwgW1xuICAgICAgICAgICAgICAgICAgICBsYWJlbChleHRlbnNpb25zLmxhYmVsLCAnJGxhYmVsJyksXG4gICAgICAgICAgICAgICAgICAgIGlubmVyKGV4dGVuc2lvbnMuaW5uZXIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeChleHRlbnNpb25zLnByZWZpeCksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4KGV4dGVuc2lvbnMuc3VmZml4KSxcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgaGVscChleHRlbnNpb25zLmhlbHAsICckaGVscCcpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzKGV4dGVuc2lvbnMubWVzc2FnZXMsIFtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZShleHRlbnNpb25zLm1lc3NhZ2UsICckbWVzc2FnZS52YWx1ZScpLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF07XG4gICAgfTtcbn1cblxuY29uc3QgbGFiZWwgPSBjb21wb3NhYmxlKCdsYWJlbCcsICgpID0+ICh7XG4gICAgJGVsOiAnbGFiZWwnLFxuICAgIGlmOiAnJGxhYmVsJyxcbiAgICBhdHRyczoge1xuICAgICAgICBmb3I6ICckaWQnLFxuICAgICAgICBjbGFzczogJyRjbGFzc2VzLmxhYmVsJyxcbiAgICB9LFxufSkpO1xuXG5jb25zdCB0ZXh0JDEgPSBjb21wb3NhYmxlKCdpbnB1dCcsICgpID0+ICh7XG4gICAgJGVsOiAnaW5wdXQnLFxuICAgIGJpbmQ6ICckYXR0cnMnLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIHR5cGU6ICckdHlwZScsXG4gICAgICAgIGRpc2FibGVkOiAnJGRpc2FibGVkJyxcbiAgICAgICAgY2xhc3M6ICckY2xhc3Nlcy5pbnB1dCcsXG4gICAgICAgIG5hbWU6ICckbm9kZS5uYW1lJyxcbiAgICAgICAgb25JbnB1dDogJyRoYW5kbGVycy5ET01JbnB1dCcsXG4gICAgICAgIG9uQmx1cjogJyRoYW5kbGVycy5ibHVyJyxcbiAgICAgICAgdmFsdWU6ICckX3ZhbHVlJyxcbiAgICAgICAgaWQ6ICckaWQnLFxuICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6ICckZGVzY3JpYmVkQnknLFxuICAgIH0sXG59KSk7XG5cbi8qKlxuICogVGhlIHNjaGVtYSBmb3IgdGV4dCBjbGFzc2lmaWNhdGlvbnMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHRleHRTY2hlbWEkMSA9IChleHRlbnNpb25zID0ge30pID0+IFtcbiAgICBvdXRlcihleHRlbnNpb25zLm91dGVyLCBbXG4gICAgICAgIHdyYXBwZXIkMihleHRlbnNpb25zLndyYXBwZXIsIFtcbiAgICAgICAgICAgIGxhYmVsKGV4dGVuc2lvbnMubGFiZWwsICckbGFiZWwnKSxcbiAgICAgICAgICAgIGlubmVyKGV4dGVuc2lvbnMuaW5uZXIsIFtcbiAgICAgICAgICAgICAgICBwcmVmaXgoZXh0ZW5zaW9ucy5wcmVmaXgpLFxuICAgICAgICAgICAgICAgIHRleHQkMShleHRlbnNpb25zLmlucHV0KSxcbiAgICAgICAgICAgICAgICBzdWZmaXgoZXh0ZW5zaW9ucy5zdWZmaXgpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF0pLFxuICAgICAgICBoZWxwKGV4dGVuc2lvbnMuaGVscCwgJyRoZWxwJyksXG4gICAgICAgIG1lc3NhZ2VzKGV4dGVuc2lvbnMubWVzc2FnZXMsIFtcbiAgICAgICAgICAgIG1lc3NhZ2UoZXh0ZW5zaW9ucy5tZXNzYWdlLCAnJG1lc3NhZ2UudmFsdWUnKSxcbiAgICAgICAgXSksXG4gICAgXSksXG5dO1xuXG5jb25zdCBmaWxlJDEgPSBjb21wb3NhYmxlKCdpbnB1dCcsICgpID0+ICh7XG4gICAgJGVsOiAnaW5wdXQnLFxuICAgIGJpbmQ6ICckYXR0cnMnLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgZm9vOiAnYmFyJyxcbiAgICAgICAgZGlzYWJsZWQ6ICckZGlzYWJsZWQnLFxuICAgICAgICBjbGFzczogJyRjbGFzc2VzLmlucHV0JyxcbiAgICAgICAgbmFtZTogJyRub2RlLm5hbWUnLFxuICAgICAgICBvbkNoYW5nZTogJyRoYW5kbGVycy5maWxlcycsXG4gICAgICAgIG9uQmx1cjogJyRoYW5kbGVycy5ibHVyJyxcbiAgICAgICAgaWQ6ICckaWQnLFxuICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6ICckZGVzY3JpYmVkQnknLFxuICAgIH0sXG59KSk7XG5cbmNvbnN0IGZpbGVMaXN0ID0gY29tcG9zYWJsZSgnZmlsZUxpc3QnLCAoKSA9PiAoe1xuICAgICRlbDogJ3VsJyxcbiAgICBpZjogJyR2YWx1ZS5sZW5ndGgnLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIGNsYXNzOiAnJGNsYXNzZXMuZmlsZUxpc3QnLFxuICAgICAgICAnZGF0YS1oYXMtbXVsdGlwbGUnOiB7XG4gICAgICAgICAgICBpZjogJyR2YWx1ZS5sZW5ndGggPiAxJyxcbiAgICAgICAgICAgIHRoZW46ICd0cnVlJyxcbiAgICAgICAgfSxcbiAgICB9LFxufSkpO1xuXG5jb25zdCBmaWxlSXRlbSA9IGNvbXBvc2FibGUoJ2ZpbGVJdGVtJywgKCkgPT4gKHtcbiAgICAkZWw6ICdsaScsXG4gICAgZm9yOiBbJ2ZpbGUnLCAnJHZhbHVlJ10sXG4gICAgYXR0cnM6IHtcbiAgICAgICAgY2xhc3M6ICckY2xhc3Nlcy5maWxlSXRlbScsXG4gICAgfSxcbn0pKTtcblxuY29uc3QgZmlsZU5hbWUgPSBjb21wb3NhYmxlKCdmaWxlTmFtZScsICgpID0+ICh7XG4gICAgJGVsOiAnc3BhbicsXG4gICAgYXR0cnM6IHtcbiAgICAgICAgY2xhc3M6ICckY2xhc3Nlcy5maWxlTmFtZScsXG4gICAgfSxcbn0pKTtcblxuY29uc3Qgbm9GaWxlcyA9IGNvbXBvc2FibGUoJ25vRmlsZXMnLCAoKSA9PiAoe1xuICAgICRlbDogJ3NwYW4nLFxuICAgIGlmOiAnJHZhbHVlLmxlbmd0aCA9PSAwJyxcbiAgICBhdHRyczoge1xuICAgICAgICBjbGFzczogJyRjbGFzc2VzLm5vRmlsZXMnLFxuICAgIH0sXG59KSk7XG5cbmNvbnN0IHJlbW92ZUZpbGVzID0gY29tcG9zYWJsZSgncmVtb3ZlRmlsZXMnLCAoKSA9PiAoe1xuICAgICRlbDogJ2EnLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIGhyZWY6ICcjJyxcbiAgICAgICAgY2xhc3M6ICckY2xhc3Nlcy5yZW1vdmVGaWxlcycsXG4gICAgICAgIG9uQ2xpY2s6ICckaGFuZGxlcnMucmVzZXRGaWxlcycsXG4gICAgfSxcbn0pKTtcblxuLyoqXG4gKiBUaGUgc2NoZW1hIGZvciB0ZXh0IGNsYXNzaWZpY2F0aW9ucy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZmlsZVNjaGVtYSA9IChleHRlbnNpb25zID0ge30pID0+IFtcbiAgICBvdXRlcihleHRlbnNpb25zLm91dGVyLCBbXG4gICAgICAgIHdyYXBwZXIkMihleHRlbnNpb25zLndyYXBwZXIsIFtcbiAgICAgICAgICAgIGxhYmVsKGV4dGVuc2lvbnMubGFiZWwsICckbGFiZWwnKSxcbiAgICAgICAgICAgIGlubmVyKGV4dGVuc2lvbnMuaW5uZXIsIFtcbiAgICAgICAgICAgICAgICBwcmVmaXgoZXh0ZW5zaW9ucy5wcmVmaXgpLFxuICAgICAgICAgICAgICAgIGZpbGUkMShleHRlbnNpb25zLmlucHV0KSxcbiAgICAgICAgICAgICAgICBmaWxlTGlzdChleHRlbnNpb25zLmZpbGVMaXN0LCBbXG4gICAgICAgICAgICAgICAgICAgIGZpbGVJdGVtKGV4dGVuc2lvbnMuZmlsZSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUoZXh0ZW5zaW9ucy5maWxlTmFtZSwgJyRmaWxlLm5hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZjogJyR2YWx1ZS5sZW5ndGggPT0gMScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbjogcmVtb3ZlRmlsZXMoZXh0ZW5zaW9ucy5yZW1vdmVGaWxlcywgJyR1aS5yZW1vdmUudmFsdWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWY6ICckdmFsdWUubGVuZ3RoID4gMScsXG4gICAgICAgICAgICAgICAgICAgIHRoZW46IHJlbW92ZUZpbGVzKGV4dGVuc2lvbnMucmVtb3ZlRmlsZXMsICckdWkucmVtb3ZlQWxsLnZhbHVlJyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBub0ZpbGVzKGV4dGVuc2lvbnMubm9GaWxlcywgJyR1aS5ub0ZpbGVzLnZhbHVlJyksXG4gICAgICAgICAgICAgICAgc3VmZml4KGV4dGVuc2lvbnMuc3VmZml4KSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICBdKSxcbiAgICAgICAgaGVscChleHRlbnNpb25zLmhlbHAsICckaGVscCcpLFxuICAgICAgICBtZXNzYWdlcyhleHRlbnNpb25zLm1lc3NhZ2VzLCBbXG4gICAgICAgICAgICBtZXNzYWdlKGV4dGVuc2lvbnMubWVzc2FnZSwgJyRtZXNzYWdlLnZhbHVlJyksXG4gICAgICAgIF0pLFxuICAgIF0pLFxuXTtcblxuY29uc3QgdGV4dGFyZWEkMSA9IGNvbXBvc2FibGUoJ2lucHV0JywgKCkgPT4gKHtcbiAgICAkZWw6ICd0ZXh0YXJlYScsXG4gICAgYmluZDogJyRhdHRycycsXG4gICAgYXR0cnM6IHtcbiAgICAgICAgY2xhc3M6ICckY2xhc3Nlcy5pbnB1dCcsXG4gICAgICAgIGRpc2FibGVkOiAnJGRpc2FibGVkJyxcbiAgICAgICAgbmFtZTogJyRub2RlLm5hbWUnLFxuICAgICAgICBvbklucHV0OiAnJGhhbmRsZXJzLkRPTUlucHV0JyxcbiAgICAgICAgb25CbHVyOiAnJGhhbmRsZXJzLmJsdXInLFxuICAgICAgICB2YWx1ZTogJyRfdmFsdWUnLFxuICAgICAgICBpZDogJyRpZCcsXG4gICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogJyRkZXNjcmliZWRCeScsXG4gICAgfSxcbiAgICBjaGlsZHJlbjogJyRpbml0aWFsVmFsdWUnLFxufSkpO1xuXG4vKipcbiAqIFRoZSBzY2hlbWEgZm9yIHRleHRhcmVhIGNsYXNzaWZpY2F0aW9ucy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdGV4dGFyZWFTY2hlbWEgPSAoZXh0ZW5zaW9ucyA9IHt9KSA9PiBbXG4gICAgb3V0ZXIoZXh0ZW5zaW9ucy5vdXRlciwgW1xuICAgICAgICB3cmFwcGVyJDIoZXh0ZW5zaW9ucy53cmFwcGVyLCBbXG4gICAgICAgICAgICBsYWJlbChleHRlbnNpb25zLmxhYmVsLCAnJGxhYmVsJyksXG4gICAgICAgICAgICBpbm5lcihleHRlbnNpb25zLmlubmVyLCBbXG4gICAgICAgICAgICAgICAgcHJlZml4KGV4dGVuc2lvbnMucHJlZml4KSxcbiAgICAgICAgICAgICAgICB0ZXh0YXJlYSQxKGV4dGVuc2lvbnMuaW5wdXQpLFxuICAgICAgICAgICAgICAgIHN1ZmZpeChleHRlbnNpb25zLnN1ZmZpeCksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgXSksXG4gICAgICAgIGhlbHAoZXh0ZW5zaW9ucy5oZWxwLCAnJGhlbHAnKSxcbiAgICAgICAgbWVzc2FnZXMoZXh0ZW5zaW9ucy5tZXNzYWdlcywgW1xuICAgICAgICAgICAgbWVzc2FnZShleHRlbnNpb25zLm1lc3NhZ2UsICckbWVzc2FnZS52YWx1ZScpLFxuICAgICAgICBdKSxcbiAgICBdKSxcbl07XG5cbi8qKlxuICogVGhlIHNjaGVtYSBmb3IgdGV4dCBjbGFzc2lmaWNhdGlvbnMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGhpZGRlblNjaGVtYSA9IChleHRlbnNpb25zID0ge30pID0+IFtcbiAgICB0ZXh0JDEoZXh0ZW5zaW9ucy5pbnB1dCksXG5dO1xuXG5jb25zdCBmcmFnbWVudCA9IChzY2hlbWEgPSB7fSwgY2hpbGRyZW4gPSBbXSkgPT4gKE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoIHx8IHR5cGVvZiBjaGlsZHJlbiAhPT0gJ3N0cmluZydcbiAgICA/IGV4dGVuZCh7ICRlbDogJ2RpdicsIGNoaWxkcmVuIH0sIHNjaGVtYSlcbiAgICA6IGNoaWxkcmVuKTtcblxuY29uc3QgZ3JvdXBTY2hlbWEgPSAoZXh0ZW5zaW9ucyA9IHt9KSA9PiB7XG4gICAgcmV0dXJuIFtmcmFnbWVudChleHRlbnNpb25zLndyYXBwZXIsICckc2xvdHMuZGVmYXVsdCcpXTtcbn07XG5cbmNvbnN0IGxpc3RTY2hlbWEgPSAoZXh0ZW5zaW9ucyA9IHt9KSA9PiB7XG4gICAgcmV0dXJuIFtmcmFnbWVudChleHRlbnNpb25zLndyYXBwZXIsICckc2xvdHMuZGVmYXVsdCcpXTtcbn07XG5cbmNvbnN0IHNlbGVjdCQyID0gY29tcG9zYWJsZSgnaW5wdXQnLCAoY2hpbGRyZW4pID0+ICh7XG4gICAgJGVsOiAnc2VsZWN0JyxcbiAgICBiaW5kOiAnJGF0dHJzJyxcbiAgICBhdHRyczoge1xuICAgICAgICBpZDogJyRpZCcsXG4gICAgICAgICdkYXRhLXBsYWNlaG9sZGVyJzoge1xuICAgICAgICAgICAgaWY6ICckcGxhY2Vob2xkZXInLFxuICAgICAgICAgICAgdGhlbjoge1xuICAgICAgICAgICAgICAgIGlmOiAnJHZhbHVlJyxcbiAgICAgICAgICAgICAgICB0aGVuOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZWxzZTogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZWQ6ICckZGlzYWJsZWQnLFxuICAgICAgICBjbGFzczogJyRjbGFzc2VzLmlucHV0JyxcbiAgICAgICAgbmFtZTogJyRub2RlLm5hbWUnLFxuICAgICAgICBvbklucHV0OiAnJGhhbmRsZXJzLnNlbGVjdElucHV0JyxcbiAgICAgICAgb25CbHVyOiAnJGhhbmRsZXJzLmJsdXInLFxuICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6ICckZGVzY3JpYmVkQnknLFxuICAgIH0sXG4gICAgY2hpbGRyZW46IHtcbiAgICAgICAgaWY6ICckc2xvdHMuZGVmYXVsdCcsXG4gICAgICAgIHRoZW46ICckc2xvdHMuZGVmYXVsdCcsXG4gICAgICAgIGVsc2U6IGNoaWxkcmVuLFxuICAgIH0sXG59KSk7XG5cbmNvbnN0IG9wdGlvbiA9IChzY2hlbWEgPSB7fSwgY2hpbGRyZW4gPSBbXSkgPT4gKHtcbiAgICBpZjogJyRzbG90cy5vcHRpb24nLFxuICAgIHRoZW46IFtcbiAgICAgICAge1xuICAgICAgICAgICAgJGVsOiAndGV4dCcsXG4gICAgICAgICAgICBpZjogJyRvcHRpb25zLmxlbmd0aCcsXG4gICAgICAgICAgICBmb3I6IFsnb3B0aW9uJywgJyRvcHRpb25zJ10sXG4gICAgICAgICAgICBjaGlsZHJlbjogJyRzbG90cy5vcHRpb24nLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgZWxzZTogZXh0ZW5kKHtcbiAgICAgICAgJGVsOiAnb3B0aW9uJyxcbiAgICAgICAgaWY6ICckb3B0aW9ucy5sZW5ndGgnLFxuICAgICAgICBmb3I6IFsnb3B0aW9uJywgJyRvcHRpb25zJ10sXG4gICAgICAgIGJpbmQ6ICckb3B0aW9uLmF0dHJzJyxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGNsYXNzOiAnJGNsYXNzZXMub3B0aW9uJyxcbiAgICAgICAgICAgIHZhbHVlOiAnJG9wdGlvbi52YWx1ZScsXG4gICAgICAgICAgICBzZWxlY3RlZDogJyRmbnMuaXNTZWxlY3RlZCgkb3B0aW9uLnZhbHVlKScsXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0sIHNjaGVtYSksXG59KTtcblxuLyoqXG4gKiBUaGUgc2NoZW1hIGZvciB0ZXh0IGNsYXNzaWZpY2F0aW9ucy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdGV4dFNjaGVtYSA9IChleHRlbnNpb25zID0ge30pID0+IFtcbiAgICBvdXRlcihleHRlbnNpb25zLm91dGVyLCBbXG4gICAgICAgIHdyYXBwZXIkMihleHRlbnNpb25zLndyYXBwZXIsIFtcbiAgICAgICAgICAgIGxhYmVsKGV4dGVuc2lvbnMubGFiZWwsICckbGFiZWwnKSxcbiAgICAgICAgICAgIGlubmVyKGV4dGVuc2lvbnMuaW5uZXIsIFtcbiAgICAgICAgICAgICAgICBwcmVmaXgoZXh0ZW5zaW9ucy5wcmVmaXgpLFxuICAgICAgICAgICAgICAgIHNlbGVjdCQyKGV4dGVuc2lvbnMuaW5wdXQsIFtvcHRpb24oZXh0ZW5zaW9ucy5vcHRpb24sICckb3B0aW9uLmxhYmVsJyldKSxcbiAgICAgICAgICAgICAgICBzdWZmaXgoZXh0ZW5zaW9ucy5zdWZmaXgpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF0pLFxuICAgICAgICBoZWxwKGV4dGVuc2lvbnMuaGVscCwgJyRoZWxwJyksXG4gICAgICAgIG1lc3NhZ2VzKGV4dGVuc2lvbnMubWVzc2FnZXMsIFtcbiAgICAgICAgICAgIG1lc3NhZ2UoZXh0ZW5zaW9ucy5tZXNzYWdlLCAnJG1lc3NhZ2UudmFsdWUnKSxcbiAgICAgICAgXSksXG4gICAgXSksXG5dO1xuXG5jb25zdCBib3hMYWJlbCA9IGNvbXBvc2FibGUoJ2xhYmVsJywgKGNoaWxkcmVuKSA9PiAoe1xuICAgICRlbDogJ3NwYW4nLFxuICAgIGlmOiB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnID8gY2hpbGRyZW4gOiAnJDogdHJ1ZScsXG4gICAgYXR0cnM6IHtcbiAgICAgICAgY2xhc3M6ICckY2xhc3Nlcy5sYWJlbCcsXG4gICAgfSxcbn0pKTtcblxuY29uc3Qgd3JhcHBlciQxID0gY29tcG9zYWJsZSgnd3JhcHBlcicsICgpID0+ICh7XG4gICAgJGVsOiAnbGFiZWwnLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIGNsYXNzOiAnJGNsYXNzZXMud3JhcHBlcicsXG4gICAgICAgICdkYXRhLWRpc2FibGVkJzoge1xuICAgICAgICAgICAgaWY6ICckb3B0aW9ucy5sZW5ndGgnLFxuICAgICAgICAgICAgdGhlbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZWxzZTogJyRkaXNhYmxlZCcsXG4gICAgICAgIH0sXG4gICAgfSxcbn0pKTtcblxuY29uc3QgYm94ID0gY29tcG9zYWJsZSgnaW5wdXQnLCAoKSA9PiAoe1xuICAgICRlbDogJ2lucHV0JyxcbiAgICBiaW5kOiAnJGF0dHJzJyxcbiAgICBhdHRyczoge1xuICAgICAgICB0eXBlOiAnJHR5cGUnLFxuICAgICAgICBjbGFzczogJyRjbGFzc2VzLmlucHV0JyxcbiAgICAgICAgbmFtZTogJyRub2RlLnByb3BzLmFsdE5hbWUgfHwgJG5vZGUubmFtZScsXG4gICAgICAgIGRpc2FibGVkOiAnJG9wdGlvbi5hdHRycy5kaXNhYmxlZCB8fCAkZGlzYWJsZWQnLFxuICAgICAgICBvbklucHV0OiAnJGhhbmRsZXJzLnRvZ2dsZUNoZWNrZWQnLFxuICAgICAgICBjaGVja2VkOiAnJGZucy5lcSgkX3ZhbHVlLCAkb25WYWx1ZSknLFxuICAgICAgICBvbkJsdXI6ICckaGFuZGxlcnMuYmx1cicsXG4gICAgICAgIHZhbHVlOiAnJDogdHJ1ZScsXG4gICAgICAgIGlkOiAnJGlkJyxcbiAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiB7XG4gICAgICAgICAgICBpZjogJyRvcHRpb25zLmxlbmd0aCcsXG4gICAgICAgICAgICB0aGVuOiB7XG4gICAgICAgICAgICAgICAgaWY6ICckb3B0aW9uLmhlbHAnLFxuICAgICAgICAgICAgICAgIHRoZW46ICckOiBcImhlbHAtXCIgKyAkb3B0aW9uLmF0dHJzLmlkJyxcbiAgICAgICAgICAgICAgICBlbHNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWxzZToge1xuICAgICAgICAgICAgICAgIGlmOiAnJGhlbHAnLFxuICAgICAgICAgICAgICAgIHRoZW46ICckOiBcImhlbHAtXCIgKyAkaWQnLFxuICAgICAgICAgICAgICAgIGVsc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pKTtcblxuY29uc3QgZmllbGRzZXQgPSBjb21wb3NhYmxlKCdmaWVsZHNldCcsICgpID0+ICh7XG4gICAgJGVsOiAnZmllbGRzZXQnLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIGlkOiAnJGlkJyxcbiAgICAgICAgY2xhc3M6ICckY2xhc3Nlcy5maWVsZHNldCcsXG4gICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5Jzoge1xuICAgICAgICAgICAgaWY6ICckaGVscCcsXG4gICAgICAgICAgICB0aGVuOiAnJDogXCJoZWxwLVwiICsgJGlkJyxcbiAgICAgICAgICAgIGVsc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICB9LFxufSkpO1xuXG5jb25zdCBsZWdlbmQgPSBjb21wb3NhYmxlKCdsZWdlbmQnLCAoKSA9PiAoe1xuICAgICRlbDogJ2xlZ2VuZCcsXG4gICAgaWY6ICckbGFiZWwnLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIGNsYXNzOiAnJGNsYXNzZXMubGVnZW5kJyxcbiAgICB9LFxufSkpO1xuXG5jb25zdCBib3hlcyA9IGNvbXBvc2FibGUoJ29wdGlvbicsICgpID0+ICh7XG4gICAgJGVsOiAnbGknLFxuICAgIGZvcjogWydvcHRpb24nLCAnJG9wdGlvbnMnXSxcbiAgICBhdHRyczoge1xuICAgICAgICBjbGFzczogJyRjbGFzc2VzLm9wdGlvbicsXG4gICAgICAgICdkYXRhLWRpc2FibGVkJzogJyRvcHRpb24uYXR0cnMuZGlzYWJsZWQgfHwgJGRpc2FibGVkJyxcbiAgICB9LFxufSkpO1xuXG5jb25zdCB3cmFwcGVyID0gY29tcG9zYWJsZSgnb3B0aW9ucycsICgpID0+ICh7XG4gICAgJGVsOiAndWwnLFxuICAgIGF0dHJzOiB7XG4gICAgICAgIGNsYXNzOiAnJGNsYXNzZXMub3B0aW9ucycsXG4gICAgfSxcbn0pKTtcblxuY29uc3QgZGVjb3JhdG9yID0gY29tcG9zYWJsZSgnZGVjb3JhdG9yJywgKCkgPT4gKHtcbiAgICAkZWw6ICdzcGFuJyxcbiAgICBhdHRyczoge1xuICAgICAgICBjbGFzczogJyRjbGFzc2VzLmRlY29yYXRvcicsXG4gICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgICB9LFxufSkpO1xuXG4vKipcbiAqIFRoZSBzY2hlbWEgZm9yIHRleHQgY2xhc3NpZmljYXRpb25zLlxuICogQHB1YmxpY1xuICovXG5jb25zdCBib3hTY2hlbWEgPSAoZXh0ZW5zaW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgc2luZ2xlQ2hlY2tib3ggPSBbXG4gICAgICAgIHdyYXBwZXIkMShleHRlbnNpb25zLndyYXBwZXIsIFtcbiAgICAgICAgICAgIGlubmVyKGV4dGVuc2lvbnMuaW5uZXIsIFtcbiAgICAgICAgICAgICAgICBwcmVmaXgoZXh0ZW5zaW9ucy5wcmVmaXgpLFxuICAgICAgICAgICAgICAgIGJveChleHRlbnNpb25zLmlucHV0KSxcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3IoZXh0ZW5zaW9ucy5kZWNvcmF0b3IpLFxuICAgICAgICAgICAgICAgIHN1ZmZpeChleHRlbnNpb25zLnN1ZmZpeCksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIGJveExhYmVsKGV4dGVuc2lvbnMubGFiZWwsICckbGFiZWwnKSxcbiAgICAgICAgXSksXG4gICAgICAgIGhlbHAoZXh0ZW5zaW9ucy5oZWxwLCAnJGhlbHAnKSxcbiAgICBdO1xuICAgIGNvbnN0IG11bHRpQ2hlY2tib3ggPSBmaWVsZHNldChleHRlbnNpb25zLmZpZWxkc2V0LCBbXG4gICAgICAgIGxlZ2VuZChleHRlbnNpb25zLmxlZ2VuZCwgJyRsYWJlbCcpLFxuICAgICAgICBoZWxwKGV4dGVuc2lvbnMuaGVscCwgJyRoZWxwJyksXG4gICAgICAgIHdyYXBwZXIoZXh0ZW5zaW9ucy5vcHRpb25zLCBbXG4gICAgICAgICAgICBib3hlcyhleHRlbnNpb25zLm9wdGlvbiwgW1xuICAgICAgICAgICAgICAgIHdyYXBwZXIkMShleHRlbnNpb25zLndyYXBwZXIsIFtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIoZXh0ZW5zaW9ucy5pbm5lciwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4KGV4dGVuc2lvbnMucHJlZml4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveChleHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmQ6ICckb3B0aW9uLmF0dHJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJyRvcHRpb24uYXR0cnMuaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJyRvcHRpb24udmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiAnJGZucy5pc0NoZWNrZWQoJG9wdGlvbi52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBleHRlbnNpb25zLmlucHV0IHx8IHt9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3IoZXh0ZW5zaW9ucy5kZWNvcmF0b3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4KGV4dGVuc2lvbnMuc3VmZml4KSxcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIGJveExhYmVsKGV4dGVuc2lvbnMubGFiZWwsICckb3B0aW9uLmxhYmVsJyksXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgaGVscChleHRlbnNpb25zLm9wdGlvbkhlbHAsICckb3B0aW9uLmhlbHAnLCAnb3B0aW9uSGVscCcsICckb3B0aW9uLmhlbHAnKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICBdKSxcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBvdXRlcihleHRlbnNpb25zLm91dGVyLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWY6ICckb3B0aW9ucy5sZW5ndGgnLFxuICAgICAgICAgICAgICAgIHRoZW46IG11bHRpQ2hlY2tib3gsXG4gICAgICAgICAgICAgICAgZWxzZTogc2luZ2xlQ2hlY2tib3gsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZXMoZXh0ZW5zaW9ucy5tZXNzYWdlcywgW1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UoZXh0ZW5zaW9ucy5tZXNzYWdlLCAnJG1lc3NhZ2UudmFsdWUnKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICBdKSxcbiAgICBdO1xufTtcblxuY29uc3QgYWN0aW9ucyA9IGNvbXBvc2FibGUoJ2FjdGlvbnMnLCAoKSA9PiAoe1xuICAgICRlbDogJ2RpdicsXG4gICAgaWY6ICckYWN0aW9ucycsXG4gICAgYXR0cnM6IHtcbiAgICAgICAgY2xhc3M6ICckY2xhc3Nlcy5hY3Rpb25zJyxcbiAgICB9LFxufSkpO1xuXG5jb25zdCBmb3JtJDIgPSBjb21wb3NhYmxlKCdmb3JtJywgKCkgPT4gKHtcbiAgICAkZWw6ICdmb3JtJyxcbiAgICBiaW5kOiAnJGF0dHJzJyxcbiAgICBhdHRyczoge1xuICAgICAgICBpZDogJyRpZCcsXG4gICAgICAgIGNsYXNzOiAnJGNsYXNzZXMuZm9ybScsXG4gICAgICAgIG5hbWU6ICckbm9kZS5uYW1lJyxcbiAgICAgICAgb25TdWJtaXQ6ICckaGFuZGxlcnMuc3VibWl0JyxcbiAgICAgICAgJ2RhdGEtbG9hZGluZyc6ICckc3RhdGUubG9hZGluZyB8fCB1bmRlZmluZWQnLFxuICAgIH0sXG59KSk7XG5cbmNvbnN0IHN1Ym1pdCQxID0gY29tcG9zYWJsZSgnc3VibWl0JywgKCkgPT4gKHtcbiAgICAkY21wOiAnRm9ybUtpdCcsXG4gICAgYmluZDogJyRzdWJtaXRBdHRycycsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgaWdub3JlOiB0cnVlLFxuICAgICAgICB0eXBlOiAnc3VibWl0JyxcbiAgICAgICAgZGlzYWJsZWQ6ICckZGlzYWJsZWQnLFxuICAgICAgICBsYWJlbDogJyRzdWJtaXRMYWJlbCcsXG4gICAgfSxcbn0pKTtcblxuY29uc3QgZm9ybVNjaGVtYSA9IChleHRlbnNpb25zID0ge30pID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgICBmb3JtJDIoZXh0ZW5zaW9ucy5mb3JtLCBbXG4gICAgICAgICAgICAnJHNsb3RzLmRlZmF1bHQnLFxuICAgICAgICAgICAgbWVzc2FnZXMoZXh0ZW5zaW9ucy5tZXNzYWdlcywgW1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UoZXh0ZW5zaW9ucy5tZXNzYWdlLCAnJG1lc3NhZ2UudmFsdWUnKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgYWN0aW9ucyhleHRlbnNpb25zLmFjdGlvbnMsIFtzdWJtaXQkMShleHRlbnNpb25zLnN1Ym1pdCldKSxcbiAgICAgICAgXSksXG4gICAgXTtcbn07XG5cbmNvbnN0IGJ1dHRvbiQxID0gY29tcG9zYWJsZSgnaW5wdXQnLCAoKSA9PiAoe1xuICAgICRlbDogJ2J1dHRvbicsXG4gICAgYmluZDogJyRhdHRycycsXG4gICAgYXR0cnM6IHtcbiAgICAgICAgdHlwZTogJyR0eXBlJyxcbiAgICAgICAgZGlzYWJsZWQ6ICckZGlzYWJsZWQnLFxuICAgICAgICBjbGFzczogJyRjbGFzc2VzLmlucHV0JyxcbiAgICAgICAgbmFtZTogJyRub2RlLm5hbWUnLFxuICAgICAgICBpZDogJyRpZCcsXG4gICAgfSxcbn0pKTtcblxuLyoqXG4gKiBUaGUgc2NoZW1hIGZvciB0ZXh0IGNsYXNzaWZpY2F0aW9ucy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgYnV0dG9uU2NoZW1hID0gKGV4dGVuc2lvbnMgPSB7fSkgPT4gW1xuICAgIG91dGVyKGV4dGVuc2lvbnMub3V0ZXIsIFtcbiAgICAgICAgbWVzc2FnZXMoZXh0ZW5zaW9ucy5tZXNzYWdlcywgW1xuICAgICAgICAgICAgbWVzc2FnZShleHRlbnNpb25zLm1lc3NhZ2UsICckbWVzc2FnZS52YWx1ZScpLFxuICAgICAgICBdKSxcbiAgICAgICAgd3JhcHBlciQyKGV4dGVuc2lvbnMud3JhcHBlciwgW1xuICAgICAgICAgICAgYnV0dG9uJDEoZXh0ZW5zaW9ucy5pbnB1dCwgW1xuICAgICAgICAgICAgICAgIHByZWZpeChleHRlbnNpb25zLnByZWZpeCksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZjogJyRzbG90cy5kZWZhdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgdGhlbjogJyRzbG90cy5kZWZhdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgZWxzZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWY6ICckbGFiZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbjogJyRsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlOiAnJHVpLnN1Ym1pdC52YWx1ZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWZmaXgoZXh0ZW5zaW9ucy5zdWZmaXgpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF0pLFxuICAgICAgICBoZWxwKGV4dGVuc2lvbnMuaGVscCwgJyRoZWxwJyksXG4gICAgXSksXG5dO1xuXG4vKipcbiAqIEFjY2VwdHMgYW4gYXJyYXkgb2Ygb2JqZWN0cywgYXJyYXkgb2Ygc3RyaW5ncywgb3Igb2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycy5cbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB2YWx1ZSBhbmQgbGFiZWwgcHJvcGVydGllcy5cbiAqIEBwYXJhbSBvcHRpb25zIC1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1hcCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9wdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogb3B0aW9uLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICgndmFsdWUnIGluIG9wdGlvbiAmJiB0eXBlb2Ygb3B0aW9uLnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGBfX21hc2tfJHtpKyt9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fb3JpZ2luYWw6IG9wdGlvbi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKS5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYWJlbDogb3B0aW9uc1t2YWx1ZV0sXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogR2l2ZW4gYW4gb3B0aW9uIGxpc3QsIGZpbmQgdGhlIFwidHJ1ZVwiIHZhbHVlIGluIHRoZSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjaGVjayBmb3IgYSBnaXZlbiB2YWx1ZVxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVyblxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gb3B0aW9uVmFsdWUob3B0aW9ucywgdmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gb3B0aW9uLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdfX29yaWdpbmFsJyBpbiBvcHRpb24gPyBvcHRpb24uX19vcmlnaW5hbCA6IG9wdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHZhbHVlIHNob3VsZCBiZSBzZWxlY3RlZC5cbiAqIEBwYXJhbSB2YWx1ZUEgLSBBbnkgdHlwZSBvZiB2YWx1ZVxuICogQHBhcmFtIHZhbHVlQiAtIEFueSB0eXBlIG9mIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNlbGVjdCh2YWx1ZUEsIHZhbHVlQikge1xuICAgIGlmICh2YWx1ZUEgPT0gdmFsdWVCKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNQb2pvKHZhbHVlQSkgJiYgaXNQb2pvKHZhbHVlQikpXG4gICAgICAgIHJldHVybiBlcSh2YWx1ZUEsIHZhbHVlQik7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgb3B0aW9ucyBwcm9wIHRvIHVzYWJsZSB2YWx1ZXMuXG4gKiBAcGFyYW0gbm9kZSAtIEEgZm9ybWtpdCBub2RlLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBvcHRpb25zKG5vZGUpIHtcbiAgICBub2RlLmhvb2sucHJvcCgocHJvcCwgbmV4dCkgPT4ge1xuICAgICAgICBpZiAocHJvcC5wcm9wID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKHByb3AudmFsdWUpO1xuICAgICAgICAgICAgcHJvcC52YWx1ZSA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQocHJvcCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgdGhlIGdpdmVuIG9wdGlvbiBzaG91bGQgaGF2ZSB0aGUgc2VsZWN0ZWQgYXR0cmlidXRlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSBiZWluZyBldmFsdWF0ZWQuXG4gKiBAcGFyYW0gb3B0aW9uIC0gVGhlIG9wdGlvbiB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXNTZWxlY3RlZChub2RlLCBvcHRpb24pIHtcbiAgICAvLyBIZXJlIHdlIHRyaWNrIHJlYWN0aXZpdHkgKGlmIGF0IHBsYXkpIHRvIHdhdGNoIHRoaXMgZnVuY3Rpb24uXG4gICAgbm9kZS5jb250ZXh0ICYmIG5vZGUuY29udGV4dC52YWx1ZTtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvblZhbHVlKG5vZGUucHJvcHMub3B0aW9ucywgb3B0aW9uKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShub2RlLl92YWx1ZSlcbiAgICAgICAgPyBub2RlLl92YWx1ZS5zb21lKChvcHRpb25BKSA9PiBzaG91bGRTZWxlY3Qob3B0aW9uQSwgdmFsdWUpKVxuICAgICAgICA6IChub2RlLnZhbHVlID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbikgfHwgc2hvdWxkU2VsZWN0KHZhbHVlLCBub2RlLl92YWx1ZSk7XG59XG4vKipcbiAqIFNlbGVjdCB0aGUgY29ycmVjdCB2YWx1ZXMuXG4gKiBAcGFyYW0gZSAtIFRoZSBpbnB1dCBldmVudCBlbWl0dGVkIGJ5IHRoZSBzZWxlY3QuXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdElucHV0KG5vZGUsIGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICBjb25zdCB2YWx1ZSA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJylcbiAgICAgICAgPyBBcnJheS5mcm9tKHRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcCgobykgPT4gb3B0aW9uVmFsdWUobm9kZS5wcm9wcy5vcHRpb25zLCBvLnZhbHVlKSlcbiAgICAgICAgOiBvcHRpb25WYWx1ZShub2RlLnByb3BzLm9wdGlvbnMsIHRhcmdldC52YWx1ZSk7XG4gICAgbm9kZS5pbnB1dCh2YWx1ZSk7XG59XG4vKipcbiAqIEFwcGVuZHMgYSBwbGFjZWhvbGRlciB0byB0aGUgb3B0aW9ucyBsaXN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIGxpc3RcbiAqIEBwYXJhbSBwbGFjZWhvbGRlciAtIEEgcGxhY2Vob2xkZXIgc3RyaW5nIHRvIGFwcGVuZFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlQbGFjZWhvbGRlcihvcHRpb25zLCBwbGFjZWhvbGRlcikge1xuICAgIGlmICghb3B0aW9ucy5zb21lKChvcHRpb24pID0+IG9wdGlvbi5hdHRycyAmJiBvcHRpb24uYXR0cnNbJ2RhdGEtaXMtcGxhY2Vob2xkZXInXSkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkYXRhLWlzLXBsYWNlaG9sZGVyJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBvcHRpb25zIHByb3AgdG8gdXNhYmxlIHZhbHVlcy5cbiAqIEBwYXJhbSBub2RlIC0gQSBmb3Jta2l0IG5vZGUuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdCQxKG5vZGUpIHtcbiAgICAvLyBTZXQgdGhlIGluaXRpYWwgdmFsdWUgb2YgYSBtdWx0aS1pbnB1dFxuICAgIG5vZGUub24oJ2NyZWF0ZWQnLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBpc011bHRpcGxlID0gdW5kZWZpbmUoKF9hID0gbm9kZS5wcm9wcy5hdHRycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm11bHRpcGxlKTtcbiAgICAgICAgaWYgKCFpc011bHRpcGxlICYmXG4gICAgICAgICAgICBub2RlLnByb3BzLnBsYWNlaG9sZGVyICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KG5vZGUucHJvcHMub3B0aW9ucykpIHtcbiAgICAgICAgICAgIG5vZGUuaG9vay5wcm9wKCh7IHByb3AsIHZhbHVlIH0sIG5leHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXBwbHlQbGFjZWhvbGRlcih2YWx1ZSwgbm9kZS5wcm9wcy5wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KHsgcHJvcCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUucHJvcHMub3B0aW9ucyA9IGFwcGx5UGxhY2Vob2xkZXIobm9kZS5wcm9wcy5vcHRpb25zLCBub2RlLnByb3BzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5wdXQoW10sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLmNvbnRleHQgJiYgIW5vZGUuY29udGV4dC5vcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlucHV0IGlzIChwcm9iYWJseSkgdXNpbmcgdGhlIGRlZmF1bHQgc2xvdCwgd2UgbmVlZCB0byBhZGQgYVxuICAgICAgICAgICAgLy8gXCJ2YWx1ZVwiIGF0dHJpYnV0ZSB0byBnZXQgYm91bmRcbiAgICAgICAgICAgIG5vZGUucHJvcHMuYXR0cnMgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLnByb3BzLmF0dHJzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUuX3ZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlLm9uKCdpbnB1dCcsICh7IHBheWxvYWQgfSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcHMuYXR0cnMgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLnByb3BzLmF0dHJzLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfYiA9IG5vZGUuY29udGV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICBub2RlLmNvbnRleHQuaGFuZGxlcnMuc2VsZWN0SW5wdXQgPSBzZWxlY3RJbnB1dC5iaW5kKG51bGwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2MgPSBub2RlLmNvbnRleHQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5mbnMpIHtcbiAgICAgICAgICAgIG5vZGUuY29udGV4dC5mbnMuaXNTZWxlY3RlZCA9IGlzU2VsZWN0ZWQuYmluZChudWxsLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG5vZGUuaG9vay5pbnB1dCgodmFsdWUsIG5leHQpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICghbm9kZS5wcm9wcy5wbGFjZWhvbGRlciAmJlxuICAgICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSgoX2EgPSBub2RlLnByb3BzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucykgJiZcbiAgICAgICAgICAgIG5vZGUucHJvcHMub3B0aW9ucy5sZW5ndGggJiZcbiAgICAgICAgICAgICF1bmRlZmluZSgoX2MgPSAoX2IgPSBub2RlLnByb3BzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYXR0cnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tdWx0aXBsZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICAnX19vcmlnaW5hbCcgaW4gbm9kZS5wcm9wcy5vcHRpb25zWzBdXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZS5wcm9wcy5vcHRpb25zWzBdLl9fb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlLnByb3BzLm9wdGlvbnNbMF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQodmFsdWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgYm94ZXMuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlXG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBub3JtYWxpemVCb3hlcyhub2RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wLCBuZXh0KSB7XG4gICAgICAgIGlmIChwcm9wLnByb3AgPT09ICdvcHRpb25zJyAmJiBBcnJheS5pc0FycmF5KHByb3AudmFsdWUpKSB7XG4gICAgICAgICAgICBwcm9wLnZhbHVlID0gcHJvcC52YWx1ZS5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBvcHRpb24uYXR0cnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZChvcHRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBgJHtub2RlLm5hbWV9LW9wdGlvbi0ke2tlYmFiKFN0cmluZyhvcHRpb24udmFsdWUpKX1gIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobm9kZS5wcm9wcy50eXBlID09PSAnY2hlY2tib3gnICYmICFBcnJheS5pc0FycmF5KG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNDcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5wdXQoW10sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUub24oJ2NyZWF0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmlucHV0KFtdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dChwcm9wKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgd2hlbiBhbiBpbnB1dCBpcyB0b2dnbGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSBiZWluZyB0b2dnbGVkXG4gKiBAcGFyYW0gZSAtIFRoZSBpbnB1dCBldmVuIHJlbGF0ZWQgdG8gdGhlIHRvZ2dsaW5nXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNoZWNrZWQkMShub2RlLCBlKSB7XG4gICAgY29uc3QgZWwgPSBlLnRhcmdldDtcbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQXJyYXkuaXNBcnJheShub2RlLnByb3BzLm9wdGlvbnMpXG4gICAgICAgICAgICA/IG9wdGlvblZhbHVlKG5vZGUucHJvcHMub3B0aW9ucywgZWwudmFsdWUpXG4gICAgICAgICAgICA6IGVsLnZhbHVlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlLnByb3BzLm9wdGlvbnMpICYmIG5vZGUucHJvcHMub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlLl92YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBhcnJheSB2YWx1ZSBzZXRcbiAgICAgICAgICAgICAgICBub2RlLmlucHV0KFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW5vZGUuX3ZhbHVlLnNvbWUoKGV4aXN0aW5nVmFsdWUpID0+IHNob3VsZFNlbGVjdCh2YWx1ZSwgZXhpc3RpbmdWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIG5vdCBpbiB0aGUgY3VycmVudCBzZXRcbiAgICAgICAgICAgICAgICBub2RlLmlucHV0KFsuLi5ub2RlLl92YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgZXF1aXZhbGVudCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBub2RlLmlucHV0KG5vZGUuX3ZhbHVlLmZpbHRlcigoZXhpc3RpbmdWYWx1ZSkgPT4gIXNob3VsZFNlbGVjdCh2YWx1ZSwgZXhpc3RpbmdWYWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pbnB1dChub2RlLnByb3BzLm9uVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pbnB1dChub2RlLnByb3BzLm9mZlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gb3B0aW9uIGlzIHByZXNlbnQgaW4gdGhlIG5vZGUgdmFsdWUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIGJlaW5nIGNoZWNrZWRcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiBhbnkgb3B0aW9uXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0NoZWNrZWQkMShub2RlLCB2YWx1ZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy8gV2UgbmVlZCB0byBmb3JjZSB2dWXigJlzIHJlYWN0aXZpdHkgdG8gcmVzcG9uZCB3aGVuIHRoZSB2YWx1ZSBpcyBydW46XG4gICAgKF9hID0gbm9kZS5jb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWU7XG4gICAgKF9iID0gbm9kZS5jb250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuX3ZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUuX3ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbm9kZS5fdmFsdWUuc29tZSgoZXhpc3RpbmdWYWx1ZSkgPT4gc2hvdWxkU2VsZWN0KG9wdGlvblZhbHVlKG5vZGUucHJvcHMub3B0aW9ucywgdmFsdWUpLCBleGlzdGluZ1ZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQWRkcyBjaGVja2JveCBzZWxlY3Rpb24gc3VwcG9ydFxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRoZSBmZWF0dXJlIGlzIGFkZGVkIHRvXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNoZWNrYm94ZXMobm9kZSkge1xuICAgIG5vZGUub24oJ2NyZWF0ZWQnLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoX2EgPSBub2RlLmNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVycykge1xuICAgICAgICAgICAgbm9kZS5jb250ZXh0LmhhbmRsZXJzLnRvZ2dsZUNoZWNrZWQgPSB0b2dnbGVDaGVja2VkJDEuYmluZChudWxsLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gbm9kZS5jb250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm5zKSB7XG4gICAgICAgICAgICBub2RlLmNvbnRleHQuZm5zLmlzQ2hlY2tlZCA9IGlzQ2hlY2tlZCQxLmJpbmQobnVsbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uZmlndXJlIG91ciBkZWZhdWx0IG9uVmFsdWUgYW5kIG9mZlZhbHVlXG4gICAgICAgIGlmICghaGFzKG5vZGUucHJvcHMsICdvblZhbHVlJykpXG4gICAgICAgICAgICBub2RlLnByb3BzLm9uVmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoIWhhcyhub2RlLnByb3BzLCAnb2ZmVmFsdWUnKSlcbiAgICAgICAgICAgIG5vZGUucHJvcHMub2ZmVmFsdWUgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBub2RlLmhvb2sucHJvcChub3JtYWxpemVCb3hlcyhub2RlKSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSByYWRpbyBidXR0b24gd2hlbiBjaGVja2VkLlxuICogQHBhcmFtIG5vZGUgLSBGb3JtS2l0Tm9kZVxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ2hlY2tlZChub2RlLCBldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIG5vZGUuaW5wdXQob3B0aW9uVmFsdWUobm9kZS5wcm9wcy5vcHRpb25zLCBldmVudC50YXJnZXQudmFsdWUpKTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdmFsdWUgYmVpbmcgY2hlY2tlZCBpcyB0aGUgY3VycmVudCB2YWx1ZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXNDaGVja2VkKG5vZGUsIHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvLyBXZSBuZWVkIHRvIGZvcmNlIHZ1ZeKAmXMgcmVhY3Rpdml0eSB0byByZXNwb25kIHdoZW4gdGhlIHZhbHVlIGlzIHJ1bjpcbiAgICAoX2EgPSBub2RlLmNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgICAoX2IgPSBub2RlLmNvbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5fdmFsdWU7XG4gICAgcmV0dXJuIHNob3VsZFNlbGVjdChvcHRpb25WYWx1ZShub2RlLnByb3BzLm9wdGlvbnMsIHZhbHVlKSwgbm9kZS5fdmFsdWUpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gcmFkaW8gaW5wdXQgaXMgYmVpbmcgZXZhbHVhdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgcmFkaW8gaW5wdXQgZ3JvdXAuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHJhZGlvcyhub2RlKSB7XG4gICAgbm9kZS5vbignY3JlYXRlZCcsICgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGUucHJvcHMub3B0aW9ucykpIHtcbiAgICAgICAgICAgIHdhcm4oMzUwLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9hID0gbm9kZS5jb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIG5vZGUuY29udGV4dC5oYW5kbGVycy50b2dnbGVDaGVja2VkID0gdG9nZ2xlQ2hlY2tlZC5iaW5kKG51bGwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2IgPSBub2RlLmNvbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mbnMpIHtcbiAgICAgICAgICAgIG5vZGUuY29udGV4dC5mbnMuaXNDaGVja2VkID0gaXNDaGVja2VkLmJpbmQobnVsbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBub2RlLmhvb2sucHJvcChub3JtYWxpemVCb3hlcyhub2RlKSk7XG59XG5cbi8qKlxuICogQWxsb3dzIGRpc2FibGluZyBjaGlsZHJlbiBvZiB0aGlzLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgRm9ybUtpdE5vZGUgb2YgdGhlIGZvcm0vZ3JvdXAvbGlzdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBkaXNhYmxlcyhub2RlKSB7XG4gICAgbm9kZS5vbignY3JlYXRlZCcsICgpID0+IHtcbiAgICAgICAgbm9kZS5wcm9wcy5kaXNhYmxlZCA9IHVuZGVmaW5lKG5vZGUucHJvcHMuZGlzYWJsZWQpO1xuICAgIH0pO1xuICAgIG5vZGUuaG9vay5wcm9wKCh7IHByb3AsIHZhbHVlIH0sIG5leHQpID0+IHtcbiAgICAgICAgdmFsdWUgPSBwcm9wID09PSAnZGlzYWJsZWQnID8gdW5kZWZpbmUodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIHJldHVybiBuZXh0KHsgcHJvcCwgdmFsdWUgfSk7XG4gICAgfSk7XG4gICAgbm9kZS5vbigncHJvcDpkaXNhYmxlZCcsICh7IHBheWxvYWQ6IHZhbHVlIH0pID0+IHtcbiAgICAgICAgbm9kZS5jb25maWcuZGlzYWJsZWQgPSB1bmRlZmluZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgbm9kZS5vbignY3JlYXRlZCcsICgpID0+IHtcbiAgICAgICAgbm9kZS5jb25maWcuZGlzYWJsZWQgPSB1bmRlZmluZShub2RlLnByb3BzLmRpc2FibGVkKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGhlIHN1Ym1pdCBldmVudC5cbiAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVN1Ym1pdChub2RlLCBzdWJtaXRFdmVudCkge1xuICAgIHN1Ym1pdEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgYXdhaXQgbm9kZS5zZXR0bGVkO1xuICAgIC8vIFNldCB0aGUgc3VibWl0dGVkIHN0YXRlIG9uIGFsbCBjaGlsZHJlblxuICAgIG5vZGUud2FsaygobikgPT4ge1xuICAgICAgICBuLnN0b3JlLnNldChjcmVhdGVNZXNzYWdlKHtcbiAgICAgICAgICAgIGtleTogJ3N1Ym1pdHRlZCcsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBub2RlLnByb3BzLm9uU3VibWl0UmF3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5vZGUucHJvcHMub25TdWJtaXRSYXcoc3VibWl0RXZlbnQsIG5vZGUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5sZWRnZXIudmFsdWUoJ2Jsb2NraW5nJykpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgc3RpbGwgYSBibG9ja2luZyBtZXNzYWdlIGluIHRoZSBzdG9yZS5cbiAgICAgICAgaWYgKG5vZGUucHJvcHMuaW5jb21wbGV0ZU1lc3NhZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnN0b3JlLnNldChjcmVhdGVNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBibG9ja2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAga2V5OiBgaW5jb21wbGV0ZWAsXG4gICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGl6ZTogbm9kZS5wcm9wcy5pbmNvbXBsZXRlTWVzc2FnZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBpMThuQXJnczogW3sgbm9kZSB9XSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd0FzTWVzc2FnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHR5cGU6ICd1aScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUucHJvcHMuaW5jb21wbGV0ZU1lc3NhZ2UgfHwgJ0Zvcm0gaW5jb21wbGV0ZS4nLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyBibG9ja2luZyBtZXNzYWdlc1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUucHJvcHMub25TdWJtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgb25TdWJtaXRcbiAgICAgICAgICAgIGNvbnN0IHJldFZhbCA9IG5vZGUucHJvcHMub25TdWJtaXQoY2xvbmUobm9kZS52YWx1ZSksIG5vZGUpO1xuICAgICAgICAgICAgaWYgKHJldFZhbCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRvRGlzYWJsZSA9IG5vZGUucHJvcHMuZGlzYWJsZWQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLnByb3BzLnN1Ym1pdEJlaGF2aW9yICE9PSAnbGl2ZSc7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9EaXNhYmxlKVxuICAgICAgICAgICAgICAgICAgICBub2RlLnByb3BzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0b3JlLnNldChjcmVhdGVNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnbG9hZGluZycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmV0VmFsO1xuICAgICAgICAgICAgICAgIGlmIChhdXRvRGlzYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wcm9wcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RvcmUucmVtb3ZlKCdsb2FkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3VibWl0RXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc3VibWl0RXZlbnQudGFyZ2V0LnN1Ym1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgb3B0aW9ucyBwcm9wIHRvIHVzYWJsZSB2YWx1ZXMuXG4gKiBAcGFyYW0gbm9kZSAtIEEgZm9ybWtpdCBub2RlLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBmb3JtJDEobm9kZSkge1xuICAgIG5vZGUucHJvcHMuaXNGb3JtID0gdHJ1ZTtcbiAgICBub2RlLm9uKCdjcmVhdGVkJywgKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSBub2RlLmNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVycykge1xuICAgICAgICAgICAgbm9kZS5jb250ZXh0LmhhbmRsZXJzLnN1Ym1pdCA9IGhhbmRsZVN1Ym1pdC5iaW5kKG51bGwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzKG5vZGUucHJvcHMsICdhY3Rpb25zJykpIHtcbiAgICAgICAgICAgIG5vZGUucHJvcHMuYWN0aW9ucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBub2RlLm9uKCdzZXR0bGVkOmJsb2NraW5nJywgKCkgPT4gbm9kZS5zdG9yZS5yZW1vdmUoJ2luY29tcGxldGUnKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmZWF0dXJlIHRoYXQgZ2VuZXJhdGVzIGEgbG9jYWxpemF0aW9uIG1lc3NhZ2Ugb2YgdHlwZSB1aVxuICogZm9yIHVzZSBvbiBhIGdpdmVuIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgbWVzc2FnZVxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBtZXNzYWdlXG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2NhbGl6ZShrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgIG5vZGUuc3RvcmUuc2V0KGNyZWF0ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdHlwZTogJ3VpJyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSB8fCBrZXksXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgbG9jYWxpemU6IHRydWUsXG4gICAgICAgICAgICAgICAgaTE4bkFyZ3M6IFtub2RlXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICB9O1xufVxuXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbi8qKlxuICogUmVtb3ZlIHRoZSBkYXRhLWZpbGUtaG92ZXIgYXR0cmlidXRlIGZyb20gdGhlIHRhcmdldC5cbiAqIEBwYXJhbSBlIC0gRXZlbnRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlSG92ZXIoZSkge1xuICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgICAgIGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1maWxlLWhvdmVyJykpIHtcbiAgICAgICAgZS50YXJnZXQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWZpbGUtaG92ZXInKTtcbiAgICB9XG59XG4vKipcbiAqIFByZXZlbnQgc3RyYXkgZHJhZy9kcm9wIGV2ZW50cyBmcm9tIG5hdmlnYXRpbmcgdGhlIHdpbmRvdy5cbiAqIEBwYXJhbSBlIC0gRXZlbnRcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcHJldmVudFN0cmF5RHJvcCh0eXBlLCBlKSB7XG4gICAgaWYgKCEoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdkcmFnb3ZlcicpIHtcbiAgICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLWZpbGUtaG92ZXInLCAndHJ1ZScpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2Ryb3AnKSB7XG4gICAgICAgIHJlbW92ZUhvdmVyKGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbGVzKG5vZGUpIHtcbiAgICAvLyBMb2NhbGl6ZSBvdXIgY29udGVudDpcbiAgICBsb2NhbGl6ZSgnbm9GaWxlcycsICdTZWxlY3QgZmlsZScpKG5vZGUpO1xuICAgIGxvY2FsaXplKCdyZW1vdmVBbGwnLCAnUmVtb3ZlIGFsbCcpKG5vZGUpO1xuICAgIGxvY2FsaXplKCdyZW1vdmUnKShub2RlKTtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIGlmICghd2luZG93Ll9Gb3JtS2l0X0ZpbGVfRHJvcCkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgcHJldmVudFN0cmF5RHJvcC5iaW5kKG51bGwsICdkcmFnb3ZlcicpKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgcHJldmVudFN0cmF5RHJvcC5iaW5kKG51bGwsICdkcm9wJykpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIHJlbW92ZUhvdmVyKTtcbiAgICAgICAgICAgIHdpbmRvdy5fRm9ybUtpdF9GaWxlX0Ryb3AgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGUub24oJ2NyZWF0ZWQnLCAoKSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgbm9kZS5pbnB1dChbXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5jb250ZXh0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBub2RlLmNvbnRleHQuaGFuZGxlcnMucmVzZXRGaWxlcyA9IChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBub2RlLmlucHV0KFtdKTtcbiAgICAgICAgICAgIGlmIChub2RlLnByb3BzLmlkICYmIGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5wcm9wcy5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsKVxuICAgICAgICAgICAgICAgICAgICBlbC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBub2RlLmNvbnRleHQuaGFuZGxlcnMuZmlsZXMgPSAoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gW107XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIGUudGFyZ2V0LmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLnRhcmdldC5maWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmaWxlID0gZS50YXJnZXQuZmlsZXMuaXRlbShpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goeyBuYW1lOiBmaWxlLm5hbWUsIGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5pbnB1dChmaWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZXh0KVxuICAgICAgICAgICAgICAgIG5vZGUuY29udGV4dC5maWxlcyA9IGZpbGVzO1xuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgb3JpZ2luYWwgbGlzdGVuZXIgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoKF9hID0gbm9kZS5wcm9wcy5hdHRycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uQ2hhbmdlKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIChfYiA9IG5vZGUucHJvcHMuYXR0cnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbkNoYW5nZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIGlnbm9yZT1cInRydWVcIiBieSBkZWZhdWx0LlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpZ25vcmUobm9kZSkge1xuICAgIGlmIChub2RlLnByb3BzLmlnbm9yZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUucHJvcHMuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbFZhbHVlKG5vZGUpIHtcbiAgICBub2RlLm9uKCdjcmVhdGVkJywgKCkgPT4ge1xuICAgICAgICBpZiAobm9kZS5jb250ZXh0KSB7XG4gICAgICAgICAgICBub2RlLmNvbnRleHQuaW5pdGlhbFZhbHVlID0gbm9kZS52YWx1ZSB8fCAnJztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIERlZmF1bHQgY2xhc3NpZmljYXRpb25zIHRoYXQgYXJlIGF2YWlsYWJsZS5cbiAqL1xuY29uc3QgdGV4dENsYXNzaWZpY2F0aW9uID0ge1xuICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgc2NoZW1hOiB0ZXh0U2NoZW1hJDEsXG59O1xuLyoqXG4gKiBUaGUgY29sb3IgaW5wdXQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGNvbG9yID0gdGV4dENsYXNzaWZpY2F0aW9uO1xuLyoqXG4gKiBUaGUgZGF0ZSBpbnB1dC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZGF0ZSA9IHRleHRDbGFzc2lmaWNhdGlvbjtcbi8qKlxuICogVGhlIGRhdGV0aW1lLWxvY2FsIGlucHV0LlxuICogQHB1YmxpY1xuICovXG5jb25zdCBkYXRldGltZUxvY2FsID0gdGV4dENsYXNzaWZpY2F0aW9uO1xuLyoqXG4gKiBUaGUgZW1haWwgaW5wdXQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGVtYWlsID0gdGV4dENsYXNzaWZpY2F0aW9uO1xuLyoqXG4gKiBUaGUgbW9udGggaW5wdXQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IG1vbnRoID0gdGV4dENsYXNzaWZpY2F0aW9uO1xuLyoqXG4gKiBUaGUgbnVtYmVyIGlucHV0LlxuICogQHB1YmxpY1xuICovXG5jb25zdCBudW1iZXIgPSB0ZXh0Q2xhc3NpZmljYXRpb247XG4vKipcbiAqIFRoZSBwYXNzd29yZCBpbnB1dC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgcGFzc3dvcmQgPSB0ZXh0Q2xhc3NpZmljYXRpb247XG4vKipcbiAqIFRoZSBzZWFyY2ggaW5wdXQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHNlYXJjaCA9IHRleHRDbGFzc2lmaWNhdGlvbjtcbi8qKlxuICogVGhlIHRlbCBpbnB1dC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdGVsID0gdGV4dENsYXNzaWZpY2F0aW9uO1xuLyoqXG4gKiBUaGUgdGltZSBpbnB1dC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdGltZSA9IHRleHRDbGFzc2lmaWNhdGlvbjtcbi8qKlxuICogVGhlIHRleHQgaW5wdXQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHRleHQgPSB0ZXh0Q2xhc3NpZmljYXRpb247XG4vKipcbiAqIFRoZSB1cmwgaW5wdXQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVybCA9IHRleHRDbGFzc2lmaWNhdGlvbjtcbi8qKlxuICogVGhlIHdlZWsgaW5wdXQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHdlZWsgPSB0ZXh0Q2xhc3NpZmljYXRpb247XG4vKipcbiAqIFRoZSByYW5nZSBpbnB1dC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgcmFuZ2UgPSB0ZXh0Q2xhc3NpZmljYXRpb247XG4vKipcbiAqIFRoZSB0ZXh0YXJlYSBpbnB1dC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdGV4dGFyZWEgPSB7XG4gICAgdHlwZTogJ2lucHV0JyxcbiAgICBzY2hlbWE6IHRleHRhcmVhU2NoZW1hLFxuICAgIGZlYXR1cmVzOiBbaW5pdGlhbFZhbHVlXSxcbn07XG4vKipcbiAqIEJ1dHRvbnMgYXJlIGFsbCB0aGlzIGNsYXNzaWZpY2F0aW9uOlxuICovXG5jb25zdCBidXR0b25DbGFzc2lmaWNhdGlvbiA9IHtcbiAgICB0eXBlOiAnaW5wdXQnLFxuICAgIHNjaGVtYTogYnV0dG9uU2NoZW1hLFxuICAgIGZlYXR1cmVzOiBbbG9jYWxpemUoJ3N1Ym1pdCcpLCBpZ25vcmVdLFxufTtcbi8qKlxuICogVGhlIHN1Ym1pdCBpbnB1dC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3Qgc3VibWl0ID0gYnV0dG9uQ2xhc3NpZmljYXRpb247XG4vKipcbiAqIFRoZSBidXR0b24gY2xhc3NpZmljYXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGJ1dHRvbiA9IGJ1dHRvbkNsYXNzaWZpY2F0aW9uO1xuLyoqXG4gKiBUaGUgaGlkZGVuIGlucHV0LlxuICogQHB1YmxpY1xuICovXG5jb25zdCBoaWRkZW4gPSB7XG4gICAgdHlwZTogJ2lucHV0JyxcbiAgICBzY2hlbWE6IGhpZGRlblNjaGVtYSxcbn07XG4vKipcbiAqIFRoZSBzZWxlY3QgaW5wdXQgdHlwZS5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3Qgc2VsZWN0ID0ge1xuICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgc2NoZW1hOiB0ZXh0U2NoZW1hLFxuICAgIHByb3BzOiBbJ29wdGlvbnMnLCAncGxhY2Vob2xkZXInXSxcbiAgICBmZWF0dXJlczogW29wdGlvbnMsIHNlbGVjdCQxXSxcbn07XG4vKipcbiAqIFRoZSBjaGVja2JveCBpbnB1dCB0eXBlLlxuICogQHB1YmxpY1xuICovXG5jb25zdCBjaGVja2JveCA9IHtcbiAgICB0eXBlOiAnaW5wdXQnLFxuICAgIHNjaGVtYTogYm94U2NoZW1hLFxuICAgIHByb3BzOiBbJ29wdGlvbnMnLCAnb25WYWx1ZScsICdvZmZWYWx1ZSddLFxuICAgIGZlYXR1cmVzOiBbb3B0aW9ucywgY2hlY2tib3hlc10sXG59O1xuLyoqXG4gKiBUaGUgcmFkaW8gaW5wdXQgdHlwZS5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgcmFkaW8gPSB7XG4gICAgdHlwZTogJ2lucHV0JyxcbiAgICBzY2hlbWE6IGJveFNjaGVtYSxcbiAgICBwcm9wczogWydvcHRpb25zJ10sXG4gICAgZmVhdHVyZXM6IFtvcHRpb25zLCByYWRpb3NdLFxufTtcbi8qKlxuICogVGhlIGdyb3VwIGlucHV0IHR5cGUuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGdyb3VwID0ge1xuICAgIHR5cGU6ICdncm91cCcsXG4gICAgc2NoZW1hOiBncm91cFNjaGVtYSxcbiAgICBmZWF0dXJlczogW2Rpc2FibGVzXSxcbn07XG4vKipcbiAqIFRoZSBmb3JtIGlucHV0IHR5cGUuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGZvcm0gPSB7XG4gICAgdHlwZTogJ2dyb3VwJyxcbiAgICBzY2hlbWE6IGZvcm1TY2hlbWEsXG4gICAgcHJvcHM6IFtcbiAgICAgICAgJ2FjdGlvbnMnLFxuICAgICAgICAnc3VibWl0JyxcbiAgICAgICAgJ3N1Ym1pdExhYmVsJyxcbiAgICAgICAgJ3N1Ym1pdEF0dHJzJyxcbiAgICAgICAgJ3N1Ym1pdEJlaGF2aW9yJyxcbiAgICAgICAgJ2luY29tcGxldGVNZXNzYWdlJyxcbiAgICBdLFxuICAgIGZlYXR1cmVzOiBbZm9ybSQxLCBkaXNhYmxlc10sXG59O1xuLyoqXG4gKiBUaGUgbGlzdCBpbnB1dCB0eXBlLlxuICogQHB1YmxpY1xuICovXG5jb25zdCBsaXN0ID0ge1xuICAgIHR5cGU6ICdsaXN0JyxcbiAgICBzY2hlbWE6IGxpc3RTY2hlbWEsXG4gICAgZmVhdHVyZXM6IFtkaXNhYmxlc10sXG59O1xuLyoqXG4gKiBUaGUgZmlsZSBpbnB1dC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZmlsZSA9IHtcbiAgICB0eXBlOiAnaW5wdXQnLFxuICAgIHNjaGVtYTogZmlsZVNjaGVtYSxcbiAgICBmZWF0dXJlczogW2ZpbGVzXSxcbiAgICBwcm9wczogWydmaWxlcyddLFxufTtcblxudmFyIGlucHV0cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGRhdGU6IGRhdGUsXG4gICAgZGF0ZXRpbWVMb2NhbDogZGF0ZXRpbWVMb2NhbCxcbiAgICBlbWFpbDogZW1haWwsXG4gICAgbW9udGg6IG1vbnRoLFxuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICB0ZWw6IHRlbCxcbiAgICB0aW1lOiB0aW1lLFxuICAgIHRleHQ6IHRleHQsXG4gICAgdXJsOiB1cmwsXG4gICAgd2Vlazogd2VlayxcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgdGV4dGFyZWE6IHRleHRhcmVhLFxuICAgIHN1Ym1pdDogc3VibWl0LFxuICAgIGJ1dHRvbjogYnV0dG9uLFxuICAgIGhpZGRlbjogaGlkZGVuLFxuICAgIHNlbGVjdDogc2VsZWN0LFxuICAgIGNoZWNrYm94OiBjaGVja2JveCxcbiAgICByYWRpbzogcmFkaW8sXG4gICAgZ3JvdXA6IGdyb3VwLFxuICAgIGZvcm06IGZvcm0sXG4gICAgbGlzdDogbGlzdCxcbiAgICBmaWxlOiBmaWxlXG59KTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGxpYnJhcmllcyAtIE9uZSBvciBtYW55IGZvcm1raXQgdXJscy5cbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxpYnJhcnlQbHVnaW4oLi4ubGlicmFyaWVzKSB7XG4gICAgLyoqXG4gICAgICogTWVyZ2UgYWxsIHByb3ZpZGVkIGxpYnJhcnkgaXRlbXMuXG4gICAgICovXG4gICAgY29uc3QgbGlicmFyeSA9IGxpYnJhcmllcy5yZWR1Y2UoKG1lcmdlZCwgbGliKSA9PiBleHRlbmQobWVyZ2VkLCBsaWIpLCB7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xuICAgIGNvbnN0IHBsdWdpbiA9ICgpID0+IHsgfTtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBob29rIHRoYXQgZXhwb3NlcyBhbGwgbGlicmFyeSBpbnB1dHMuXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgcHJpbWFyeSBwbHVnaW5cbiAgICAgKi9cbiAgICBwbHVnaW4ubGlicmFyeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjYW1lbChub2RlLnByb3BzLnR5cGUpO1xuICAgICAgICBpZiAoaGFzKGxpYnJhcnksIHR5cGUpKSB7XG4gICAgICAgICAgICBub2RlLmRlZmluZShsaWJyYXJ5W3R5cGVdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHBsdWdpbjtcbn1cblxuLyoqXG4gKiBFeHBvcnQgYWxsIGZlYXR1cmVzICgjMTg4KTpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIGluZGV4ID0ge1xuICAgIGNoZWNrYm94OiBjaGVja2JveGVzLFxuICAgIGRpc2FibGVzLFxuICAgIGZpbGVzLFxuICAgIGZvcm06IGZvcm0kMSxcbiAgICBpZ25vcmUsXG4gICAgaW5pdGlhbFZhbHVlLFxuICAgIGxvY2FsaXplLFxuICAgIG5vcm1hbGl6ZUJveGVzLFxuICAgIG9wdGlvbnMsXG4gICAgcmFkaW9zLFxuICAgIHNlbGVjdDogc2VsZWN0JDEsXG59O1xuXG5leHBvcnQgeyBidXR0b24sIGNoZWNrYm94LCBjb2xvciwgY29tcG9zYWJsZSwgY3JlYXRlTGlicmFyeVBsdWdpbiwgZGF0ZSwgZGF0ZXRpbWVMb2NhbCwgZW1haWwsIGV4dGVuZFNjaGVtYSwgaW5kZXggYXMgZmVhdHVyZXMsIGZpbGUsIGZvcm0sIGdyb3VwLCBoaWRkZW4sIGlucHV0cywgbGlzdCwgbG9jYWxpemUsIG1vbnRoLCBudW1iZXIsIHBhc3N3b3JkLCByYWRpbywgcmFuZ2UsIHNlYXJjaCwgc2VsZWN0LCBzdWJtaXQsIHRlbCwgdGV4dCwgdGV4dGFyZWEsIHRpbWUsIHVybCwgdXNlU2NoZW1hLCB3ZWVrIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formkit/inputs/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/@formkit/observer/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@formkit/observer/dist/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyListeners\": function() { return /* binding */ applyListeners; },\n/* harmony export */   \"createObserver\": function() { return /* binding */ createObserver; },\n/* harmony export */   \"diffDeps\": function() { return /* binding */ diffDeps; },\n/* harmony export */   \"isKilled\": function() { return /* binding */ isKilled; },\n/* harmony export */   \"removeListeners\": function() { return /* binding */ removeListeners; }\n/* harmony export */ });\n/* harmony import */ var _formkit_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formkit/utils */ \"./node_modules/@formkit/utils/dist/index.mjs\");\n/* harmony import */ var _formkit_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formkit/core */ \"./node_modules/@formkit/core/dist/index.mjs\");\n\n\n\n/**\n * A registry of all revoked observers.\n */\nconst revokedObservers = new WeakSet();\n/**\n * The FormKitNode to observe.\n * @param node - Any formkit node to observe.\n * @returns\n * @public\n */\nfunction createObserver(node, dependencies) {\n    // The dependencies touched during tracking\n    const deps = dependencies || Object.assign(new Map(), { active: false });\n    // A registry of event receipts returned by the event system\n    const receipts = new Map();\n    /**\n     * Simple function to add a dependency to the deps map.\n     * @param event - The name of the event type (like commit/input etc)\n     */\n    const addDependency = function (event) {\n        var _a;\n        if (!deps.active)\n            return;\n        if (!deps.has(node))\n            deps.set(node, new Set());\n        (_a = deps.get(node)) === null || _a === void 0 ? void 0 : _a.add(event);\n    };\n    /**\n     * Proxies the props of a node so we know which ones were messed with, could\n     * potentially be more generalized in the future if we want to support\n     * more sub-objects.\n     * @param props - The props object from a node\n     * @returns\n     */\n    const observeProps = function (props) {\n        return new Proxy(props, {\n            get(...args) {\n                typeof args[1] === 'string' && addDependency(`prop:${args[1]}`);\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Observes the FormKit ledger \"value\".\n     * @param ledger - A formkit ledger counter.\n     */\n    const observeLedger = function (ledger) {\n        return new Proxy(ledger, {\n            get(...args) {\n                if (args[1] === 'value') {\n                    return (key) => {\n                        addDependency(`count:${key}`);\n                        return ledger.value(key);\n                    };\n                }\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Return values from our observer proxy first pass through this function\n     * which gives us a chance to listen sub-dependencies and properties.\n     */\n    const observe = function (value, property) {\n        if ((0,_formkit_core__WEBPACK_IMPORTED_MODULE_1__.isNode)(value)) {\n            return createObserver(value, deps);\n        }\n        if (property === 'value')\n            addDependency('commit');\n        if (property === 'props')\n            return observeProps(value);\n        if (property === 'ledger')\n            return observeLedger(value);\n        return value;\n    };\n    /**\n     * The actual proxy object of the original node.\n     */\n    const { proxy: observed, revoke, } = Proxy.revocable(node, {\n        get(...args) {\n            switch (args[1]) {\n                case 'deps':\n                    return deps;\n                case 'watch':\n                    return (block) => watch(observed, block);\n                case 'observe':\n                    return () => {\n                        const old = new Map(deps);\n                        deps.clear();\n                        deps.active = true;\n                        return old;\n                    };\n                case 'stopObserve':\n                    return () => {\n                        const newDeps = new Map(deps);\n                        deps.active = false;\n                        return newDeps;\n                    };\n                case 'receipts':\n                    return receipts;\n                case 'kill':\n                    return () => {\n                        removeListeners(receipts);\n                        revokedObservers.add(args[2]);\n                        revoke();\n                    };\n            }\n            const value = Reflect.get(...args);\n            // If we're dealing with a function, we need to sub-call the function\n            // get that return value, and pass it through the same logic.\n            if (typeof value === 'function') {\n                return (...subArgs) => {\n                    const subValue = value(...subArgs);\n                    return observe(subValue, args[1]);\n                };\n            }\n            return observe(value, args[1]);\n        },\n    });\n    return observed;\n}\n/**\n * Given two maps (toAdd and toRemove) apply the dependencies as event listeners\n * on the underlying nodes.\n * @param node - The node to apply dependencies to\n * @param delta - The toAdd and toRemove dependency Maps\n * @public\n */\nfunction applyListeners(node, [toAdd, toRemove], callback) {\n    toAdd.forEach((events, depNode) => {\n        events.forEach((event) => {\n            node.receipts.has(depNode) || node.receipts.set(depNode, {});\n            node.receipts.set(depNode, Object.assign(node.receipts.get(depNode), {\n                [event]: depNode.on(event, callback),\n            }));\n        });\n    });\n    toRemove.forEach((events, depNode) => {\n        events.forEach((event) => {\n            if (node.receipts.has(depNode)) {\n                const nodeReceipts = node.receipts.get(depNode);\n                if (nodeReceipts && (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(nodeReceipts, event)) {\n                    depNode.off(nodeReceipts[event]);\n                    delete nodeReceipts[event];\n                    node.receipts.set(depNode, nodeReceipts);\n                }\n            }\n        });\n    });\n}\n/**\n * Remove all the receipts from the observed node and subtree.\n * @param receipts - The formkit observer receipts to remove\n * @public\n */\nfunction removeListeners(receipts) {\n    receipts.forEach((events, node) => {\n        for (const event in events) {\n            node.off(events[event]);\n        }\n    });\n}\n/**\n * Observes a chunk of code to dependencies, and then re-calls that chunk of\n * code when those dependencies are manipulated.\n * @param node - The node to observer\n * @param block - The block of code to observe\n * @public\n */\nasync function watch(node, block) {\n    const oldDeps = new Map(node.deps);\n    node.observe();\n    const res = block(node);\n    if (res instanceof Promise)\n        await res;\n    const newDeps = node.stopObserve();\n    applyListeners(node, diffDeps(oldDeps, newDeps), () => watch(node, block));\n}\n/**\n * Determines which nodes should be added as dependencies and which should be\n * removed.\n * @param previous - The previous watcher dependencies\n * @param current - The new/current watcher dependencies\n * @returns\n * @public\n */\nfunction diffDeps(previous, current) {\n    const toAdd = new Map();\n    const toRemove = new Map();\n    current.forEach((events, node) => {\n        if (!previous.has(node)) {\n            toAdd.set(node, events);\n        }\n        else {\n            const eventsToAdd = new Set();\n            const previousEvents = previous.get(node);\n            events.forEach((event) => !(previousEvents === null || previousEvents === void 0 ? void 0 : previousEvents.has(event)) && eventsToAdd.add(event));\n            toAdd.set(node, eventsToAdd);\n        }\n    });\n    previous.forEach((events, node) => {\n        if (!current.has(node)) {\n            toRemove.set(node, events);\n        }\n        else {\n            const eventsToRemove = new Set();\n            const newEvents = current.get(node);\n            events.forEach((event) => !(newEvents === null || newEvents === void 0 ? void 0 : newEvents.has(event)) && eventsToRemove.add(event));\n            toRemove.set(node, eventsToRemove);\n        }\n    });\n    return [toAdd, toRemove];\n}\n/**\n * Checks if the given noe is revoked.\n * @param node - Any observed node to check.\n * @returns\n * @public\n */\nfunction isKilled(node) {\n    return revokedObservers.has(node);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvb2JzZXJ2ZXIvZGlzdC9pbmRleC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWtpdC9vYnNlcnZlci9kaXN0L2luZGV4Lm1qcz8yMmEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhcyB9IGZyb20gJ0Bmb3Jta2l0L3V0aWxzJztcbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJ0Bmb3Jta2l0L2NvcmUnO1xuXG4vKipcbiAqIEEgcmVnaXN0cnkgb2YgYWxsIHJldm9rZWQgb2JzZXJ2ZXJzLlxuICovXG5jb25zdCByZXZva2VkT2JzZXJ2ZXJzID0gbmV3IFdlYWtTZXQoKTtcbi8qKlxuICogVGhlIEZvcm1LaXROb2RlIHRvIG9ic2VydmUuXG4gKiBAcGFyYW0gbm9kZSAtIEFueSBmb3Jta2l0IG5vZGUgdG8gb2JzZXJ2ZS5cbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKG5vZGUsIGRlcGVuZGVuY2llcykge1xuICAgIC8vIFRoZSBkZXBlbmRlbmNpZXMgdG91Y2hlZCBkdXJpbmcgdHJhY2tpbmdcbiAgICBjb25zdCBkZXBzID0gZGVwZW5kZW5jaWVzIHx8IE9iamVjdC5hc3NpZ24obmV3IE1hcCgpLCB7IGFjdGl2ZTogZmFsc2UgfSk7XG4gICAgLy8gQSByZWdpc3RyeSBvZiBldmVudCByZWNlaXB0cyByZXR1cm5lZCBieSB0aGUgZXZlbnQgc3lzdGVtXG4gICAgY29uc3QgcmVjZWlwdHMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIGZ1bmN0aW9uIHRvIGFkZCBhIGRlcGVuZGVuY3kgdG8gdGhlIGRlcHMgbWFwLlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0eXBlIChsaWtlIGNvbW1pdC9pbnB1dCBldGMpXG4gICAgICovXG4gICAgY29uc3QgYWRkRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZGVwcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghZGVwcy5oYXMobm9kZSkpXG4gICAgICAgICAgICBkZXBzLnNldChub2RlLCBuZXcgU2V0KCkpO1xuICAgICAgICAoX2EgPSBkZXBzLmdldChub2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZChldmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94aWVzIHRoZSBwcm9wcyBvZiBhIG5vZGUgc28gd2Uga25vdyB3aGljaCBvbmVzIHdlcmUgbWVzc2VkIHdpdGgsIGNvdWxkXG4gICAgICogcG90ZW50aWFsbHkgYmUgbW9yZSBnZW5lcmFsaXplZCBpbiB0aGUgZnV0dXJlIGlmIHdlIHdhbnQgdG8gc3VwcG9ydFxuICAgICAqIG1vcmUgc3ViLW9iamVjdHMuXG4gICAgICogQHBhcmFtIHByb3BzIC0gVGhlIHByb3BzIG9iamVjdCBmcm9tIGEgbm9kZVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgY29uc3Qgb2JzZXJ2ZVByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkocHJvcHMsIHtcbiAgICAgICAgICAgIGdldCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZ3NbMV0gPT09ICdzdHJpbmcnICYmIGFkZERlcGVuZGVuY3koYHByb3A6JHthcmdzWzFdfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCguLi5hcmdzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT2JzZXJ2ZXMgdGhlIEZvcm1LaXQgbGVkZ2VyIFwidmFsdWVcIi5cbiAgICAgKiBAcGFyYW0gbGVkZ2VyIC0gQSBmb3Jta2l0IGxlZGdlciBjb3VudGVyLlxuICAgICAqL1xuICAgIGNvbnN0IG9ic2VydmVMZWRnZXIgPSBmdW5jdGlvbiAobGVkZ2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkobGVkZ2VyLCB7XG4gICAgICAgICAgICBnZXQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzWzFdID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGREZXBlbmRlbmN5KGBjb3VudDoke2tleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWRnZXIudmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdmFsdWVzIGZyb20gb3VyIG9ic2VydmVyIHByb3h5IGZpcnN0IHBhc3MgdGhyb3VnaCB0aGlzIGZ1bmN0aW9uXG4gICAgICogd2hpY2ggZ2l2ZXMgdXMgYSBjaGFuY2UgdG8gbGlzdGVuIHN1Yi1kZXBlbmRlbmNpZXMgYW5kIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgY29uc3Qgb2JzZXJ2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVPYnNlcnZlcih2YWx1ZSwgZGVwcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5ID09PSAndmFsdWUnKVxuICAgICAgICAgICAgYWRkRGVwZW5kZW5jeSgnY29tbWl0Jyk7XG4gICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3Byb3BzJylcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlUHJvcHModmFsdWUpO1xuICAgICAgICBpZiAocHJvcGVydHkgPT09ICdsZWRnZXInKVxuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVMZWRnZXIodmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWN0dWFsIHByb3h5IG9iamVjdCBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICAgKi9cbiAgICBjb25zdCB7IHByb3h5OiBvYnNlcnZlZCwgcmV2b2tlLCB9ID0gUHJveHkucmV2b2NhYmxlKG5vZGUsIHtcbiAgICAgICAgZ2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJnc1sxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RlcHMnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwcztcbiAgICAgICAgICAgICAgICBjYXNlICd3YXRjaCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYmxvY2spID0+IHdhdGNoKG9ic2VydmVkLCBibG9jayk7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JzZXJ2ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBuZXcgTWFwKGRlcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlICdzdG9wT2JzZXJ2ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdEZXBzID0gbmV3IE1hcChkZXBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RGVwcztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlICdyZWNlaXB0cyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0cztcbiAgICAgICAgICAgICAgICBjYXNlICdraWxsJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycyhyZWNlaXB0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZva2VkT2JzZXJ2ZXJzLmFkZChhcmdzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCguLi5hcmdzKTtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGZ1bmN0aW9uLCB3ZSBuZWVkIHRvIHN1Yi1jYWxsIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgLy8gZ2V0IHRoYXQgcmV0dXJuIHZhbHVlLCBhbmQgcGFzcyBpdCB0aHJvdWdoIHRoZSBzYW1lIGxvZ2ljLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoLi4uc3ViQXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJWYWx1ZSA9IHZhbHVlKC4uLnN1YkFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZShzdWJWYWx1ZSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlKHZhbHVlLCBhcmdzWzFdKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gb2JzZXJ2ZWQ7XG59XG4vKipcbiAqIEdpdmVuIHR3byBtYXBzICh0b0FkZCBhbmQgdG9SZW1vdmUpIGFwcGx5IHRoZSBkZXBlbmRlbmNpZXMgYXMgZXZlbnQgbGlzdGVuZXJzXG4gKiBvbiB0aGUgdW5kZXJseWluZyBub2Rlcy5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYXBwbHkgZGVwZW5kZW5jaWVzIHRvXG4gKiBAcGFyYW0gZGVsdGEgLSBUaGUgdG9BZGQgYW5kIHRvUmVtb3ZlIGRlcGVuZGVuY3kgTWFwc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBhcHBseUxpc3RlbmVycyhub2RlLCBbdG9BZGQsIHRvUmVtb3ZlXSwgY2FsbGJhY2spIHtcbiAgICB0b0FkZC5mb3JFYWNoKChldmVudHMsIGRlcE5vZGUpID0+IHtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBub2RlLnJlY2VpcHRzLmhhcyhkZXBOb2RlKSB8fCBub2RlLnJlY2VpcHRzLnNldChkZXBOb2RlLCB7fSk7XG4gICAgICAgICAgICBub2RlLnJlY2VpcHRzLnNldChkZXBOb2RlLCBPYmplY3QuYXNzaWduKG5vZGUucmVjZWlwdHMuZ2V0KGRlcE5vZGUpLCB7XG4gICAgICAgICAgICAgICAgW2V2ZW50XTogZGVwTm9kZS5vbihldmVudCwgY2FsbGJhY2spLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB0b1JlbW92ZS5mb3JFYWNoKChldmVudHMsIGRlcE5vZGUpID0+IHtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5yZWNlaXB0cy5oYXMoZGVwTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUmVjZWlwdHMgPSBub2RlLnJlY2VpcHRzLmdldChkZXBOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVJlY2VpcHRzICYmIGhhcyhub2RlUmVjZWlwdHMsIGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBkZXBOb2RlLm9mZihub2RlUmVjZWlwdHNbZXZlbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGVSZWNlaXB0c1tldmVudF07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVjZWlwdHMuc2V0KGRlcE5vZGUsIG5vZGVSZWNlaXB0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmVtb3ZlIGFsbCB0aGUgcmVjZWlwdHMgZnJvbSB0aGUgb2JzZXJ2ZWQgbm9kZSBhbmQgc3VidHJlZS5cbiAqIEBwYXJhbSByZWNlaXB0cyAtIFRoZSBmb3Jta2l0IG9ic2VydmVyIHJlY2VpcHRzIHRvIHJlbW92ZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMocmVjZWlwdHMpIHtcbiAgICByZWNlaXB0cy5mb3JFYWNoKChldmVudHMsIG5vZGUpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBpbiBldmVudHMpIHtcbiAgICAgICAgICAgIG5vZGUub2ZmKGV2ZW50c1tldmVudF0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIE9ic2VydmVzIGEgY2h1bmsgb2YgY29kZSB0byBkZXBlbmRlbmNpZXMsIGFuZCB0aGVuIHJlLWNhbGxzIHRoYXQgY2h1bmsgb2ZcbiAqIGNvZGUgd2hlbiB0aG9zZSBkZXBlbmRlbmNpZXMgYXJlIG1hbmlwdWxhdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBvYnNlcnZlclxuICogQHBhcmFtIGJsb2NrIC0gVGhlIGJsb2NrIG9mIGNvZGUgdG8gb2JzZXJ2ZVxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiB3YXRjaChub2RlLCBibG9jaykge1xuICAgIGNvbnN0IG9sZERlcHMgPSBuZXcgTWFwKG5vZGUuZGVwcyk7XG4gICAgbm9kZS5vYnNlcnZlKCk7XG4gICAgY29uc3QgcmVzID0gYmxvY2sobm9kZSk7XG4gICAgaWYgKHJlcyBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgIGF3YWl0IHJlcztcbiAgICBjb25zdCBuZXdEZXBzID0gbm9kZS5zdG9wT2JzZXJ2ZSgpO1xuICAgIGFwcGx5TGlzdGVuZXJzKG5vZGUsIGRpZmZEZXBzKG9sZERlcHMsIG5ld0RlcHMpLCAoKSA9PiB3YXRjaChub2RlLCBibG9jaykpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIG5vZGVzIHNob3VsZCBiZSBhZGRlZCBhcyBkZXBlbmRlbmNpZXMgYW5kIHdoaWNoIHNob3VsZCBiZVxuICogcmVtb3ZlZC5cbiAqIEBwYXJhbSBwcmV2aW91cyAtIFRoZSBwcmV2aW91cyB3YXRjaGVyIGRlcGVuZGVuY2llc1xuICogQHBhcmFtIGN1cnJlbnQgLSBUaGUgbmV3L2N1cnJlbnQgd2F0Y2hlciBkZXBlbmRlbmNpZXNcbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRpZmZEZXBzKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgY29uc3QgdG9BZGQgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdG9SZW1vdmUgPSBuZXcgTWFwKCk7XG4gICAgY3VycmVudC5mb3JFYWNoKChldmVudHMsIG5vZGUpID0+IHtcbiAgICAgICAgaWYgKCFwcmV2aW91cy5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgIHRvQWRkLnNldChub2RlLCBldmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzVG9BZGQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0V2ZW50cyA9IHByZXZpb3VzLmdldChub2RlKTtcbiAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4gIShwcmV2aW91c0V2ZW50cyA9PT0gbnVsbCB8fCBwcmV2aW91c0V2ZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldmlvdXNFdmVudHMuaGFzKGV2ZW50KSkgJiYgZXZlbnRzVG9BZGQuYWRkKGV2ZW50KSk7XG4gICAgICAgICAgICB0b0FkZC5zZXQobm9kZSwgZXZlbnRzVG9BZGQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMuZm9yRWFjaCgoZXZlbnRzLCBub2RlKSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudC5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgIHRvUmVtb3ZlLnNldChub2RlLCBldmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudHMgPSBjdXJyZW50LmdldChub2RlKTtcbiAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4gIShuZXdFdmVudHMgPT09IG51bGwgfHwgbmV3RXZlbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdFdmVudHMuaGFzKGV2ZW50KSkgJiYgZXZlbnRzVG9SZW1vdmUuYWRkKGV2ZW50KSk7XG4gICAgICAgICAgICB0b1JlbW92ZS5zZXQobm9kZSwgZXZlbnRzVG9SZW1vdmUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFt0b0FkZCwgdG9SZW1vdmVdO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIG5vZSBpcyByZXZva2VkLlxuICogQHBhcmFtIG5vZGUgLSBBbnkgb2JzZXJ2ZWQgbm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzS2lsbGVkKG5vZGUpIHtcbiAgICByZXR1cm4gcmV2b2tlZE9ic2VydmVycy5oYXMobm9kZSk7XG59XG5cbmV4cG9ydCB7IGFwcGx5TGlzdGVuZXJzLCBjcmVhdGVPYnNlcnZlciwgZGlmZkRlcHMsIGlzS2lsbGVkLCByZW1vdmVMaXN0ZW5lcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formkit/observer/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/@formkit/rules/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@formkit/rules/dist/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"accepted\": function() { return /* binding */ accepted; },\n/* harmony export */   \"alpha\": function() { return /* binding */ alpha; },\n/* harmony export */   \"alpha_spaces\": function() { return /* binding */ alpha_spaces; },\n/* harmony export */   \"alphanumeric\": function() { return /* binding */ alphanumeric; },\n/* harmony export */   \"between\": function() { return /* binding */ between; },\n/* harmony export */   \"confirm\": function() { return /* binding */ confirm; },\n/* harmony export */   \"date_after\": function() { return /* binding */ date_after; },\n/* harmony export */   \"date_before\": function() { return /* binding */ date_before; },\n/* harmony export */   \"date_between\": function() { return /* binding */ date_between; },\n/* harmony export */   \"date_format\": function() { return /* binding */ date_format; },\n/* harmony export */   \"email\": function() { return /* binding */ email; },\n/* harmony export */   \"ends_with\": function() { return /* binding */ ends_with; },\n/* harmony export */   \"is\": function() { return /* binding */ is; },\n/* harmony export */   \"length\": function() { return /* binding */ length; },\n/* harmony export */   \"matches\": function() { return /* binding */ matches; },\n/* harmony export */   \"max\": function() { return /* binding */ max; },\n/* harmony export */   \"min\": function() { return /* binding */ min; },\n/* harmony export */   \"not\": function() { return /* binding */ not; },\n/* harmony export */   \"number\": function() { return /* binding */ number; },\n/* harmony export */   \"required\": function() { return /* binding */ required; },\n/* harmony export */   \"starts_with\": function() { return /* binding */ starts_with; },\n/* harmony export */   \"url\": function() { return /* binding */ url; }\n/* harmony export */ });\n/* harmony import */ var _formkit_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formkit/utils */ \"./node_modules/@formkit/utils/dist/index.mjs\");\n\n\n/**\n * Determine if the given input's value was should be considered \"accepted\".\n * @param context - The FormKitValidationContext\n * @public\n */\nconst accepted = function accepted({ value }) {\n    return ['yes', 'on', '1', 1, true, 'true'].includes(value);\n};\n\n/**\n * Determine if the given input's value is after a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after = function ({ value }, compare = false) {\n    const timestamp = Date.parse(compare || new Date());\n    const fieldValue = Date.parse(String(value));\n    return isNaN(fieldValue) ? false : fieldValue > timestamp;\n};\n\n/**\n * Determine if the given input's value is only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,\n        latin: /^[a-zA-Z]+$/,\n    };\n    const selectedSet = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value is only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha_spaces = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż ]+$/,\n        latin: /^[a-zA-Z ]+$/,\n    };\n    const selectedSet = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value is only alpha or numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alphanumeric = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z0-9À-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,\n        latin: /^[a-zA-Z0-9]+$/,\n    };\n    const selectedSet = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.has)(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value before a given date.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before = function ({ value }, compare = false) {\n    const timestamp = Date.parse(compare || new Date());\n    const fieldValue = Date.parse(String(value));\n    return isNaN(fieldValue) ? false : fieldValue < timestamp;\n};\n\n/**\n * Determine if the given input's value is between two other values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst between = function between({ value }, from, to) {\n    if (!isNaN(value) && !isNaN(from) && !isNaN(to)) {\n        const val = 1 * value;\n        from = Number(from);\n        to = Number(to);\n        const [a, b] = from <= to ? [from, to] : [to, from];\n        return val >= 1 * a && val <= 1 * b;\n    }\n    return false;\n};\n\nconst hasConfirm = /(_confirm(?:ed)?)$/;\n/**\n * Determine if the given input's value matches another input's value\n * @param context - The FormKitValidationContext\n * @public\n */\nconst confirm = function confirm(node, address, comparison = 'loose') {\n    var _a;\n    if (!address) {\n        address = hasConfirm.test(node.name)\n            ? node.name.replace(hasConfirm, '')\n            : `${node.name}_confirm`;\n    }\n    const foreignValue = (_a = node.at(address)) === null || _a === void 0 ? void 0 : _a.value;\n    return comparison === 'strict'\n        ? node.value === foreignValue\n        : node.value == foreignValue;\n};\n\n/**\n * Determine if the given input's value is between two other dates\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_between = function date_between({ value }, dateA, dateB) {\n    dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA);\n    dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB);\n    const compareTo = value instanceof Date ? value.getTime() : Date.parse(String(value));\n    if (dateA && !dateB) {\n        dateB = dateA;\n        dateA = Date.now();\n    }\n    else if (!dateA || !compareTo) {\n        return false;\n    }\n    return compareTo >= dateA && compareTo <= dateB;\n};\n\n/**\n * Determine if the given input's value matches a specified date format\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_format = function date({ value }, format) {\n    if (format && typeof format === 'string') {\n        return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.regexForFormat)(format).test(String(value));\n    }\n    return !isNaN(Date.parse(String(value)));\n};\n\n/**\n * Determine if the given input's value is a plausible email address.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst email = function email({ value }) {\n    const isEmail = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n    return isEmail.test(String(value));\n};\n\n/**\n * Determine if the given input's value ends with a given string\n * @param context - The FormKitValidationContext\n * @public\n */\nconst ends_with = function ends_with({ value }, ...stack) {\n    if (typeof value === 'string' && stack.length) {\n        return stack.some((item) => {\n            return value.endsWith(item);\n        });\n    }\n    else if (typeof value === 'string' && stack.length === 0) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value is in a set of possible values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst is = function is({ value }, ...stack) {\n    return stack.some((item) => {\n        if (typeof item === 'object') {\n            return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.eq)(item, value);\n        }\n        return item == value;\n    });\n};\n\n/**\n * Determine if the given input's value length is full width.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst length = function length({ value }, first = 0, second = Infinity) {\n    first = parseInt(first);\n    second = isNaN(parseInt(second)) ? Infinity : parseInt(second);\n    const min = first <= second ? first : second;\n    const max = second >= first ? second : first;\n    if (typeof value === 'string' || Array.isArray(value)) {\n        return value.length >= min && value.length <= max;\n    }\n    else if (value && typeof value === 'object') {\n        const length = Object.keys(value).length;\n        return length >= min && length <= max;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value matches one or more values or regular expressions.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst matches = function matches({ value }, ...stack) {\n    return stack.some((pattern) => {\n        if (typeof pattern === 'string' &&\n            pattern.substr(0, 1) === '/' &&\n            pattern.substr(-1) === '/') {\n            pattern = new RegExp(pattern.substr(1, pattern.length - 2));\n        }\n        if (pattern instanceof RegExp) {\n            return pattern.test(String(value));\n        }\n        return pattern === value;\n    });\n};\n\n/**\n * Determine if the given input's value is less than the maximum\n * @param context - The FormKitValidationContext\n * @public\n */\nconst max = function max({ value }, maximum = 10) {\n    if (Array.isArray(value)) {\n        return value.length <= maximum;\n    }\n    return Number(value) <= Number(maximum);\n};\n\n/**\n * Determine if the given input's value is less than a certain value.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst min = function min({ value }, minimum = 1) {\n    if (Array.isArray(value)) {\n        return value.length >= minimum;\n    }\n    return Number(value) >= Number(minimum);\n};\n\n/**\n * Determine if the given input's value is not in a given stack\n * @param context - The FormKitValidationContext\n * @public\n */\nconst not = function not({ value }, ...stack) {\n    return !stack.some((item) => {\n        if (typeof item === 'object') {\n            return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.eq)(item, value);\n        }\n        return item === value;\n    });\n};\n\n/**\n * Determine if the given input's value is numeric\n * @param context - The FormKitValidationContext\n * @public\n */\nconst number = function number({ value }) {\n    return !isNaN(value);\n};\n\n/**\n * Determine if the given input's value was required.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst required = function required({ value }, action = 'default') {\n    return action === 'trim' && typeof value === 'string'\n        ? !(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.empty)(value.trim())\n        : !(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_0__.empty)(value);\n};\n/**\n * This rules should run even if the inputs is empty (obviously)\n */\nrequired.skipEmpty = false;\n\n/**\n * Determine if the given input's value starts with a substring\n * @param context - The FormKitValidationContext\n * @public\n */\nconst starts_with = function starts_with({ value }, ...stack) {\n    if (typeof value === 'string' && stack.length) {\n        return stack.some((item) => {\n            return value.startsWith(item);\n        });\n    }\n    else if (typeof value === 'string' && stack.length === 0) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value is an http url\n * @param context - The FormKitValidationContext\n * @public\n */\nconst url = function url({ value }, ...stack) {\n    try {\n        const protocols = stack.length ? stack : ['http:', 'https:'];\n        const url = new URL(String(value));\n        return protocols.includes(url.protocol);\n    }\n    catch {\n        return false;\n    }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvcnVsZXMvZGlzdC9pbmRleC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWtpdC9ydWxlcy9kaXN0L2luZGV4Lm1qcz84NTYzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhcywgcmVnZXhGb3JGb3JtYXQsIGVxLCBlbXB0eSB9IGZyb20gJ0Bmb3Jta2l0L3V0aWxzJztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIGlucHV0J3MgdmFsdWUgd2FzIHNob3VsZCBiZSBjb25zaWRlcmVkIFwiYWNjZXB0ZWRcIi5cbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIEZvcm1LaXRWYWxpZGF0aW9uQ29udGV4dFxuICogQHB1YmxpY1xuICovXG5jb25zdCBhY2NlcHRlZCA9IGZ1bmN0aW9uIGFjY2VwdGVkKHsgdmFsdWUgfSkge1xuICAgIHJldHVybiBbJ3llcycsICdvbicsICcxJywgMSwgdHJ1ZSwgJ3RydWUnXS5pbmNsdWRlcyh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gaW5wdXQncyB2YWx1ZSBpcyBhZnRlciBhIGdpdmVuIGRhdGUuXG4gKiBEZWZhdWx0cyB0byBjdXJyZW50IHRpbWUuXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBGb3JtS2l0VmFsaWRhdGlvbkNvbnRleHRcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZGF0ZV9hZnRlciA9IGZ1bmN0aW9uICh7IHZhbHVlIH0sIGNvbXBhcmUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUucGFyc2UoY29tcGFyZSB8fCBuZXcgRGF0ZSgpKTtcbiAgICBjb25zdCBmaWVsZFZhbHVlID0gRGF0ZS5wYXJzZShTdHJpbmcodmFsdWUpKTtcbiAgICByZXR1cm4gaXNOYU4oZmllbGRWYWx1ZSkgPyBmYWxzZSA6IGZpZWxkVmFsdWUgPiB0aW1lc3RhbXA7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gaW5wdXQncyB2YWx1ZSBpcyBvbmx5IGFscGhhIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBGb3JtS2l0VmFsaWRhdGlvbkNvbnRleHRcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgYWxwaGEgPSBmdW5jdGlvbiAoeyB2YWx1ZSB9LCBzZXQgPSAnZGVmYXVsdCcpIHtcbiAgICBjb25zdCBzZXRzID0ge1xuICAgICAgICBkZWZhdWx0OiAvXlthLXpBLVrDgC3DlsOYLcO2w7gtw7/EhMSFxIbEh8SYxJnFgcWCxYPFhMWaxZvFucW6xbvFvF0rJC8sXG4gICAgICAgIGxhdGluOiAvXlthLXpBLVpdKyQvLFxuICAgIH07XG4gICAgY29uc3Qgc2VsZWN0ZWRTZXQgPSBoYXMoc2V0cywgc2V0KSA/IHNldCA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gc2V0c1tzZWxlY3RlZFNldF0udGVzdChTdHJpbmcodmFsdWUpKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBpbnB1dCdzIHZhbHVlIGlzIG9ubHkgYWxwaGEgY2hhcmFjdGVycy5cbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIEZvcm1LaXRWYWxpZGF0aW9uQ29udGV4dFxuICogQHB1YmxpY1xuICovXG5jb25zdCBhbHBoYV9zcGFjZXMgPSBmdW5jdGlvbiAoeyB2YWx1ZSB9LCBzZXQgPSAnZGVmYXVsdCcpIHtcbiAgICBjb25zdCBzZXRzID0ge1xuICAgICAgICBkZWZhdWx0OiAvXlthLXpBLVrDgC3DlsOYLcO2w7gtw7/EhMSFxIbEh8SYxJnFgcWCxYPFhMWaxZvFucW6xbvFvCBdKyQvLFxuICAgICAgICBsYXRpbjogL15bYS16QS1aIF0rJC8sXG4gICAgfTtcbiAgICBjb25zdCBzZWxlY3RlZFNldCA9IGhhcyhzZXRzLCBzZXQpID8gc2V0IDogJ2RlZmF1bHQnO1xuICAgIHJldHVybiBzZXRzW3NlbGVjdGVkU2V0XS50ZXN0KFN0cmluZyh2YWx1ZSkpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIGlucHV0J3MgdmFsdWUgaXMgb25seSBhbHBoYSBvciBudW1lcmljIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBGb3JtS2l0VmFsaWRhdGlvbkNvbnRleHRcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgYWxwaGFudW1lcmljID0gZnVuY3Rpb24gKHsgdmFsdWUgfSwgc2V0ID0gJ2RlZmF1bHQnKSB7XG4gICAgY29uc3Qgc2V0cyA9IHtcbiAgICAgICAgZGVmYXVsdDogL15bYS16QS1aMC05w4Atw5bDmC3DtsO4LcO/xITEhcSGxIfEmMSZxYHFgsWDxYTFmsWbxbnFusW7xbxdKyQvLFxuICAgICAgICBsYXRpbjogL15bYS16QS1aMC05XSskLyxcbiAgICB9O1xuICAgIGNvbnN0IHNlbGVjdGVkU2V0ID0gaGFzKHNldHMsIHNldCkgPyBzZXQgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIHNldHNbc2VsZWN0ZWRTZXRdLnRlc3QoU3RyaW5nKHZhbHVlKSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gaW5wdXQncyB2YWx1ZSBiZWZvcmUgYSBnaXZlbiBkYXRlLlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgRm9ybUtpdFZhbGlkYXRpb25Db250ZXh0XG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGRhdGVfYmVmb3JlID0gZnVuY3Rpb24gKHsgdmFsdWUgfSwgY29tcGFyZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5wYXJzZShjb21wYXJlIHx8IG5ldyBEYXRlKCkpO1xuICAgIGNvbnN0IGZpZWxkVmFsdWUgPSBEYXRlLnBhcnNlKFN0cmluZyh2YWx1ZSkpO1xuICAgIHJldHVybiBpc05hTihmaWVsZFZhbHVlKSA/IGZhbHNlIDogZmllbGRWYWx1ZSA8IHRpbWVzdGFtcDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBpbnB1dCdzIHZhbHVlIGlzIGJldHdlZW4gdHdvIG90aGVyIHZhbHVlcy5cbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIEZvcm1LaXRWYWxpZGF0aW9uQ29udGV4dFxuICogQHB1YmxpY1xuICovXG5jb25zdCBiZXR3ZWVuID0gZnVuY3Rpb24gYmV0d2Vlbih7IHZhbHVlIH0sIGZyb20sIHRvKSB7XG4gICAgaWYgKCFpc05hTih2YWx1ZSkgJiYgIWlzTmFOKGZyb20pICYmICFpc05hTih0bykpIHtcbiAgICAgICAgY29uc3QgdmFsID0gMSAqIHZhbHVlO1xuICAgICAgICBmcm9tID0gTnVtYmVyKGZyb20pO1xuICAgICAgICB0byA9IE51bWJlcih0byk7XG4gICAgICAgIGNvbnN0IFthLCBiXSA9IGZyb20gPD0gdG8gPyBbZnJvbSwgdG9dIDogW3RvLCBmcm9tXTtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSAxICogYSAmJiB2YWwgPD0gMSAqIGI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGhhc0NvbmZpcm0gPSAvKF9jb25maXJtKD86ZWQpPykkLztcbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBpbnB1dCdzIHZhbHVlIG1hdGNoZXMgYW5vdGhlciBpbnB1dCdzIHZhbHVlXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBGb3JtS2l0VmFsaWRhdGlvbkNvbnRleHRcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgY29uZmlybSA9IGZ1bmN0aW9uIGNvbmZpcm0obm9kZSwgYWRkcmVzcywgY29tcGFyaXNvbiA9ICdsb29zZScpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSBoYXNDb25maXJtLnRlc3Qobm9kZS5uYW1lKVxuICAgICAgICAgICAgPyBub2RlLm5hbWUucmVwbGFjZShoYXNDb25maXJtLCAnJylcbiAgICAgICAgICAgIDogYCR7bm9kZS5uYW1lfV9jb25maXJtYDtcbiAgICB9XG4gICAgY29uc3QgZm9yZWlnblZhbHVlID0gKF9hID0gbm9kZS5hdChhZGRyZXNzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlO1xuICAgIHJldHVybiBjb21wYXJpc29uID09PSAnc3RyaWN0J1xuICAgICAgICA/IG5vZGUudmFsdWUgPT09IGZvcmVpZ25WYWx1ZVxuICAgICAgICA6IG5vZGUudmFsdWUgPT0gZm9yZWlnblZhbHVlO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIGlucHV0J3MgdmFsdWUgaXMgYmV0d2VlbiB0d28gb3RoZXIgZGF0ZXNcbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIEZvcm1LaXRWYWxpZGF0aW9uQ29udGV4dFxuICogQHB1YmxpY1xuICovXG5jb25zdCBkYXRlX2JldHdlZW4gPSBmdW5jdGlvbiBkYXRlX2JldHdlZW4oeyB2YWx1ZSB9LCBkYXRlQSwgZGF0ZUIpIHtcbiAgICBkYXRlQSA9IGRhdGVBIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGVBLmdldFRpbWUoKSA6IERhdGUucGFyc2UoZGF0ZUEpO1xuICAgIGRhdGVCID0gZGF0ZUIgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZUIuZ2V0VGltZSgpIDogRGF0ZS5wYXJzZShkYXRlQik7XG4gICAgY29uc3QgY29tcGFyZVRvID0gdmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gdmFsdWUuZ2V0VGltZSgpIDogRGF0ZS5wYXJzZShTdHJpbmcodmFsdWUpKTtcbiAgICBpZiAoZGF0ZUEgJiYgIWRhdGVCKSB7XG4gICAgICAgIGRhdGVCID0gZGF0ZUE7XG4gICAgICAgIGRhdGVBID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWRhdGVBIHx8ICFjb21wYXJlVG8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGFyZVRvID49IGRhdGVBICYmIGNvbXBhcmVUbyA8PSBkYXRlQjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBpbnB1dCdzIHZhbHVlIG1hdGNoZXMgYSBzcGVjaWZpZWQgZGF0ZSBmb3JtYXRcbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIEZvcm1LaXRWYWxpZGF0aW9uQ29udGV4dFxuICogQHB1YmxpY1xuICovXG5jb25zdCBkYXRlX2Zvcm1hdCA9IGZ1bmN0aW9uIGRhdGUoeyB2YWx1ZSB9LCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ICYmIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZWdleEZvckZvcm1hdChmb3JtYXQpLnRlc3QoU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiAhaXNOYU4oRGF0ZS5wYXJzZShTdHJpbmcodmFsdWUpKSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gaW5wdXQncyB2YWx1ZSBpcyBhIHBsYXVzaWJsZSBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgRm9ybUtpdFZhbGlkYXRpb25Db250ZXh0XG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGVtYWlsID0gZnVuY3Rpb24gZW1haWwoeyB2YWx1ZSB9KSB7XG4gICAgY29uc3QgaXNFbWFpbCA9IC9eKChbXjw+KClcXFtcXF1cXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVxcW1xcXVxcLiw7Olxcc0BcXFwiXSspKil8KFxcXCIuK1xcXCIpKUAoKFtePD4oKVtcXF1cXC4sOzpcXHNAXFxcIl0rXFwuKStbXjw+KClbXFxdXFwuLDs6XFxzQFxcXCJdezIsfSkkL2k7XG4gICAgcmV0dXJuIGlzRW1haWwudGVzdChTdHJpbmcodmFsdWUpKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBpbnB1dCdzIHZhbHVlIGVuZHMgd2l0aCBhIGdpdmVuIHN0cmluZ1xuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgRm9ybUtpdFZhbGlkYXRpb25Db250ZXh0XG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGVuZHNfd2l0aCA9IGZ1bmN0aW9uIGVuZHNfd2l0aCh7IHZhbHVlIH0sIC4uLnN0YWNrKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdGFjay5zb21lKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZW5kc1dpdGgoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIGlucHV0J3MgdmFsdWUgaXMgaW4gYSBzZXQgb2YgcG9zc2libGUgdmFsdWVzLlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgRm9ybUtpdFZhbGlkYXRpb25Db250ZXh0XG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGlzID0gZnVuY3Rpb24gaXMoeyB2YWx1ZSB9LCAuLi5zdGFjaykge1xuICAgIHJldHVybiBzdGFjay5zb21lKChpdGVtKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlcShpdGVtLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0gPT0gdmFsdWU7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gaW5wdXQncyB2YWx1ZSBsZW5ndGggaXMgZnVsbCB3aWR0aC5cbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIEZvcm1LaXRWYWxpZGF0aW9uQ29udGV4dFxuICogQHB1YmxpY1xuICovXG5jb25zdCBsZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoeyB2YWx1ZSB9LCBmaXJzdCA9IDAsIHNlY29uZCA9IEluZmluaXR5KSB7XG4gICAgZmlyc3QgPSBwYXJzZUludChmaXJzdCk7XG4gICAgc2Vjb25kID0gaXNOYU4ocGFyc2VJbnQoc2Vjb25kKSkgPyBJbmZpbml0eSA6IHBhcnNlSW50KHNlY29uZCk7XG4gICAgY29uc3QgbWluID0gZmlyc3QgPD0gc2Vjb25kID8gZmlyc3QgOiBzZWNvbmQ7XG4gICAgY29uc3QgbWF4ID0gc2Vjb25kID49IGZpcnN0ID8gc2Vjb25kIDogZmlyc3Q7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSBtaW4gJiYgdmFsdWUubGVuZ3RoIDw9IG1heDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoID49IG1pbiAmJiBsZW5ndGggPD0gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gaW5wdXQncyB2YWx1ZSBtYXRjaGVzIG9uZSBvciBtb3JlIHZhbHVlcyBvciByZWd1bGFyIGV4cHJlc3Npb25zLlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgRm9ybUtpdFZhbGlkYXRpb25Db250ZXh0XG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IG1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKHsgdmFsdWUgfSwgLi4uc3RhY2spIHtcbiAgICByZXR1cm4gc3RhY2suc29tZSgocGF0dGVybikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBwYXR0ZXJuLnN1YnN0cigwLCAxKSA9PT0gJy8nICYmXG4gICAgICAgICAgICBwYXR0ZXJuLnN1YnN0cigtMSkgPT09ICcvJykge1xuICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5zdWJzdHIoMSwgcGF0dGVybi5sZW5ndGggLSAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm4gPT09IHZhbHVlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIGlucHV0J3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBtYXhpbXVtXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBGb3JtS2l0VmFsaWRhdGlvbkNvbnRleHRcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgbWF4ID0gZnVuY3Rpb24gbWF4KHsgdmFsdWUgfSwgbWF4aW11bSA9IDEwKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPD0gbWF4aW11bTtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPD0gTnVtYmVyKG1heGltdW0pO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIGlucHV0J3MgdmFsdWUgaXMgbGVzcyB0aGFuIGEgY2VydGFpbiB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIEZvcm1LaXRWYWxpZGF0aW9uQ29udGV4dFxuICogQHB1YmxpY1xuICovXG5jb25zdCBtaW4gPSBmdW5jdGlvbiBtaW4oeyB2YWx1ZSB9LCBtaW5pbXVtID0gMSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID49IG1pbmltdW07XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIodmFsdWUpID49IE51bWJlcihtaW5pbXVtKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBpbnB1dCdzIHZhbHVlIGlzIG5vdCBpbiBhIGdpdmVuIHN0YWNrXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBGb3JtS2l0VmFsaWRhdGlvbkNvbnRleHRcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3Qgbm90ID0gZnVuY3Rpb24gbm90KHsgdmFsdWUgfSwgLi4uc3RhY2spIHtcbiAgICByZXR1cm4gIXN0YWNrLnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVxKGl0ZW0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbSA9PT0gdmFsdWU7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gaW5wdXQncyB2YWx1ZSBpcyBudW1lcmljXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBGb3JtS2l0VmFsaWRhdGlvbkNvbnRleHRcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgbnVtYmVyID0gZnVuY3Rpb24gbnVtYmVyKHsgdmFsdWUgfSkge1xuICAgIHJldHVybiAhaXNOYU4odmFsdWUpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIGlucHV0J3MgdmFsdWUgd2FzIHJlcXVpcmVkLlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgRm9ybUtpdFZhbGlkYXRpb25Db250ZXh0XG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHJlcXVpcmVkID0gZnVuY3Rpb24gcmVxdWlyZWQoeyB2YWx1ZSB9LCBhY3Rpb24gPSAnZGVmYXVsdCcpIHtcbiAgICByZXR1cm4gYWN0aW9uID09PSAndHJpbScgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICA/ICFlbXB0eSh2YWx1ZS50cmltKCkpXG4gICAgICAgIDogIWVtcHR5KHZhbHVlKTtcbn07XG4vKipcbiAqIFRoaXMgcnVsZXMgc2hvdWxkIHJ1biBldmVuIGlmIHRoZSBpbnB1dHMgaXMgZW1wdHkgKG9idmlvdXNseSlcbiAqL1xucmVxdWlyZWQuc2tpcEVtcHR5ID0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBpbnB1dCdzIHZhbHVlIHN0YXJ0cyB3aXRoIGEgc3Vic3RyaW5nXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBGb3JtS2l0VmFsaWRhdGlvbkNvbnRleHRcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3Qgc3RhcnRzX3dpdGggPSBmdW5jdGlvbiBzdGFydHNfd2l0aCh7IHZhbHVlIH0sIC4uLnN0YWNrKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdGFjay5zb21lKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3RhcnRzV2l0aChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gaW5wdXQncyB2YWx1ZSBpcyBhbiBodHRwIHVybFxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgRm9ybUtpdFZhbGlkYXRpb25Db250ZXh0XG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVybCA9IGZ1bmN0aW9uIHVybCh7IHZhbHVlIH0sIC4uLnN0YWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2xzID0gc3RhY2subGVuZ3RoID8gc3RhY2sgOiBbJ2h0dHA6JywgJ2h0dHBzOiddO1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gcHJvdG9jb2xzLmluY2x1ZGVzKHVybC5wcm90b2NvbCk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGFjY2VwdGVkLCBhbHBoYSwgYWxwaGFfc3BhY2VzLCBhbHBoYW51bWVyaWMsIGJldHdlZW4sIGNvbmZpcm0sIGRhdGVfYWZ0ZXIsIGRhdGVfYmVmb3JlLCBkYXRlX2JldHdlZW4sIGRhdGVfZm9ybWF0LCBlbWFpbCwgZW5kc193aXRoLCBpcywgbGVuZ3RoLCBtYXRjaGVzLCBtYXgsIG1pbiwgbm90LCBudW1iZXIsIHJlcXVpcmVkLCBzdGFydHNfd2l0aCwgdXJsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formkit/rules/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/@formkit/utils/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@formkit/utils/dist/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assignDeep\": function() { return /* binding */ assignDeep; },\n/* harmony export */   \"camel\": function() { return /* binding */ camel; },\n/* harmony export */   \"clone\": function() { return /* binding */ clone; },\n/* harmony export */   \"cloneAny\": function() { return /* binding */ cloneAny; },\n/* harmony export */   \"dedupe\": function() { return /* binding */ dedupe; },\n/* harmony export */   \"empty\": function() { return /* binding */ empty; },\n/* harmony export */   \"eq\": function() { return /* binding */ eq; },\n/* harmony export */   \"escapeExp\": function() { return /* binding */ escapeExp; },\n/* harmony export */   \"except\": function() { return /* binding */ except; },\n/* harmony export */   \"extend\": function() { return /* binding */ extend; },\n/* harmony export */   \"getAt\": function() { return /* binding */ getAt; },\n/* harmony export */   \"has\": function() { return /* binding */ has; },\n/* harmony export */   \"init\": function() { return /* binding */ init; },\n/* harmony export */   \"isObject\": function() { return /* binding */ isObject; },\n/* harmony export */   \"isPojo\": function() { return /* binding */ isPojo; },\n/* harmony export */   \"isQuotedString\": function() { return /* binding */ isQuotedString; },\n/* harmony export */   \"isRecord\": function() { return /* binding */ isRecord; },\n/* harmony export */   \"kebab\": function() { return /* binding */ kebab; },\n/* harmony export */   \"nodeProps\": function() { return /* binding */ nodeProps; },\n/* harmony export */   \"nodeType\": function() { return /* binding */ nodeType; },\n/* harmony export */   \"only\": function() { return /* binding */ only; },\n/* harmony export */   \"parseArgs\": function() { return /* binding */ parseArgs; },\n/* harmony export */   \"regexForFormat\": function() { return /* binding */ regexForFormat; },\n/* harmony export */   \"rmEscapes\": function() { return /* binding */ rmEscapes; },\n/* harmony export */   \"setify\": function() { return /* binding */ setify; },\n/* harmony export */   \"shallowClone\": function() { return /* binding */ shallowClone; },\n/* harmony export */   \"slugify\": function() { return /* binding */ slugify; },\n/* harmony export */   \"spread\": function() { return /* binding */ spread; },\n/* harmony export */   \"token\": function() { return /* binding */ token; },\n/* harmony export */   \"undefine\": function() { return /* binding */ undefine; }\n/* harmony export */ });\n/**\n * Generates a random string.\n * @returns string\n * @public\n */\nfunction token() {\n    return Math.random().toString(36).substring(2, 15);\n}\n/**\n * Creates a new set of the specified type and uses the values from an Array or\n * an existing Set.\n * @param items -\n * @returns Set\n * @public\n */\nfunction setify(items) {\n    return items instanceof Set ? items : new Set(items);\n}\n/**\n * Given 2 arrays, return them as a combined array with no duplicates.\n * @param arr1 -\n * @param arr2 -\n * @returns any[]\n * @public\n */\nfunction dedupe(arr1, arr2) {\n    const original = arr1 instanceof Set ? arr1 : new Set(arr1);\n    if (arr2)\n        arr2.forEach((item) => original.add(item));\n    return [...original];\n}\n/**\n * Checks if the given property exists on the given object.\n * @param obj -\n * @param property -\n * @public\n */\nfunction has(obj, property) {\n    return Object.prototype.hasOwnProperty.call(obj, property);\n}\n/**\n * Compare two values for equality optionally at depth.\n * @param valA - Any type of input\n * @param valB - Any type of output\n * @param deep - Indicate if we should recurse into the object\n * @param explicit - Explicit keys\n * @returns boolean\n * @public\n */\nfunction eq(valA, // eslint-disable-line\nvalB, // eslint-disable-line\ndeep = true, explicit = ['__key']) {\n    if (valA === valB)\n        return true;\n    if (typeof valB === 'object' && typeof valA === 'object') {\n        if (valA instanceof Map)\n            return false;\n        if (valA instanceof Set)\n            return false;\n        if (valA instanceof Date)\n            return false;\n        if (valA === null || valB === null)\n            return false;\n        if (Object.keys(valA).length !== Object.keys(valB).length)\n            return false;\n        for (const k of explicit) {\n            if ((k in valA || k in valB) && valA[k] !== valB[k])\n                return false;\n        }\n        for (const key in valA) {\n            if (!(key in valB))\n                return false;\n            if (valA[key] !== valB[key] && !deep)\n                return false;\n            if (deep && !eq(valA[key], valB[key], deep, explicit))\n                return false;\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if a value is empty or not.\n * @param value - any type of value that could be returned by an input.\n * @public\n */\nfunction empty(value // eslint-disable-line\n) {\n    const type = typeof value;\n    if (type === 'number')\n        return false;\n    if (value === undefined)\n        return true;\n    if (type === 'string') {\n        return value === '';\n    }\n    if (type === 'object') {\n        if (value === null)\n            return true;\n        for (const _i in value)\n            return false;\n        if (value instanceof RegExp)\n            return false;\n        if (value instanceof Date)\n            return false;\n        return true;\n    }\n    return false;\n}\n/**\n * Escape a string for use in regular expressions.\n * @param string - The string to escape.\n * @public\n */\nfunction escapeExp(string) {\n    // $& means the whole matched string\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n/**\n * Given a string format (date) return a regex to match against.\n * @param format - The format of the string\n * @returns\n * @public\n */\nfunction regexForFormat(format) {\n    const escaped = `^${escapeExp(format)}$`;\n    const formats = {\n        MM: '(0[1-9]|1[012])',\n        M: '([1-9]|1[012])',\n        DD: '([012][0-9]|3[01])',\n        D: '([012]?[0-9]|3[01])',\n        YYYY: '\\\\d{4}',\n        YY: '\\\\d{2}',\n    };\n    const tokens = Object.keys(formats);\n    return new RegExp(tokens.reduce((regex, format) => {\n        return regex.replace(format, formats[format]);\n    }, escaped));\n}\n/**\n * Given a FormKit input type\n * @param type - Any FormKit input type\n * @public\n */\nfunction nodeType(type) {\n    const t = type.toLowerCase();\n    if (t === 'list')\n        return 'list';\n    if (t === 'group')\n        return 'group';\n    return 'input';\n}\n/**\n * Determines if an object is an object or not.\n * @param o - any value\n * @returns\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isRecord(o) {\n    return Object.prototype.toString.call(o) === '[object Object]';\n}\n/**\n * Checks if an object is a simple array or record.\n * @param o - A value to check\n * @returns\n * @public\n */\nfunction isObject(o) {\n    return isRecord(o) || Array.isArray(o);\n}\n/**\n * Attempts to determine if an object is a plain object. Mostly lifted from\n * is-plain-object: https://github.com/jonschlinkert/is-plain-object\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * @param o - any value\n * @returns\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isPojo(o) {\n    if (isRecord(o) === false)\n        return false;\n    if (o.__FKNode__ || o.__POJO__ === false)\n        return false;\n    const ctor = o.constructor;\n    if (ctor === undefined)\n        return true;\n    const prot = ctor.prototype;\n    if (isRecord(prot) === false)\n        return false;\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Recursively merge data from additional into original returning a new object.\n * @param original - An object to extend\n * @param additional - An object to modify the original object with.\n * @param arrays - By default replaces arrays, but can also append to them.\n * @param ignoreUndefined - when true it treats undefined values as if they dont exist\n * @public\n */\nfunction extend(original, additional, extendArrays = false, ignoreUndefined = false) {\n    if (additional === null)\n        return null;\n    const merged = {};\n    if (typeof additional === 'string')\n        return additional;\n    for (const key in original) {\n        if (has(additional, key) &&\n            (additional[key] !== undefined || !ignoreUndefined)) {\n            if (extendArrays &&\n                Array.isArray(original[key]) &&\n                Array.isArray(additional[key])) {\n                merged[key] = original[key].concat(additional[key]);\n                continue;\n            }\n            if (additional[key] === undefined) {\n                continue;\n            }\n            if (isPojo(original[key]) && isPojo(additional[key])) {\n                merged[key] = extend(original[key], additional[key], extendArrays, ignoreUndefined);\n            }\n            else {\n                merged[key] = additional[key];\n            }\n        }\n        else {\n            merged[key] = original[key];\n        }\n    }\n    for (const key in additional) {\n        if (!has(merged, key) && additional[key] !== undefined) {\n            merged[key] = additional[key];\n        }\n    }\n    return merged;\n}\n/**\n * Determine if the given string is fully quoted. Examples:\n * hello - false\n * \"hello\" - true\n * 'world' - true\n * \"hello\"==\"world\" - false\n * \"hello'this'\" - false\n * \"hello\"'there' - false\n * \"hello\"\"there\" - false\n * 'hello === world' - true\n * @param str - A string to check.\n * @public\n */\nfunction isQuotedString(str) {\n    // quickly return false if the value is note quoted\n    if (str[0] !== '\"' && str[0] !== \"'\")\n        return false;\n    if (str[0] !== str[str.length - 1])\n        return false;\n    const quoteType = str[0];\n    for (let p = 1; p < str.length; p++) {\n        if (str[p] === quoteType &&\n            (p === 1 || str[p - 1] !== '\\\\') &&\n            p !== str.length - 1) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Remove extra escape characters.\n * @param str - A string to remove escape characters from.\n * @public\n */\nfunction rmEscapes(str) {\n    if (!str.length)\n        return '';\n    let clean = '';\n    let lastChar = '';\n    for (let p = 0; p < str.length; p++) {\n        const char = str.charAt(p);\n        if (char !== '\\\\' || lastChar === '\\\\') {\n            clean += char;\n        }\n        lastChar = char;\n    }\n    return clean;\n}\n/**\n * Performs a recursive Object.assign like operation.\n * @param a - An object to be extended by object b\n * @param b - An object to copy values from\n * @public\n */\nfunction assignDeep(a, b) {\n    for (const key in a) {\n        if (has(b, key) &&\n            a[key] !== b[key] &&\n            !(isPojo(a[key]) && isPojo(b[key]))) {\n            a[key] = b[key];\n        }\n        else if (isPojo(a[key]) && isPojo(b[key])) {\n            assignDeep(a[key], b[key]);\n        }\n    }\n    for (const key in b) {\n        if (!has(a, key)) {\n            a[key] = b[key];\n        }\n    }\n    return a;\n}\n/**\n * Filters out values from an object that should not be considered \"props\" of\n * a core node, like \"value\" and \"name\".\n * @param attrs - An object to extract core node config from.\n * @public\n */\nfunction nodeProps(...sets) {\n    return sets.reduce((valid, props) => {\n        const { value, name, modelValue, config, plugins, ...validProps } = props; // eslint-disable-line\n        return Object.assign(valid, validProps);\n    }, {});\n}\n/**\n * Parse a string for comma-separated arguments\n * @param str - A string to parse\n * @public\n */\nfunction parseArgs(str) {\n    const args = [];\n    let arg = '';\n    let depth = 0;\n    let quote = '';\n    let lastChar = '';\n    for (let p = 0; p < str.length; p++) {\n        const char = str.charAt(p);\n        if (char === quote && lastChar !== '\\\\') {\n            quote = '';\n        }\n        else if ((char === \"'\" || char === '\"') && !quote && lastChar !== '\\\\') {\n            quote = char;\n        }\n        else if (char === '(' && !quote) {\n            depth++;\n        }\n        else if (char === ')' && !quote) {\n            depth--;\n        }\n        if (char === ',' && !quote && depth === 0) {\n            args.push(arg);\n            arg = '';\n        }\n        else if (char !== ' ' || quote) {\n            arg += char;\n        }\n        lastChar = char;\n    }\n    if (arg) {\n        args.push(arg);\n    }\n    return args;\n}\n/**\n * Return a new (shallow) object with all properties from a given object\n * that are present in the array.\n * @param obj - An object to clone\n * @param toRemove - An array of keys to remove\n * @public\n */\nfunction except(obj, toRemove) {\n    const clean = {};\n    const exps = toRemove.filter((n) => n instanceof RegExp);\n    const keysToRemove = new Set(toRemove);\n    for (const key in obj) {\n        if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {\n            clean[key] = obj[key];\n        }\n    }\n    return clean;\n}\n/**\n * Extracts a set of keys from a given object. Importantly, this will extract\n * values even if they are not set on the original object they will just have an\n * undefined value.\n * @param obj - An object to extract values from\n * @param include - A set of keys to extract\n * @returns\n * @public\n */\nfunction only(obj, include) {\n    const clean = {};\n    const exps = include.filter((n) => n instanceof RegExp);\n    include.forEach((key) => {\n        if (!(key instanceof RegExp)) {\n            clean[key] = obj[key];\n        }\n    });\n    Object.keys(obj).forEach((key) => {\n        if (exps.some((exp) => exp.test(key))) {\n            clean[key] = obj[key];\n        }\n    });\n    return clean;\n}\n/**\n * This converts kebab-case to camelCase. It ONLY converts from kebab for\n * efficiency stake.\n * @param str - String to convert.\n * @public\n */\nfunction camel(str) {\n    return str.replace(/-([a-z0-9])/gi, (_s, g) => g.toUpperCase());\n}\n/**\n * This converts camel-case to kebab case. It ONLY converts from camel to kebab.\n * @param str - Converts camel to kebab\n * @returns\n * @public\n */\nfunction kebab(str) {\n    return str\n        .replace(/([a-z0-9])([A-Z])/g, (_s, trail, cap) => trail + '-' + cap.toLowerCase())\n        .replace(' ', '-')\n        .toLowerCase();\n}\n/**\n * Very shallowly clones the given object.\n * @param obj - The object to shallow clone\n * @returns\n * @public\n */\nfunction shallowClone(obj, explicit = ['__key', '__init']) {\n    if (obj !== null && typeof obj === 'object') {\n        let returnObject;\n        if (Array.isArray(obj))\n            returnObject = [...obj];\n        else if (isPojo(obj))\n            returnObject = { ...obj };\n        if (returnObject) {\n            applyExplicit(obj, returnObject, explicit);\n            return returnObject;\n        }\n    }\n    return obj;\n}\n/**\n * Perform a recursive clone on a given object. This only intended to be used\n * for simple objects like arrays and pojos.\n * @param obj - Object to clone\n * @public\n */\nfunction clone(obj, explicit = ['__key', '__init']) {\n    if (obj === null ||\n        obj instanceof RegExp ||\n        obj instanceof Date ||\n        obj instanceof Map ||\n        obj instanceof Set ||\n        (typeof File === 'function' && obj instanceof File))\n        return obj;\n    let returnObject;\n    if (Array.isArray(obj)) {\n        returnObject = obj.map((value) => {\n            if (typeof value === 'object')\n                return clone(value, explicit);\n            return value;\n        });\n    }\n    else {\n        returnObject = Object.keys(obj).reduce((newObj, key) => {\n            newObj[key] =\n                typeof obj[key] === 'object'\n                    ? clone(obj[key], explicit)\n                    : obj[key];\n            return newObj;\n        }, {});\n    }\n    for (const key of explicit) {\n        if (key in obj) {\n            Object.defineProperty(returnObject, key, {\n                enumerable: false,\n                value: obj[key],\n            });\n        }\n    }\n    return returnObject;\n}\n/**\n * Clones anything. If the item is scalar, no worries, it passes it back. if it\n * is an object, it performs a (fast/loose) clone operation.\n * @param obj - The object to clone\n * @public\n */\nfunction cloneAny(obj) {\n    return typeof obj === 'object'\n        ? clone(obj)\n        : obj;\n}\n/**\n * Get a specific value via dot notation.\n * @param obj - An object to fetch data from\n * @param addr - An \"address\" in dot notation\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction getAt(obj, addr) {\n    if (!obj || typeof obj !== 'object')\n        return null;\n    const segments = addr.split('.');\n    let o = obj;\n    for (const i in segments) {\n        const segment = segments[i];\n        if (has(o, segment)) {\n            o = o[segment];\n        }\n        if (+i === segments.length - 1)\n            return o;\n        if (!o || typeof o !== 'object')\n            return null;\n    }\n    return null;\n}\n/**\n * Determines if the value of a prop that is either present (true) or not\n * present (false). For example the prop disabled should disable\n * by just existing, but what if it is set to the string \"false\" — then it\n * should not be disabled.\n * @param value - value to be checked\n * @returns\n * @public\n */\nfunction undefine(value) {\n    return value !== undefined && value !== 'false' && value !== false\n        ? true\n        : undefined;\n}\n/**\n * Defines an object as an initial value.\n * @param obj - Object\n * @returns\n * @public\n */\n/* eslint-disable-next-line @typescript-eslint/ban-types */\nfunction init(obj) {\n    return !Object.isFrozen(obj)\n        ? Object.defineProperty(obj, '__init', {\n            enumerable: false,\n            value: true,\n        })\n        : obj;\n}\n/**\n * Turn any string into a URL/DOM safe string.\n * @public\n */\nfunction slugify(str) {\n    return str\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '')\n        .toLowerCase()\n        .replace(/[^a-z0-9]/g, ' ')\n        .trim()\n        .replace(/\\s+/g, '-');\n}\n/**\n * Spreads an object or an array, otherwise returns the same value.\n * @param obj - Any value, but will spread objects and arrays\n * @public\n */\nfunction spread(obj, explicit = ['__key', '__init']) {\n    if (obj && typeof obj === 'object') {\n        if (obj instanceof RegExp)\n            return obj;\n        if (obj instanceof Date)\n            return obj;\n        let spread;\n        if (Array.isArray(obj)) {\n            spread = [...obj];\n        }\n        else {\n            spread = { ...obj };\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        return applyExplicit(obj, spread, explicit);\n    }\n    return obj;\n}\n/**\n * Apply non enumerable properties to an object.\n * @param obj - The object to apply non-enumerable properties to\n * @param explicit - An array of non-enumerable properties to apply\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction applyExplicit(original, obj, explicit) {\n    for (const key of explicit) {\n        if (key in original) {\n            Object.defineProperty(obj, key, {\n                enumerable: false,\n                value: original[key],\n            });\n        }\n    }\n    return obj;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvdXRpbHMvZGlzdC9pbmRleC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWtpdC91dGlscy9kaXN0L2luZGV4Lm1qcz8wMzQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHN0cmluZy5cbiAqIEByZXR1cm5zIHN0cmluZ1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b2tlbigpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzZXQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGFuZCB1c2VzIHRoZSB2YWx1ZXMgZnJvbSBhbiBBcnJheSBvclxuICogYW4gZXhpc3RpbmcgU2V0LlxuICogQHBhcmFtIGl0ZW1zIC1cbiAqIEByZXR1cm5zIFNldFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXRpZnkoaXRlbXMpIHtcbiAgICByZXR1cm4gaXRlbXMgaW5zdGFuY2VvZiBTZXQgPyBpdGVtcyA6IG5ldyBTZXQoaXRlbXMpO1xufVxuLyoqXG4gKiBHaXZlbiAyIGFycmF5cywgcmV0dXJuIHRoZW0gYXMgYSBjb21iaW5lZCBhcnJheSB3aXRoIG5vIGR1cGxpY2F0ZXMuXG4gKiBAcGFyYW0gYXJyMSAtXG4gKiBAcGFyYW0gYXJyMiAtXG4gKiBAcmV0dXJucyBhbnlbXVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWR1cGUoYXJyMSwgYXJyMikge1xuICAgIGNvbnN0IG9yaWdpbmFsID0gYXJyMSBpbnN0YW5jZW9mIFNldCA/IGFycjEgOiBuZXcgU2V0KGFycjEpO1xuICAgIGlmIChhcnIyKVxuICAgICAgICBhcnIyLmZvckVhY2goKGl0ZW0pID0+IG9yaWdpbmFsLmFkZChpdGVtKSk7XG4gICAgcmV0dXJuIFsuLi5vcmlnaW5hbF07XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gcHJvcGVydHkgZXhpc3RzIG9uIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0gb2JqIC1cbiAqIEBwYXJhbSBwcm9wZXJ0eSAtXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGhhcyhvYmosIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BlcnR5KTtcbn1cbi8qKlxuICogQ29tcGFyZSB0d28gdmFsdWVzIGZvciBlcXVhbGl0eSBvcHRpb25hbGx5IGF0IGRlcHRoLlxuICogQHBhcmFtIHZhbEEgLSBBbnkgdHlwZSBvZiBpbnB1dFxuICogQHBhcmFtIHZhbEIgLSBBbnkgdHlwZSBvZiBvdXRwdXRcbiAqIEBwYXJhbSBkZWVwIC0gSW5kaWNhdGUgaWYgd2Ugc2hvdWxkIHJlY3Vyc2UgaW50byB0aGUgb2JqZWN0XG4gKiBAcGFyYW0gZXhwbGljaXQgLSBFeHBsaWNpdCBrZXlzXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbEEsIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbnZhbEIsIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmRlZXAgPSB0cnVlLCBleHBsaWNpdCA9IFsnX19rZXknXSkge1xuICAgIGlmICh2YWxBID09PSB2YWxCKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIHZhbEIgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWxBID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodmFsQSBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHZhbEEgaW5zdGFuY2VvZiBTZXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh2YWxBIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHZhbEEgPT09IG51bGwgfHwgdmFsQiA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbEEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXModmFsQikubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgZXhwbGljaXQpIHtcbiAgICAgICAgICAgIGlmICgoayBpbiB2YWxBIHx8IGsgaW4gdmFsQikgJiYgdmFsQVtrXSAhPT0gdmFsQltrXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsQSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHZhbEIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh2YWxBW2tleV0gIT09IHZhbEJba2V5XSAmJiAhZGVlcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGVlcCAmJiAhZXEodmFsQVtrZXldLCB2YWxCW2tleV0sIGRlZXAsIGV4cGxpY2l0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHZhbHVlIGlzIGVtcHR5IG9yIG5vdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIGFueSB0eXBlIG9mIHZhbHVlIHRoYXQgY291bGQgYmUgcmV0dXJuZWQgYnkgYW4gaW5wdXQuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGVtcHR5KHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbikge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcnO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgX2kgaW4gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIGZvciB1c2UgaW4gcmVndWxhciBleHByZXNzaW9ucy5cbiAqIEBwYXJhbSBzdHJpbmcgLSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZXNjYXBlRXhwKHN0cmluZykge1xuICAgIC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBzdHJpbmcgZm9ybWF0IChkYXRlKSByZXR1cm4gYSByZWdleCB0byBtYXRjaCBhZ2FpbnN0LlxuICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIHN0cmluZ1xuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcmVnZXhGb3JGb3JtYXQoZm9ybWF0KSB7XG4gICAgY29uc3QgZXNjYXBlZCA9IGBeJHtlc2NhcGVFeHAoZm9ybWF0KX0kYDtcbiAgICBjb25zdCBmb3JtYXRzID0ge1xuICAgICAgICBNTTogJygwWzEtOV18MVswMTJdKScsXG4gICAgICAgIE06ICcoWzEtOV18MVswMTJdKScsXG4gICAgICAgIEREOiAnKFswMTJdWzAtOV18M1swMV0pJyxcbiAgICAgICAgRDogJyhbMDEyXT9bMC05XXwzWzAxXSknLFxuICAgICAgICBZWVlZOiAnXFxcXGR7NH0nLFxuICAgICAgICBZWTogJ1xcXFxkezJ9JyxcbiAgICB9O1xuICAgIGNvbnN0IHRva2VucyA9IE9iamVjdC5rZXlzKGZvcm1hdHMpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHRva2Vucy5yZWR1Y2UoKHJlZ2V4LCBmb3JtYXQpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnJlcGxhY2UoZm9ybWF0LCBmb3JtYXRzW2Zvcm1hdF0pO1xuICAgIH0sIGVzY2FwZWQpKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBGb3JtS2l0IGlucHV0IHR5cGVcbiAqIEBwYXJhbSB0eXBlIC0gQW55IEZvcm1LaXQgaW5wdXQgdHlwZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBub2RlVHlwZSh0eXBlKSB7XG4gICAgY29uc3QgdCA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodCA9PT0gJ2xpc3QnKVxuICAgICAgICByZXR1cm4gJ2xpc3QnO1xuICAgIGlmICh0ID09PSAnZ3JvdXAnKVxuICAgICAgICByZXR1cm4gJ2dyb3VwJztcbiAgICByZXR1cm4gJ2lucHV0Jztcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhbiBvYmplY3QgaXMgYW4gb2JqZWN0IG9yIG5vdC5cbiAqIEBwYXJhbSBvIC0gYW55IHZhbHVlXG4gKiBAcmV0dXJuc1xuICogQHB1YmxpY1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gaXNSZWNvcmQobykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYW4gb2JqZWN0IGlzIGEgc2ltcGxlIGFycmF5IG9yIHJlY29yZC5cbiAqIEBwYXJhbSBvIC0gQSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICAgIHJldHVybiBpc1JlY29yZChvKSB8fCBBcnJheS5pc0FycmF5KG8pO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgcGxhaW4gb2JqZWN0LiBNb3N0bHkgbGlmdGVkIGZyb21cbiAqIGlzLXBsYWluLW9iamVjdDogaHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtcGxhaW4tb2JqZWN0XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBAcGFyYW0gbyAtIGFueSB2YWx1ZVxuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGlzUG9qbyhvKSB7XG4gICAgaWYgKGlzUmVjb3JkKG8pID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChvLl9fRktOb2RlX18gfHwgby5fX1BPSk9fXyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoY3RvciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gICAgaWYgKGlzUmVjb3JkKHByb3QpID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwcm90Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIGRhdGEgZnJvbSBhZGRpdGlvbmFsIGludG8gb3JpZ2luYWwgcmV0dXJuaW5nIGEgbmV3IG9iamVjdC5cbiAqIEBwYXJhbSBvcmlnaW5hbCAtIEFuIG9iamVjdCB0byBleHRlbmRcbiAqIEBwYXJhbSBhZGRpdGlvbmFsIC0gQW4gb2JqZWN0IHRvIG1vZGlmeSB0aGUgb3JpZ2luYWwgb2JqZWN0IHdpdGguXG4gKiBAcGFyYW0gYXJyYXlzIC0gQnkgZGVmYXVsdCByZXBsYWNlcyBhcnJheXMsIGJ1dCBjYW4gYWxzbyBhcHBlbmQgdG8gdGhlbS5cbiAqIEBwYXJhbSBpZ25vcmVVbmRlZmluZWQgLSB3aGVuIHRydWUgaXQgdHJlYXRzIHVuZGVmaW5lZCB2YWx1ZXMgYXMgaWYgdGhleSBkb250IGV4aXN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChvcmlnaW5hbCwgYWRkaXRpb25hbCwgZXh0ZW5kQXJyYXlzID0gZmFsc2UsIGlnbm9yZVVuZGVmaW5lZCA9IGZhbHNlKSB7XG4gICAgaWYgKGFkZGl0aW9uYWwgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG1lcmdlZCA9IHt9O1xuICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBhZGRpdGlvbmFsO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChoYXMoYWRkaXRpb25hbCwga2V5KSAmJlxuICAgICAgICAgICAgKGFkZGl0aW9uYWxba2V5XSAhPT0gdW5kZWZpbmVkIHx8ICFpZ25vcmVVbmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpZiAoZXh0ZW5kQXJyYXlzICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvcmlnaW5hbFtrZXldKSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoYWRkaXRpb25hbFtrZXldKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtrZXldID0gb3JpZ2luYWxba2V5XS5jb25jYXQoYWRkaXRpb25hbFtrZXldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUG9qbyhvcmlnaW5hbFtrZXldKSAmJiBpc1Bvam8oYWRkaXRpb25hbFtrZXldKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtrZXldID0gZXh0ZW5kKG9yaWdpbmFsW2tleV0sIGFkZGl0aW9uYWxba2V5XSwgZXh0ZW5kQXJyYXlzLCBpZ25vcmVVbmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSBhZGRpdGlvbmFsW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IG9yaWdpbmFsW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWRkaXRpb25hbCkge1xuICAgICAgICBpZiAoIWhhcyhtZXJnZWQsIGtleSkgJiYgYWRkaXRpb25hbFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gYWRkaXRpb25hbFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59XG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGZ1bGx5IHF1b3RlZC4gRXhhbXBsZXM6XG4gKiBoZWxsbyAtIGZhbHNlXG4gKiBcImhlbGxvXCIgLSB0cnVlXG4gKiAnd29ybGQnIC0gdHJ1ZVxuICogXCJoZWxsb1wiPT1cIndvcmxkXCIgLSBmYWxzZVxuICogXCJoZWxsbyd0aGlzJ1wiIC0gZmFsc2VcbiAqIFwiaGVsbG9cIid0aGVyZScgLSBmYWxzZVxuICogXCJoZWxsb1wiXCJ0aGVyZVwiIC0gZmFsc2VcbiAqICdoZWxsbyA9PT0gd29ybGQnIC0gdHJ1ZVxuICogQHBhcmFtIHN0ciAtIEEgc3RyaW5nIHRvIGNoZWNrLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1F1b3RlZFN0cmluZyhzdHIpIHtcbiAgICAvLyBxdWlja2x5IHJldHVybiBmYWxzZSBpZiB0aGUgdmFsdWUgaXMgbm90ZSBxdW90ZWRcbiAgICBpZiAoc3RyWzBdICE9PSAnXCInICYmIHN0clswXSAhPT0gXCInXCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc3RyWzBdICE9PSBzdHJbc3RyLmxlbmd0aCAtIDFdKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcXVvdGVUeXBlID0gc3RyWzBdO1xuICAgIGZvciAobGV0IHAgPSAxOyBwIDwgc3RyLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIGlmIChzdHJbcF0gPT09IHF1b3RlVHlwZSAmJlxuICAgICAgICAgICAgKHAgPT09IDEgfHwgc3RyW3AgLSAxXSAhPT0gJ1xcXFwnKSAmJlxuICAgICAgICAgICAgcCAhPT0gc3RyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogUmVtb3ZlIGV4dHJhIGVzY2FwZSBjaGFyYWN0ZXJzLlxuICogQHBhcmFtIHN0ciAtIEEgc3RyaW5nIHRvIHJlbW92ZSBlc2NhcGUgY2hhcmFjdGVycyBmcm9tLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBybUVzY2FwZXMoc3RyKSB7XG4gICAgaWYgKCFzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgbGV0IGNsZWFuID0gJyc7XG4gICAgbGV0IGxhc3RDaGFyID0gJyc7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPCBzdHIubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQocCk7XG4gICAgICAgIGlmIChjaGFyICE9PSAnXFxcXCcgfHwgbGFzdENoYXIgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgY2xlYW4gKz0gY2hhcjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2hhciA9IGNoYXI7XG4gICAgfVxuICAgIHJldHVybiBjbGVhbjtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSByZWN1cnNpdmUgT2JqZWN0LmFzc2lnbiBsaWtlIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBhIC0gQW4gb2JqZWN0IHRvIGJlIGV4dGVuZGVkIGJ5IG9iamVjdCBiXG4gKiBAcGFyYW0gYiAtIEFuIG9iamVjdCB0byBjb3B5IHZhbHVlcyBmcm9tXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkRlZXAoYSwgYikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKGhhcyhiLCBrZXkpICYmXG4gICAgICAgICAgICBhW2tleV0gIT09IGJba2V5XSAmJlxuICAgICAgICAgICAgIShpc1Bvam8oYVtrZXldKSAmJiBpc1Bvam8oYltrZXldKSkpIHtcbiAgICAgICAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1Bvam8oYVtrZXldKSAmJiBpc1Bvam8oYltrZXldKSkge1xuICAgICAgICAgICAgYXNzaWduRGVlcChhW2tleV0sIGJba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYikge1xuICAgICAgICBpZiAoIWhhcyhhLCBrZXkpKSB7XG4gICAgICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG4vKipcbiAqIEZpbHRlcnMgb3V0IHZhbHVlcyBmcm9tIGFuIG9iamVjdCB0aGF0IHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBcInByb3BzXCIgb2ZcbiAqIGEgY29yZSBub2RlLCBsaWtlIFwidmFsdWVcIiBhbmQgXCJuYW1lXCIuXG4gKiBAcGFyYW0gYXR0cnMgLSBBbiBvYmplY3QgdG8gZXh0cmFjdCBjb3JlIG5vZGUgY29uZmlnIGZyb20uXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG5vZGVQcm9wcyguLi5zZXRzKSB7XG4gICAgcmV0dXJuIHNldHMucmVkdWNlKCh2YWxpZCwgcHJvcHMpID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgbmFtZSwgbW9kZWxWYWx1ZSwgY29uZmlnLCBwbHVnaW5zLCAuLi52YWxpZFByb3BzIH0gPSBwcm9wczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih2YWxpZCwgdmFsaWRQcm9wcyk7XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgY29tbWEtc2VwYXJhdGVkIGFyZ3VtZW50c1xuICogQHBhcmFtIHN0ciAtIEEgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXJncyhzdHIpIHtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgbGV0IGFyZyA9ICcnO1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgbGV0IHF1b3RlID0gJyc7XG4gICAgbGV0IGxhc3RDaGFyID0gJyc7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPCBzdHIubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQocCk7XG4gICAgICAgIGlmIChjaGFyID09PSBxdW90ZSAmJiBsYXN0Q2hhciAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBxdW90ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjaGFyID09PSBcIidcIiB8fCBjaGFyID09PSAnXCInKSAmJiAhcXVvdGUgJiYgbGFzdENoYXIgIT09ICdcXFxcJykge1xuICAgICAgICAgICAgcXVvdGUgPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICcoJyAmJiAhcXVvdGUpIHtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJyknICYmICFxdW90ZSkge1xuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJywnICYmICFxdW90ZSAmJiBkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyICE9PSAnICcgfHwgcXVvdGUpIHtcbiAgICAgICAgICAgIGFyZyArPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDaGFyID0gY2hhcjtcbiAgICB9XG4gICAgaWYgKGFyZykge1xuICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59XG4vKipcbiAqIFJldHVybiBhIG5ldyAoc2hhbGxvdykgb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXMgZnJvbSBhIGdpdmVuIG9iamVjdFxuICogdGhhdCBhcmUgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gb2JqIC0gQW4gb2JqZWN0IHRvIGNsb25lXG4gKiBAcGFyYW0gdG9SZW1vdmUgLSBBbiBhcnJheSBvZiBrZXlzIHRvIHJlbW92ZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBleGNlcHQob2JqLCB0b1JlbW92ZSkge1xuICAgIGNvbnN0IGNsZWFuID0ge307XG4gICAgY29uc3QgZXhwcyA9IHRvUmVtb3ZlLmZpbHRlcigobikgPT4gbiBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgY29uc3Qga2V5c1RvUmVtb3ZlID0gbmV3IFNldCh0b1JlbW92ZSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICgha2V5c1RvUmVtb3ZlLmhhcyhrZXkpICYmICFleHBzLnNvbWUoKGV4cCkgPT4gZXhwLnRlc3Qoa2V5KSkpIHtcbiAgICAgICAgICAgIGNsZWFuW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xlYW47XG59XG4vKipcbiAqIEV4dHJhY3RzIGEgc2V0IG9mIGtleXMgZnJvbSBhIGdpdmVuIG9iamVjdC4gSW1wb3J0YW50bHksIHRoaXMgd2lsbCBleHRyYWN0XG4gKiB2YWx1ZXMgZXZlbiBpZiB0aGV5IGFyZSBub3Qgc2V0IG9uIHRoZSBvcmlnaW5hbCBvYmplY3QgdGhleSB3aWxsIGp1c3QgaGF2ZSBhblxuICogdW5kZWZpbmVkIHZhbHVlLlxuICogQHBhcmFtIG9iaiAtIEFuIG9iamVjdCB0byBleHRyYWN0IHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gaW5jbHVkZSAtIEEgc2V0IG9mIGtleXMgdG8gZXh0cmFjdFxuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gb25seShvYmosIGluY2x1ZGUpIHtcbiAgICBjb25zdCBjbGVhbiA9IHt9O1xuICAgIGNvbnN0IGV4cHMgPSBpbmNsdWRlLmZpbHRlcigobikgPT4gbiBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgaW5jbHVkZS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgY2xlYW5ba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKGV4cHMuc29tZSgoZXhwKSA9PiBleHAudGVzdChrZXkpKSkge1xuICAgICAgICAgICAgY2xlYW5ba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsZWFuO1xufVxuLyoqXG4gKiBUaGlzIGNvbnZlcnRzIGtlYmFiLWNhc2UgdG8gY2FtZWxDYXNlLiBJdCBPTkxZIGNvbnZlcnRzIGZyb20ga2ViYWIgZm9yXG4gKiBlZmZpY2llbmN5IHN0YWtlLlxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byBjb252ZXJ0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjYW1lbChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLy0oW2EtejAtOV0pL2dpLCAoX3MsIGcpID0+IGcudG9VcHBlckNhc2UoKSk7XG59XG4vKipcbiAqIFRoaXMgY29udmVydHMgY2FtZWwtY2FzZSB0byBrZWJhYiBjYXNlLiBJdCBPTkxZIGNvbnZlcnRzIGZyb20gY2FtZWwgdG8ga2ViYWIuXG4gKiBAcGFyYW0gc3RyIC0gQ29udmVydHMgY2FtZWwgdG8ga2ViYWJcbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGtlYmFiKHN0cikge1xuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnJlcGxhY2UoLyhbYS16MC05XSkoW0EtWl0pL2csIChfcywgdHJhaWwsIGNhcCkgPT4gdHJhaWwgKyAnLScgKyBjYXAudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgLnJlcGxhY2UoJyAnLCAnLScpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBWZXJ5IHNoYWxsb3dseSBjbG9uZXMgdGhlIGdpdmVuIG9iamVjdC5cbiAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IHRvIHNoYWxsb3cgY2xvbmVcbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmosIGV4cGxpY2l0ID0gWydfX2tleScsICdfX2luaXQnXSkge1xuICAgIGlmIChvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbGV0IHJldHVybk9iamVjdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICAgICAgICAgIHJldHVybk9iamVjdCA9IFsuLi5vYmpdO1xuICAgICAgICBlbHNlIGlmIChpc1Bvam8ob2JqKSlcbiAgICAgICAgICAgIHJldHVybk9iamVjdCA9IHsgLi4ub2JqIH07XG4gICAgICAgIGlmIChyZXR1cm5PYmplY3QpIHtcbiAgICAgICAgICAgIGFwcGx5RXhwbGljaXQob2JqLCByZXR1cm5PYmplY3QsIGV4cGxpY2l0KTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5PYmplY3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogUGVyZm9ybSBhIHJlY3Vyc2l2ZSBjbG9uZSBvbiBhIGdpdmVuIG9iamVjdC4gVGhpcyBvbmx5IGludGVuZGVkIHRvIGJlIHVzZWRcbiAqIGZvciBzaW1wbGUgb2JqZWN0cyBsaWtlIGFycmF5cyBhbmQgcG9qb3MuXG4gKiBAcGFyYW0gb2JqIC0gT2JqZWN0IHRvIGNsb25lXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNsb25lKG9iaiwgZXhwbGljaXQgPSBbJ19fa2V5JywgJ19faW5pdCddKSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgU2V0IHx8XG4gICAgICAgICh0eXBlb2YgRmlsZSA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSlcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICBsZXQgcmV0dXJuT2JqZWN0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuT2JqZWN0ID0gb2JqLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZSh2YWx1ZSwgZXhwbGljaXQpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybk9iamVjdCA9IE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChuZXdPYmosIGtleSkgPT4ge1xuICAgICAgICAgICAgbmV3T2JqW2tleV0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgPyBjbG9uZShvYmpba2V5XSwgZXhwbGljaXQpXG4gICAgICAgICAgICAgICAgICAgIDogb2JqW2tleV07XG4gICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGV4cGxpY2l0KSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0dXJuT2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb2JqW2tleV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuT2JqZWN0O1xufVxuLyoqXG4gKiBDbG9uZXMgYW55dGhpbmcuIElmIHRoZSBpdGVtIGlzIHNjYWxhciwgbm8gd29ycmllcywgaXQgcGFzc2VzIGl0IGJhY2suIGlmIGl0XG4gKiBpcyBhbiBvYmplY3QsIGl0IHBlcmZvcm1zIGEgKGZhc3QvbG9vc2UpIGNsb25lIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNsb25lQW55KG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xuICAgICAgICA/IGNsb25lKG9iailcbiAgICAgICAgOiBvYmo7XG59XG4vKipcbiAqIEdldCBhIHNwZWNpZmljIHZhbHVlIHZpYSBkb3Qgbm90YXRpb24uXG4gKiBAcGFyYW0gb2JqIC0gQW4gb2JqZWN0IHRvIGZldGNoIGRhdGEgZnJvbVxuICogQHBhcmFtIGFkZHIgLSBBbiBcImFkZHJlc3NcIiBpbiBkb3Qgbm90YXRpb25cbiAqIEBwdWJsaWNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGdldEF0KG9iaiwgYWRkcikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBzZWdtZW50cyA9IGFkZHIuc3BsaXQoJy4nKTtcbiAgICBsZXQgbyA9IG9iajtcbiAgICBmb3IgKGNvbnN0IGkgaW4gc2VnbWVudHMpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBpZiAoaGFzKG8sIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICBvID0gb1tzZWdtZW50XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoK2kgPT09IHNlZ21lbnRzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgaWYgKCFvIHx8IHR5cGVvZiBvICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgb2YgYSBwcm9wIHRoYXQgaXMgZWl0aGVyIHByZXNlbnQgKHRydWUpIG9yIG5vdFxuICogcHJlc2VudCAoZmFsc2UpLiBGb3IgZXhhbXBsZSB0aGUgcHJvcCBkaXNhYmxlZCBzaG91bGQgZGlzYWJsZVxuICogYnkganVzdCBleGlzdGluZywgYnV0IHdoYXQgaWYgaXQgaXMgc2V0IHRvIHRoZSBzdHJpbmcgXCJmYWxzZVwiIOKAlCB0aGVuIGl0XG4gKiBzaG91bGQgbm90IGJlIGRpc2FibGVkLlxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdW5kZWZpbmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gJ2ZhbHNlJyAmJiB2YWx1ZSAhPT0gZmFsc2VcbiAgICAgICAgPyB0cnVlXG4gICAgICAgIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBEZWZpbmVzIGFuIG9iamVjdCBhcyBhbiBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIG9iaiAtIE9iamVjdFxuICogQHJldHVybnNcbiAqIEBwdWJsaWNcbiAqL1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXMgKi9cbmZ1bmN0aW9uIGluaXQob2JqKSB7XG4gICAgcmV0dXJuICFPYmplY3QuaXNGcm96ZW4ob2JqKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdfX2luaXQnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgICA6IG9iajtcbn1cbi8qKlxuICogVHVybiBhbnkgc3RyaW5nIGludG8gYSBVUkwvRE9NIHNhZmUgc3RyaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzbHVnaWZ5KHN0cikge1xuICAgIHJldHVybiBzdHJcbiAgICAgICAgLm5vcm1hbGl6ZSgnTkZEJylcbiAgICAgICAgLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csICcnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAucmVwbGFjZSgvW15hLXowLTldL2csICcgJylcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xufVxuLyoqXG4gKiBTcHJlYWRzIGFuIG9iamVjdCBvciBhbiBhcnJheSwgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuXG4gKiBAcGFyYW0gb2JqIC0gQW55IHZhbHVlLCBidXQgd2lsbCBzcHJlYWQgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNwcmVhZChvYmosIGV4cGxpY2l0ID0gWydfX2tleScsICdfX2luaXQnXSkge1xuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgbGV0IHNwcmVhZDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgc3ByZWFkID0gWy4uLm9ial07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcHJlYWQgPSB7IC4uLm9iaiB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgICAgIHJldHVybiBhcHBseUV4cGxpY2l0KG9iaiwgc3ByZWFkLCBleHBsaWNpdCk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG4vKipcbiAqIEFwcGx5IG5vbiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgdG8gYW4gb2JqZWN0LlxuICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3QgdG8gYXBwbHkgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIGV4cGxpY2l0IC0gQW4gYXJyYXkgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyB0byBhcHBseVxuICogQGludGVybmFsXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBhcHBseUV4cGxpY2l0KG9yaWdpbmFsLCBvYmosIGV4cGxpY2l0KSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZXhwbGljaXQpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvcmlnaW5hbCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsW2tleV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgeyBhc3NpZ25EZWVwLCBjYW1lbCwgY2xvbmUsIGNsb25lQW55LCBkZWR1cGUsIGVtcHR5LCBlcSwgZXNjYXBlRXhwLCBleGNlcHQsIGV4dGVuZCwgZ2V0QXQsIGhhcywgaW5pdCwgaXNPYmplY3QsIGlzUG9qbywgaXNRdW90ZWRTdHJpbmcsIGlzUmVjb3JkLCBrZWJhYiwgbm9kZVByb3BzLCBub2RlVHlwZSwgb25seSwgcGFyc2VBcmdzLCByZWdleEZvckZvcm1hdCwgcm1Fc2NhcGVzLCBzZXRpZnksIHNoYWxsb3dDbG9uZSwgc2x1Z2lmeSwgc3ByZWFkLCB0b2tlbiwgdW5kZWZpbmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formkit/utils/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/@formkit/validation/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@formkit/validation/dist/index.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createValidationPlugin\": function() { return /* binding */ createValidationPlugin; }\n/* harmony export */ });\n/* harmony import */ var _formkit_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formkit/core */ \"./node_modules/@formkit/core/dist/index.mjs\");\n/* harmony import */ var _formkit_observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formkit/observer */ \"./node_modules/@formkit/observer/dist/index.mjs\");\n/* harmony import */ var _formkit_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @formkit/utils */ \"./node_modules/@formkit/utils/dist/index.mjs\");\n\n\n\n\n/**\n * Message that gets set when the node is awaiting validation.\n */\nconst validatingMessage = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createMessage)({\n    type: 'state',\n    blocking: true,\n    visible: false,\n    value: true,\n    key: 'validating',\n});\n/**\n * The actual validation plugin function, everything must be bootstrapped here.\n * @param node - The node to bind validation to.\n * @public\n */\nfunction createValidationPlugin(baseRules = {}) {\n    return function validationPlugin(node) {\n        const availableRules = Object.assign({}, baseRules, node.props.validationRules);\n        // create an observed node\n        let observedNode = (0,_formkit_observer__WEBPACK_IMPORTED_MODULE_1__.createObserver)(node);\n        const state = { input: (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.token)(), rerun: null, isPassing: true };\n        let validation = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.cloneAny)(node.props.validation);\n        // If the node's validation prop changes, update the rules:\n        node.on('prop:validation', ({ payload: value }) => {\n            if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.eq)(validation, value))\n                return;\n            validation = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.cloneAny)(value);\n            // Destroy all observers that may re-trigger validation on an old stack\n            (0,_formkit_observer__WEBPACK_IMPORTED_MODULE_1__.removeListeners)(observedNode.receipts);\n            // Remove all existing messages before re-validating\n            node.store.filter(() => false, 'validation');\n            node.props.parsedRules = parseRules(value, availableRules);\n            observedNode.kill();\n            observedNode = (0,_formkit_observer__WEBPACK_IMPORTED_MODULE_1__.createObserver)(node);\n            validate(observedNode, node.props.parsedRules, state);\n        });\n        // Validate the field when this plugin is initialized\n        node.props.parsedRules = parseRules(validation, availableRules);\n        validate(observedNode, node.props.parsedRules, state);\n    };\n}\n/**\n * Given parsed validations, a value and a node, run the validations and set\n * the appropriate store messages on the node.\n * @param value - The value being validated\n * @param node - The Node this value belongs to\n * @param rules - The rules\n */\nfunction validate(node, validations, state) {\n    if ((0,_formkit_observer__WEBPACK_IMPORTED_MODULE_1__.isKilled)(node))\n        return;\n    state.input = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.token)();\n    state.isPassing = true;\n    node.store.filter((message) => !message.meta.removeImmediately, 'validation');\n    validations.forEach((validation) => validation.debounce && clearTimeout(validation.timer));\n    if (validations.length) {\n        node.store.set(validatingMessage);\n        run(0, validations, node, state, false, () => {\n            node.store.remove(validatingMessage.key);\n        });\n    }\n}\n/**\n * Runs validation rules recursively while collecting dependencies allowing for\n * cross-node validation rules that automatically re-trigger when a foreign\n * value is changed.\n * @param current - The index of the current validation rule\n * @param validations - The remaining validation rule stack to run\n * @param node - An observed node, the owner of this validation stack\n * @param state - An object of state information about this run\n * @param removeImmediately - Should messages created during this call be removed immediately when a new commit takes place?\n * @returns\n */\nfunction run(current, validations, node, state, removeImmediately, complete) {\n    const validation = validations[current];\n    if (!validation)\n        return complete();\n    const currentRun = state.input;\n    validation.state = null;\n    function next(async, result) {\n        state.isPassing = state.isPassing && !!result;\n        validation.queued = false;\n        const newDeps = node.stopObserve();\n        (0,_formkit_observer__WEBPACK_IMPORTED_MODULE_1__.applyListeners)(node, (0,_formkit_observer__WEBPACK_IMPORTED_MODULE_1__.diffDeps)(validation.deps, newDeps), () => {\n            validation.queued = true;\n            if (state.rerun)\n                clearTimeout(state.rerun);\n            state.rerun = setTimeout(validate, 0, node, validations, state);\n        });\n        validation.deps = newDeps;\n        if (state.input === currentRun) {\n            validation.state = result;\n            if (result === false) {\n                createFailedMessage(node, validation, removeImmediately || async);\n            }\n            else {\n                removeMessage(node, validation);\n            }\n            if (validations.length > current + 1) {\n                run(current + 1, validations, node, state, removeImmediately || async, complete);\n            }\n            else {\n                // The validation has completed\n                complete();\n            }\n        }\n    }\n    if ((!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.empty)(node.value) || !validation.skipEmpty) &&\n        (state.isPassing || validation.force)) {\n        if (validation.queued) {\n            runRule(validation, node, (result) => {\n                result instanceof Promise\n                    ? result.then((r) => next(true, r))\n                    : next(false, result);\n            });\n        }\n        else {\n            // In this case our rule is not queued, so literally nothing happened that\n            // would affect it, we just need to move past this rule and make no\n            // modifications to state\n            run(current + 1, validations, node, state, removeImmediately, complete);\n        }\n    }\n    else {\n        // This rule is not being run because either:\n        //  1. The field is empty and this rule should not run when empty\n        //  2. A previous validation rule is failing and this one is not forced\n        // In this case we should call next validation.\n        if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.empty)(node.value) && validation.skipEmpty && state.isPassing) {\n            // This node has an empty value so its validation was skipped. So we\n            // need to queue it up, we do that by starting an observation and just\n            // touching the value attribute.\n            node.observe();\n            node.value;\n        }\n        next(false, null);\n    }\n}\n/**\n * Run a validation rule debounced or not.\n * @param validation - A validation to debounce\n */\nfunction runRule(validation, node, after) {\n    if (validation.debounce) {\n        validation.timer = setTimeout(() => {\n            node.observe();\n            after(validation.rule(node, ...validation.args));\n        }, validation.debounce);\n    }\n    else {\n        node.observe();\n        after(validation.rule(node, ...validation.args));\n    }\n}\n/**\n * The messages given to this function have already been set on the node, but\n * any other validation messages on the node that are not included in this\n * stack should be removed because they have been resolved.\n * @param node - The node to operate on.\n * @param messages - A new stack of messages\n */\nfunction removeMessage(node, validation) {\n    const key = `rule_${validation.name}`;\n    if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(node.store, key)) {\n        node.store.remove(key);\n    }\n}\n/**\n *\n * @param value - The value that is failing\n * @param validation - The validation object\n */\nfunction createFailedMessage(node, validation, removeImmediately) {\n    const i18nArgs = createI18nArgs(node, validation);\n    const customMessage = createCustomMessage(node, validation, i18nArgs);\n    // Here we short circuit the i18n system to force the output.\n    const message = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createMessage)({\n        blocking: validation.blocking,\n        key: `rule_${validation.name}`,\n        meta: {\n            /**\n             * Use this key instead of the message root key to produce i18n validation\n             * messages.\n             */\n            messageKey: validation.name,\n            /**\n             * For messages that were created *by or after* a debounced or async\n             * validation rule — we make note of it so we can immediately remove them\n             * as soon as the next commit happens.\n             */\n            removeImmediately,\n            /**\n             * Determines if this message should be passed to localization.\n             */\n            localize: !customMessage,\n            /**\n             * The arguments that will be passed to the validation rules\n             */\n            i18nArgs,\n        },\n        type: 'validation',\n        value: customMessage || 'This field is not valid.',\n    });\n    node.store.set(message);\n    return message;\n}\n/**\n * Returns a custom validation message if applicable.\n * @param node - FormKit Node\n * @param validation - The validation rule being processed.\n */\nfunction createCustomMessage(node, validation, i18nArgs) {\n    const customMessage = node.props.validationMessages &&\n        (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(node.props.validationMessages, validation.name)\n        ? node.props.validationMessages[validation.name]\n        : undefined;\n    if (typeof customMessage === 'function') {\n        return customMessage(...i18nArgs);\n    }\n    return customMessage;\n}\n/**\n * Creates the arguments passed to the i18n\n * @param node - The node that performed the validation\n * @param validation - The validation that failed\n */\nfunction createI18nArgs(node, validation) {\n    // If a custom message has been found, short circuit the i18n system.\n    return [\n        {\n            node,\n            name: createMessageName(node),\n            args: validation.args,\n        },\n    ];\n}\n/**\n * The name used in validation messages.\n * @param node - The node to display\n * @returns\n */\nfunction createMessageName(node) {\n    if (typeof node.props.validationLabel === 'function') {\n        return node.props.validationLabel(node);\n    }\n    return (node.props.validationLabel ||\n        node.props.label ||\n        node.props.name ||\n        String(node.name));\n}\n/**\n * Describes hints, must also be changed in the debounceExtractor.\n */\nconst hintPattern = '(?:[\\\\*+?()0-9]+)';\n/**\n * A pattern to describe rule names. Rules names can only contain letters,\n * numbers, and underscores and must start with a letter.\n */\nconst rulePattern = '[a-zA-Z][a-zA-Z0-9_]+';\n/**\n * Regular expression for extracting rule data.\n */\nconst ruleExtractor = new RegExp(`^(${hintPattern}?${rulePattern})(?:\\\\:(.*)+)?$`, 'i');\n/**\n * Validation hints are special characters preceding a validation rule, like\n * !phone\n */\nconst hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, 'i');\n/**\n * Given a hint string like ^(200)? or ^? or (200)?^ extract the hints to\n * matches.\n */\nconst debounceExtractor = /([\\*+?]+)?(\\(\\d+\\))([\\*+?]+)?/;\n/**\n * Determines if a given string is in the proper debounce format.\n */\nconst hasDebounce = /\\(\\d+\\)/;\n/**\n * The default values of the available validation hints.\n */\nconst defaultHints = {\n    blocking: true,\n    debounce: 0,\n    force: false,\n    skipEmpty: true,\n    name: '',\n};\n/**\n * Parse validation intents and strings into validation rule stacks.\n * @param validation - Either a string a validation rules, or proper array of structured rules.\n * @internal\n */\nfunction parseRules(validation, rules) {\n    if (!validation)\n        return [];\n    const intents = typeof validation === 'string'\n        ? extractRules(validation)\n        : (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.clone)(validation);\n    return intents.reduce((validations, args) => {\n        let rule = args.shift();\n        const hints = {};\n        if (typeof rule === 'string') {\n            const [ruleName, parsedHints] = parseHints(rule);\n            if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(rules, ruleName)) {\n                rule = rules[ruleName];\n                Object.assign(hints, parsedHints);\n            }\n        }\n        if (typeof rule === 'function') {\n            validations.push({\n                rule,\n                args,\n                timer: 0,\n                state: null,\n                queued: true,\n                deps: new Map(),\n                ...defaultHints,\n                ...fnHints(hints, rule),\n            });\n        }\n        return validations;\n    }, []);\n}\n/**\n * A string of validation rules written in FormKitRule notation.\n * @param validation - The string of rules\n * @internal\n */\nfunction extractRules(validation) {\n    return validation.split('|').reduce((rules, rule) => {\n        const parsedRule = parseRule(rule);\n        if (parsedRule) {\n            rules.push(parsedRule);\n        }\n        return rules;\n    }, []);\n}\n/**\n * Given a rule like confirm:password_confirm produce a FormKitValidationIntent\n * @param rule - A string representing a validation rule.\n * @returns\n */\nfunction parseRule(rule) {\n    const trimmed = rule.trim();\n    if (trimmed) {\n        const matches = trimmed.match(ruleExtractor);\n        if (matches && typeof matches[1] === 'string') {\n            const ruleName = matches[1].trim();\n            const args = matches[2] && typeof matches[2] === 'string'\n                ? matches[2].split(',').map((s) => s.trim())\n                : [];\n            return [ruleName, ...args];\n        }\n    }\n    return false;\n}\n/**\n * Given a rule name, detect if there are any additional hints like !\n * @param ruleName - string representing a rule name\n * @returns\n */\nfunction parseHints(ruleName) {\n    const matches = ruleName.match(hintExtractor);\n    if (!matches) {\n        return [ruleName, { name: ruleName }];\n    }\n    const map = {\n        '*': { force: true },\n        '+': { skipEmpty: false },\n        '?': { blocking: false },\n    };\n    const [, hints, rule] = matches;\n    const hintGroups = hasDebounce.test(hints)\n        ? hints.match(debounceExtractor) || []\n        : [, hints];\n    return [\n        rule,\n        [hintGroups[1], hintGroups[2], hintGroups[3]].reduce((hints, group) => {\n            if (!group)\n                return hints;\n            if (hasDebounce.test(group)) {\n                hints.debounce = parseInt(group.substr(1, group.length - 1));\n            }\n            else {\n                group\n                    .split('')\n                    .forEach((hint) => (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(map, hint) && Object.assign(hints, map[hint]));\n            }\n            return hints;\n        }, { name: rule }),\n    ];\n}\n/**\n * Extracts hint properties from the validation rule function itself and applies\n * them if they are not already in the set of validation hints extracted from\n * strings.\n * @param existingHints - An existing set of hints already parsed\n * @param rule - The actual rule function, which can contain hint properties\n * @returns\n */\nfunction fnHints(existingHints, rule) {\n    if (!existingHints.name) {\n        existingHints.name = rule.ruleName || rule.name;\n    }\n    return ['skipEmpty', 'force', 'debounce', 'blocking'].reduce((hints, hint) => {\n        if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(rule, hint) && !(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(hints, hint)) {\n            Object.assign(hints, {\n                [hint]: rule[hint],\n            });\n        }\n        return hints;\n    }, existingHints);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvdmFsaWRhdGlvbi9kaXN0L2luZGV4Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3Jta2l0L3ZhbGlkYXRpb24vZGlzdC9pbmRleC5tanM/NjE1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVNZXNzYWdlIH0gZnJvbSAnQGZvcm1raXQvY29yZSc7XG5pbXBvcnQgeyBjcmVhdGVPYnNlcnZlciwgcmVtb3ZlTGlzdGVuZXJzLCBpc0tpbGxlZCwgYXBwbHlMaXN0ZW5lcnMsIGRpZmZEZXBzIH0gZnJvbSAnQGZvcm1raXQvb2JzZXJ2ZXInO1xuaW1wb3J0IHsgdG9rZW4sIGNsb25lQW55LCBlcSwgZW1wdHksIGNsb25lLCBoYXMgfSBmcm9tICdAZm9ybWtpdC91dGlscyc7XG5cbi8qKlxuICogTWVzc2FnZSB0aGF0IGdldHMgc2V0IHdoZW4gdGhlIG5vZGUgaXMgYXdhaXRpbmcgdmFsaWRhdGlvbi5cbiAqL1xuY29uc3QgdmFsaWRhdGluZ01lc3NhZ2UgPSBjcmVhdGVNZXNzYWdlKHtcbiAgICB0eXBlOiAnc3RhdGUnLFxuICAgIGJsb2NraW5nOiB0cnVlLFxuICAgIHZpc2libGU6IGZhbHNlLFxuICAgIHZhbHVlOiB0cnVlLFxuICAgIGtleTogJ3ZhbGlkYXRpbmcnLFxufSk7XG4vKipcbiAqIFRoZSBhY3R1YWwgdmFsaWRhdGlvbiBwbHVnaW4gZnVuY3Rpb24sIGV2ZXJ5dGhpbmcgbXVzdCBiZSBib290c3RyYXBwZWQgaGVyZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmluZCB2YWxpZGF0aW9uIHRvLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0aW9uUGx1Z2luKGJhc2VSdWxlcyA9IHt9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHZhbGlkYXRpb25QbHVnaW4obm9kZSkge1xuICAgICAgICBjb25zdCBhdmFpbGFibGVSdWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VSdWxlcywgbm9kZS5wcm9wcy52YWxpZGF0aW9uUnVsZXMpO1xuICAgICAgICAvLyBjcmVhdGUgYW4gb2JzZXJ2ZWQgbm9kZVxuICAgICAgICBsZXQgb2JzZXJ2ZWROb2RlID0gY3JlYXRlT2JzZXJ2ZXIobm9kZSk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0geyBpbnB1dDogdG9rZW4oKSwgcmVydW46IG51bGwsIGlzUGFzc2luZzogdHJ1ZSB9O1xuICAgICAgICBsZXQgdmFsaWRhdGlvbiA9IGNsb25lQW55KG5vZGUucHJvcHMudmFsaWRhdGlvbik7XG4gICAgICAgIC8vIElmIHRoZSBub2RlJ3MgdmFsaWRhdGlvbiBwcm9wIGNoYW5nZXMsIHVwZGF0ZSB0aGUgcnVsZXM6XG4gICAgICAgIG5vZGUub24oJ3Byb3A6dmFsaWRhdGlvbicsICh7IHBheWxvYWQ6IHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChlcSh2YWxpZGF0aW9uLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFsaWRhdGlvbiA9IGNsb25lQW55KHZhbHVlKTtcbiAgICAgICAgICAgIC8vIERlc3Ryb3kgYWxsIG9ic2VydmVycyB0aGF0IG1heSByZS10cmlnZ2VyIHZhbGlkYXRpb24gb24gYW4gb2xkIHN0YWNrXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMob2JzZXJ2ZWROb2RlLnJlY2VpcHRzKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgZXhpc3RpbmcgbWVzc2FnZXMgYmVmb3JlIHJlLXZhbGlkYXRpbmdcbiAgICAgICAgICAgIG5vZGUuc3RvcmUuZmlsdGVyKCgpID0+IGZhbHNlLCAndmFsaWRhdGlvbicpO1xuICAgICAgICAgICAgbm9kZS5wcm9wcy5wYXJzZWRSdWxlcyA9IHBhcnNlUnVsZXModmFsdWUsIGF2YWlsYWJsZVJ1bGVzKTtcbiAgICAgICAgICAgIG9ic2VydmVkTm9kZS5raWxsKCk7XG4gICAgICAgICAgICBvYnNlcnZlZE5vZGUgPSBjcmVhdGVPYnNlcnZlcihub2RlKTtcbiAgICAgICAgICAgIHZhbGlkYXRlKG9ic2VydmVkTm9kZSwgbm9kZS5wcm9wcy5wYXJzZWRSdWxlcywgc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGZpZWxkIHdoZW4gdGhpcyBwbHVnaW4gaXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgbm9kZS5wcm9wcy5wYXJzZWRSdWxlcyA9IHBhcnNlUnVsZXModmFsaWRhdGlvbiwgYXZhaWxhYmxlUnVsZXMpO1xuICAgICAgICB2YWxpZGF0ZShvYnNlcnZlZE5vZGUsIG5vZGUucHJvcHMucGFyc2VkUnVsZXMsIHN0YXRlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBHaXZlbiBwYXJzZWQgdmFsaWRhdGlvbnMsIGEgdmFsdWUgYW5kIGEgbm9kZSwgcnVuIHRoZSB2YWxpZGF0aW9ucyBhbmQgc2V0XG4gKiB0aGUgYXBwcm9wcmlhdGUgc3RvcmUgbWVzc2FnZXMgb24gdGhlIG5vZGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgYmVpbmcgdmFsaWRhdGVkXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBOb2RlIHRoaXMgdmFsdWUgYmVsb25ncyB0b1xuICogQHBhcmFtIHJ1bGVzIC0gVGhlIHJ1bGVzXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIHZhbGlkYXRpb25zLCBzdGF0ZSkge1xuICAgIGlmIChpc0tpbGxlZChub2RlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHN0YXRlLmlucHV0ID0gdG9rZW4oKTtcbiAgICBzdGF0ZS5pc1Bhc3NpbmcgPSB0cnVlO1xuICAgIG5vZGUuc3RvcmUuZmlsdGVyKChtZXNzYWdlKSA9PiAhbWVzc2FnZS5tZXRhLnJlbW92ZUltbWVkaWF0ZWx5LCAndmFsaWRhdGlvbicpO1xuICAgIHZhbGlkYXRpb25zLmZvckVhY2goKHZhbGlkYXRpb24pID0+IHZhbGlkYXRpb24uZGVib3VuY2UgJiYgY2xlYXJUaW1lb3V0KHZhbGlkYXRpb24udGltZXIpKTtcbiAgICBpZiAodmFsaWRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUuc3RvcmUuc2V0KHZhbGlkYXRpbmdNZXNzYWdlKTtcbiAgICAgICAgcnVuKDAsIHZhbGlkYXRpb25zLCBub2RlLCBzdGF0ZSwgZmFsc2UsICgpID0+IHtcbiAgICAgICAgICAgIG5vZGUuc3RvcmUucmVtb3ZlKHZhbGlkYXRpbmdNZXNzYWdlLmtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogUnVucyB2YWxpZGF0aW9uIHJ1bGVzIHJlY3Vyc2l2ZWx5IHdoaWxlIGNvbGxlY3RpbmcgZGVwZW5kZW5jaWVzIGFsbG93aW5nIGZvclxuICogY3Jvc3Mtbm9kZSB2YWxpZGF0aW9uIHJ1bGVzIHRoYXQgYXV0b21hdGljYWxseSByZS10cmlnZ2VyIHdoZW4gYSBmb3JlaWduXG4gKiB2YWx1ZSBpcyBjaGFuZ2VkLlxuICogQHBhcmFtIGN1cnJlbnQgLSBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgdmFsaWRhdGlvbiBydWxlXG4gKiBAcGFyYW0gdmFsaWRhdGlvbnMgLSBUaGUgcmVtYWluaW5nIHZhbGlkYXRpb24gcnVsZSBzdGFjayB0byBydW5cbiAqIEBwYXJhbSBub2RlIC0gQW4gb2JzZXJ2ZWQgbm9kZSwgdGhlIG93bmVyIG9mIHRoaXMgdmFsaWRhdGlvbiBzdGFja1xuICogQHBhcmFtIHN0YXRlIC0gQW4gb2JqZWN0IG9mIHN0YXRlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgcnVuXG4gKiBAcGFyYW0gcmVtb3ZlSW1tZWRpYXRlbHkgLSBTaG91bGQgbWVzc2FnZXMgY3JlYXRlZCBkdXJpbmcgdGhpcyBjYWxsIGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgd2hlbiBhIG5ldyBjb21taXQgdGFrZXMgcGxhY2U/XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBydW4oY3VycmVudCwgdmFsaWRhdGlvbnMsIG5vZGUsIHN0YXRlLCByZW1vdmVJbW1lZGlhdGVseSwgY29tcGxldGUpIHtcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGlvbnNbY3VycmVudF07XG4gICAgaWYgKCF2YWxpZGF0aW9uKVxuICAgICAgICByZXR1cm4gY29tcGxldGUoKTtcbiAgICBjb25zdCBjdXJyZW50UnVuID0gc3RhdGUuaW5wdXQ7XG4gICAgdmFsaWRhdGlvbi5zdGF0ZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gbmV4dChhc3luYywgcmVzdWx0KSB7XG4gICAgICAgIHN0YXRlLmlzUGFzc2luZyA9IHN0YXRlLmlzUGFzc2luZyAmJiAhIXJlc3VsdDtcbiAgICAgICAgdmFsaWRhdGlvbi5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbmV3RGVwcyA9IG5vZGUuc3RvcE9ic2VydmUoKTtcbiAgICAgICAgYXBwbHlMaXN0ZW5lcnMobm9kZSwgZGlmZkRlcHModmFsaWRhdGlvbi5kZXBzLCBuZXdEZXBzKSwgKCkgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGlvbi5xdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlcnVuKVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5yZXJ1bik7XG4gICAgICAgICAgICBzdGF0ZS5yZXJ1biA9IHNldFRpbWVvdXQodmFsaWRhdGUsIDAsIG5vZGUsIHZhbGlkYXRpb25zLCBzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YWxpZGF0aW9uLmRlcHMgPSBuZXdEZXBzO1xuICAgICAgICBpZiAoc3RhdGUuaW5wdXQgPT09IGN1cnJlbnRSdW4pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24uc3RhdGUgPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUZhaWxlZE1lc3NhZ2Uobm9kZSwgdmFsaWRhdGlvbiwgcmVtb3ZlSW1tZWRpYXRlbHkgfHwgYXN5bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTWVzc2FnZShub2RlLCB2YWxpZGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9ucy5sZW5ndGggPiBjdXJyZW50ICsgMSkge1xuICAgICAgICAgICAgICAgIHJ1bihjdXJyZW50ICsgMSwgdmFsaWRhdGlvbnMsIG5vZGUsIHN0YXRlLCByZW1vdmVJbW1lZGlhdGVseSB8fCBhc3luYywgY29tcGxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHZhbGlkYXRpb24gaGFzIGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCghZW1wdHkobm9kZS52YWx1ZSkgfHwgIXZhbGlkYXRpb24uc2tpcEVtcHR5KSAmJlxuICAgICAgICAoc3RhdGUuaXNQYXNzaW5nIHx8IHZhbGlkYXRpb24uZm9yY2UpKSB7XG4gICAgICAgIGlmICh2YWxpZGF0aW9uLnF1ZXVlZCkge1xuICAgICAgICAgICAgcnVuUnVsZSh2YWxpZGF0aW9uLCBub2RlLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC50aGVuKChyKSA9PiBuZXh0KHRydWUsIHIpKVxuICAgICAgICAgICAgICAgICAgICA6IG5leHQoZmFsc2UsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSBvdXIgcnVsZSBpcyBub3QgcXVldWVkLCBzbyBsaXRlcmFsbHkgbm90aGluZyBoYXBwZW5lZCB0aGF0XG4gICAgICAgICAgICAvLyB3b3VsZCBhZmZlY3QgaXQsIHdlIGp1c3QgbmVlZCB0byBtb3ZlIHBhc3QgdGhpcyBydWxlIGFuZCBtYWtlIG5vXG4gICAgICAgICAgICAvLyBtb2RpZmljYXRpb25zIHRvIHN0YXRlXG4gICAgICAgICAgICBydW4oY3VycmVudCArIDEsIHZhbGlkYXRpb25zLCBub2RlLCBzdGF0ZSwgcmVtb3ZlSW1tZWRpYXRlbHksIGNvbXBsZXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBydWxlIGlzIG5vdCBiZWluZyBydW4gYmVjYXVzZSBlaXRoZXI6XG4gICAgICAgIC8vICAxLiBUaGUgZmllbGQgaXMgZW1wdHkgYW5kIHRoaXMgcnVsZSBzaG91bGQgbm90IHJ1biB3aGVuIGVtcHR5XG4gICAgICAgIC8vICAyLiBBIHByZXZpb3VzIHZhbGlkYXRpb24gcnVsZSBpcyBmYWlsaW5nIGFuZCB0aGlzIG9uZSBpcyBub3QgZm9yY2VkXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBzaG91bGQgY2FsbCBuZXh0IHZhbGlkYXRpb24uXG4gICAgICAgIGlmIChlbXB0eShub2RlLnZhbHVlKSAmJiB2YWxpZGF0aW9uLnNraXBFbXB0eSAmJiBzdGF0ZS5pc1Bhc3NpbmcpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBoYXMgYW4gZW1wdHkgdmFsdWUgc28gaXRzIHZhbGlkYXRpb24gd2FzIHNraXBwZWQuIFNvIHdlXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHF1ZXVlIGl0IHVwLCB3ZSBkbyB0aGF0IGJ5IHN0YXJ0aW5nIGFuIG9ic2VydmF0aW9uIGFuZCBqdXN0XG4gICAgICAgICAgICAvLyB0b3VjaGluZyB0aGUgdmFsdWUgYXR0cmlidXRlLlxuICAgICAgICAgICAgbm9kZS5vYnNlcnZlKCk7XG4gICAgICAgICAgICBub2RlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoZmFsc2UsIG51bGwpO1xuICAgIH1cbn1cbi8qKlxuICogUnVuIGEgdmFsaWRhdGlvbiBydWxlIGRlYm91bmNlZCBvciBub3QuXG4gKiBAcGFyYW0gdmFsaWRhdGlvbiAtIEEgdmFsaWRhdGlvbiB0byBkZWJvdW5jZVxuICovXG5mdW5jdGlvbiBydW5SdWxlKHZhbGlkYXRpb24sIG5vZGUsIGFmdGVyKSB7XG4gICAgaWYgKHZhbGlkYXRpb24uZGVib3VuY2UpIHtcbiAgICAgICAgdmFsaWRhdGlvbi50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbm9kZS5vYnNlcnZlKCk7XG4gICAgICAgICAgICBhZnRlcih2YWxpZGF0aW9uLnJ1bGUobm9kZSwgLi4udmFsaWRhdGlvbi5hcmdzKSk7XG4gICAgICAgIH0sIHZhbGlkYXRpb24uZGVib3VuY2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5vYnNlcnZlKCk7XG4gICAgICAgIGFmdGVyKHZhbGlkYXRpb24ucnVsZShub2RlLCAuLi52YWxpZGF0aW9uLmFyZ3MpKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBtZXNzYWdlcyBnaXZlbiB0byB0aGlzIGZ1bmN0aW9uIGhhdmUgYWxyZWFkeSBiZWVuIHNldCBvbiB0aGUgbm9kZSwgYnV0XG4gKiBhbnkgb3RoZXIgdmFsaWRhdGlvbiBtZXNzYWdlcyBvbiB0aGUgbm9kZSB0aGF0IGFyZSBub3QgaW5jbHVkZWQgaW4gdGhpc1xuICogc3RhY2sgc2hvdWxkIGJlIHJlbW92ZWQgYmVjYXVzZSB0aGV5IGhhdmUgYmVlbiByZXNvbHZlZC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gb3BlcmF0ZSBvbi5cbiAqIEBwYXJhbSBtZXNzYWdlcyAtIEEgbmV3IHN0YWNrIG9mIG1lc3NhZ2VzXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZU1lc3NhZ2Uobm9kZSwgdmFsaWRhdGlvbikge1xuICAgIGNvbnN0IGtleSA9IGBydWxlXyR7dmFsaWRhdGlvbi5uYW1lfWA7XG4gICAgaWYgKGhhcyhub2RlLnN0b3JlLCBrZXkpKSB7XG4gICAgICAgIG5vZGUuc3RvcmUucmVtb3ZlKGtleSk7XG4gICAgfVxufVxuLyoqXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgaXMgZmFpbGluZ1xuICogQHBhcmFtIHZhbGlkYXRpb24gLSBUaGUgdmFsaWRhdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFpbGVkTWVzc2FnZShub2RlLCB2YWxpZGF0aW9uLCByZW1vdmVJbW1lZGlhdGVseSkge1xuICAgIGNvbnN0IGkxOG5BcmdzID0gY3JlYXRlSTE4bkFyZ3Mobm9kZSwgdmFsaWRhdGlvbik7XG4gICAgY29uc3QgY3VzdG9tTWVzc2FnZSA9IGNyZWF0ZUN1c3RvbU1lc3NhZ2Uobm9kZSwgdmFsaWRhdGlvbiwgaTE4bkFyZ3MpO1xuICAgIC8vIEhlcmUgd2Ugc2hvcnQgY2lyY3VpdCB0aGUgaTE4biBzeXN0ZW0gdG8gZm9yY2UgdGhlIG91dHB1dC5cbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlTWVzc2FnZSh7XG4gICAgICAgIGJsb2NraW5nOiB2YWxpZGF0aW9uLmJsb2NraW5nLFxuICAgICAgICBrZXk6IGBydWxlXyR7dmFsaWRhdGlvbi5uYW1lfWAsXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNlIHRoaXMga2V5IGluc3RlYWQgb2YgdGhlIG1lc3NhZ2Ugcm9vdCBrZXkgdG8gcHJvZHVjZSBpMThuIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAqIG1lc3NhZ2VzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtZXNzYWdlS2V5OiB2YWxpZGF0aW9uLm5hbWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciBtZXNzYWdlcyB0aGF0IHdlcmUgY3JlYXRlZCAqYnkgb3IgYWZ0ZXIqIGEgZGVib3VuY2VkIG9yIGFzeW5jXG4gICAgICAgICAgICAgKiB2YWxpZGF0aW9uIHJ1bGUg4oCUIHdlIG1ha2Ugbm90ZSBvZiBpdCBzbyB3ZSBjYW4gaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZW1cbiAgICAgICAgICAgICAqIGFzIHNvb24gYXMgdGhlIG5leHQgY29tbWl0IGhhcHBlbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlbW92ZUltbWVkaWF0ZWx5LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgbWVzc2FnZSBzaG91bGQgYmUgcGFzc2VkIHRvIGxvY2FsaXphdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbG9jYWxpemU6ICFjdXN0b21NZXNzYWdlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHZhbGlkYXRpb24gcnVsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaTE4bkFyZ3MsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICd2YWxpZGF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGN1c3RvbU1lc3NhZ2UgfHwgJ1RoaXMgZmllbGQgaXMgbm90IHZhbGlkLicsXG4gICAgfSk7XG4gICAgbm9kZS5zdG9yZS5zZXQobWVzc2FnZSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vKipcbiAqIFJldHVybnMgYSBjdXN0b20gdmFsaWRhdGlvbiBtZXNzYWdlIGlmIGFwcGxpY2FibGUuXG4gKiBAcGFyYW0gbm9kZSAtIEZvcm1LaXQgTm9kZVxuICogQHBhcmFtIHZhbGlkYXRpb24gLSBUaGUgdmFsaWRhdGlvbiBydWxlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tTWVzc2FnZShub2RlLCB2YWxpZGF0aW9uLCBpMThuQXJncykge1xuICAgIGNvbnN0IGN1c3RvbU1lc3NhZ2UgPSBub2RlLnByb3BzLnZhbGlkYXRpb25NZXNzYWdlcyAmJlxuICAgICAgICBoYXMobm9kZS5wcm9wcy52YWxpZGF0aW9uTWVzc2FnZXMsIHZhbGlkYXRpb24ubmFtZSlcbiAgICAgICAgPyBub2RlLnByb3BzLnZhbGlkYXRpb25NZXNzYWdlc1t2YWxpZGF0aW9uLm5hbWVdXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgY3VzdG9tTWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3VzdG9tTWVzc2FnZSguLi5pMThuQXJncyk7XG4gICAgfVxuICAgIHJldHVybiBjdXN0b21NZXNzYWdlO1xufVxuLyoqXG4gKiBDcmVhdGVzIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBpMThuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRoYXQgcGVyZm9ybWVkIHRoZSB2YWxpZGF0aW9uXG4gKiBAcGFyYW0gdmFsaWRhdGlvbiAtIFRoZSB2YWxpZGF0aW9uIHRoYXQgZmFpbGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUkxOG5BcmdzKG5vZGUsIHZhbGlkYXRpb24pIHtcbiAgICAvLyBJZiBhIGN1c3RvbSBtZXNzYWdlIGhhcyBiZWVuIGZvdW5kLCBzaG9ydCBjaXJjdWl0IHRoZSBpMThuIHN5c3RlbS5cbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbmFtZTogY3JlYXRlTWVzc2FnZU5hbWUobm9kZSksXG4gICAgICAgICAgICBhcmdzOiB2YWxpZGF0aW9uLmFyZ3MsXG4gICAgICAgIH0sXG4gICAgXTtcbn1cbi8qKlxuICogVGhlIG5hbWUgdXNlZCBpbiB2YWxpZGF0aW9uIG1lc3NhZ2VzLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBkaXNwbGF5XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlTmFtZShub2RlKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlLnByb3BzLnZhbGlkYXRpb25MYWJlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbm9kZS5wcm9wcy52YWxpZGF0aW9uTGFiZWwobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiAobm9kZS5wcm9wcy52YWxpZGF0aW9uTGFiZWwgfHxcbiAgICAgICAgbm9kZS5wcm9wcy5sYWJlbCB8fFxuICAgICAgICBub2RlLnByb3BzLm5hbWUgfHxcbiAgICAgICAgU3RyaW5nKG5vZGUubmFtZSkpO1xufVxuLyoqXG4gKiBEZXNjcmliZXMgaGludHMsIG11c3QgYWxzbyBiZSBjaGFuZ2VkIGluIHRoZSBkZWJvdW5jZUV4dHJhY3Rvci5cbiAqL1xuY29uc3QgaGludFBhdHRlcm4gPSAnKD86W1xcXFwqKz8oKTAtOV0rKSc7XG4vKipcbiAqIEEgcGF0dGVybiB0byBkZXNjcmliZSBydWxlIG5hbWVzLiBSdWxlcyBuYW1lcyBjYW4gb25seSBjb250YWluIGxldHRlcnMsXG4gKiBudW1iZXJzLCBhbmQgdW5kZXJzY29yZXMgYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci5cbiAqL1xuY29uc3QgcnVsZVBhdHRlcm4gPSAnW2EtekEtWl1bYS16QS1aMC05X10rJztcbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIGZvciBleHRyYWN0aW5nIHJ1bGUgZGF0YS5cbiAqL1xuY29uc3QgcnVsZUV4dHJhY3RvciA9IG5ldyBSZWdFeHAoYF4oJHtoaW50UGF0dGVybn0/JHtydWxlUGF0dGVybn0pKD86XFxcXDooLiopKyk/JGAsICdpJyk7XG4vKipcbiAqIFZhbGlkYXRpb24gaGludHMgYXJlIHNwZWNpYWwgY2hhcmFjdGVycyBwcmVjZWRpbmcgYSB2YWxpZGF0aW9uIHJ1bGUsIGxpa2VcbiAqICFwaG9uZVxuICovXG5jb25zdCBoaW50RXh0cmFjdG9yID0gbmV3IFJlZ0V4cChgXigke2hpbnRQYXR0ZXJufSkoJHtydWxlUGF0dGVybn0pJGAsICdpJyk7XG4vKipcbiAqIEdpdmVuIGEgaGludCBzdHJpbmcgbGlrZSBeKDIwMCk/IG9yIF4/IG9yICgyMDApP14gZXh0cmFjdCB0aGUgaGludHMgdG9cbiAqIG1hdGNoZXMuXG4gKi9cbmNvbnN0IGRlYm91bmNlRXh0cmFjdG9yID0gLyhbXFwqKz9dKyk/KFxcKFxcZCtcXCkpKFtcXCorP10rKT8vO1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gc3RyaW5nIGlzIGluIHRoZSBwcm9wZXIgZGVib3VuY2UgZm9ybWF0LlxuICovXG5jb25zdCBoYXNEZWJvdW5jZSA9IC9cXChcXGQrXFwpLztcbi8qKlxuICogVGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBhdmFpbGFibGUgdmFsaWRhdGlvbiBoaW50cy5cbiAqL1xuY29uc3QgZGVmYXVsdEhpbnRzID0ge1xuICAgIGJsb2NraW5nOiB0cnVlLFxuICAgIGRlYm91bmNlOiAwLFxuICAgIGZvcmNlOiBmYWxzZSxcbiAgICBza2lwRW1wdHk6IHRydWUsXG4gICAgbmFtZTogJycsXG59O1xuLyoqXG4gKiBQYXJzZSB2YWxpZGF0aW9uIGludGVudHMgYW5kIHN0cmluZ3MgaW50byB2YWxpZGF0aW9uIHJ1bGUgc3RhY2tzLlxuICogQHBhcmFtIHZhbGlkYXRpb24gLSBFaXRoZXIgYSBzdHJpbmcgYSB2YWxpZGF0aW9uIHJ1bGVzLCBvciBwcm9wZXIgYXJyYXkgb2Ygc3RydWN0dXJlZCBydWxlcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwYXJzZVJ1bGVzKHZhbGlkYXRpb24sIHJ1bGVzKSB7XG4gICAgaWYgKCF2YWxpZGF0aW9uKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgaW50ZW50cyA9IHR5cGVvZiB2YWxpZGF0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGV4dHJhY3RSdWxlcyh2YWxpZGF0aW9uKVxuICAgICAgICA6IGNsb25lKHZhbGlkYXRpb24pO1xuICAgIHJldHVybiBpbnRlbnRzLnJlZHVjZSgodmFsaWRhdGlvbnMsIGFyZ3MpID0+IHtcbiAgICAgICAgbGV0IHJ1bGUgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IGhpbnRzID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IFtydWxlTmFtZSwgcGFyc2VkSGludHNdID0gcGFyc2VIaW50cyhydWxlKTtcbiAgICAgICAgICAgIGlmIChoYXMocnVsZXMsIHJ1bGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJ1bGUgPSBydWxlc1tydWxlTmFtZV07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoaW50cywgcGFyc2VkSGludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgcnVsZSxcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIHRpbWVyOiAwLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHF1ZXVlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZXBzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgLi4uZGVmYXVsdEhpbnRzLFxuICAgICAgICAgICAgICAgIC4uLmZuSGludHMoaGludHMsIHJ1bGUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25zO1xuICAgIH0sIFtdKTtcbn1cbi8qKlxuICogQSBzdHJpbmcgb2YgdmFsaWRhdGlvbiBydWxlcyB3cml0dGVuIGluIEZvcm1LaXRSdWxlIG5vdGF0aW9uLlxuICogQHBhcmFtIHZhbGlkYXRpb24gLSBUaGUgc3RyaW5nIG9mIHJ1bGVzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFJ1bGVzKHZhbGlkYXRpb24pIHtcbiAgICByZXR1cm4gdmFsaWRhdGlvbi5zcGxpdCgnfCcpLnJlZHVjZSgocnVsZXMsIHJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgcGFyc2VkUnVsZSA9IHBhcnNlUnVsZShydWxlKTtcbiAgICAgICAgaWYgKHBhcnNlZFJ1bGUpIHtcbiAgICAgICAgICAgIHJ1bGVzLnB1c2gocGFyc2VkUnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgIH0sIFtdKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBydWxlIGxpa2UgY29uZmlybTpwYXNzd29yZF9jb25maXJtIHByb2R1Y2UgYSBGb3JtS2l0VmFsaWRhdGlvbkludGVudFxuICogQHBhcmFtIHJ1bGUgLSBBIHN0cmluZyByZXByZXNlbnRpbmcgYSB2YWxpZGF0aW9uIHJ1bGUuXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBwYXJzZVJ1bGUocnVsZSkge1xuICAgIGNvbnN0IHRyaW1tZWQgPSBydWxlLnRyaW0oKTtcbiAgICBpZiAodHJpbW1lZCkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdHJpbW1lZC5tYXRjaChydWxlRXh0cmFjdG9yKTtcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgdHlwZW9mIG1hdGNoZXNbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBydWxlTmFtZSA9IG1hdGNoZXNbMV0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IG1hdGNoZXNbMl0gJiYgdHlwZW9mIG1hdGNoZXNbMl0gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBtYXRjaGVzWzJdLnNwbGl0KCcsJykubWFwKChzKSA9PiBzLnRyaW0oKSlcbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIFtydWxlTmFtZSwgLi4uYXJnc107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBHaXZlbiBhIHJ1bGUgbmFtZSwgZGV0ZWN0IGlmIHRoZXJlIGFyZSBhbnkgYWRkaXRpb25hbCBoaW50cyBsaWtlICFcbiAqIEBwYXJhbSBydWxlTmFtZSAtIHN0cmluZyByZXByZXNlbnRpbmcgYSBydWxlIG5hbWVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSGludHMocnVsZU5hbWUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gcnVsZU5hbWUubWF0Y2goaGludEV4dHJhY3Rvcik7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBbcnVsZU5hbWUsIHsgbmFtZTogcnVsZU5hbWUgfV07XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgICAgJyonOiB7IGZvcmNlOiB0cnVlIH0sXG4gICAgICAgICcrJzogeyBza2lwRW1wdHk6IGZhbHNlIH0sXG4gICAgICAgICc/JzogeyBibG9ja2luZzogZmFsc2UgfSxcbiAgICB9O1xuICAgIGNvbnN0IFssIGhpbnRzLCBydWxlXSA9IG1hdGNoZXM7XG4gICAgY29uc3QgaGludEdyb3VwcyA9IGhhc0RlYm91bmNlLnRlc3QoaGludHMpXG4gICAgICAgID8gaGludHMubWF0Y2goZGVib3VuY2VFeHRyYWN0b3IpIHx8IFtdXG4gICAgICAgIDogWywgaGludHNdO1xuICAgIHJldHVybiBbXG4gICAgICAgIHJ1bGUsXG4gICAgICAgIFtoaW50R3JvdXBzWzFdLCBoaW50R3JvdXBzWzJdLCBoaW50R3JvdXBzWzNdXS5yZWR1Y2UoKGhpbnRzLCBncm91cCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFncm91cClcbiAgICAgICAgICAgICAgICByZXR1cm4gaGludHM7XG4gICAgICAgICAgICBpZiAoaGFzRGVib3VuY2UudGVzdChncm91cCkpIHtcbiAgICAgICAgICAgICAgICBoaW50cy5kZWJvdW5jZSA9IHBhcnNlSW50KGdyb3VwLnN1YnN0cigxLCBncm91cC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cFxuICAgICAgICAgICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChoaW50KSA9PiBoYXMobWFwLCBoaW50KSAmJiBPYmplY3QuYXNzaWduKGhpbnRzLCBtYXBbaGludF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoaW50cztcbiAgICAgICAgfSwgeyBuYW1lOiBydWxlIH0pLFxuICAgIF07XG59XG4vKipcbiAqIEV4dHJhY3RzIGhpbnQgcHJvcGVydGllcyBmcm9tIHRoZSB2YWxpZGF0aW9uIHJ1bGUgZnVuY3Rpb24gaXRzZWxmIGFuZCBhcHBsaWVzXG4gKiB0aGVtIGlmIHRoZXkgYXJlIG5vdCBhbHJlYWR5IGluIHRoZSBzZXQgb2YgdmFsaWRhdGlvbiBoaW50cyBleHRyYWN0ZWQgZnJvbVxuICogc3RyaW5ncy5cbiAqIEBwYXJhbSBleGlzdGluZ0hpbnRzIC0gQW4gZXhpc3Rpbmcgc2V0IG9mIGhpbnRzIGFscmVhZHkgcGFyc2VkXG4gKiBAcGFyYW0gcnVsZSAtIFRoZSBhY3R1YWwgcnVsZSBmdW5jdGlvbiwgd2hpY2ggY2FuIGNvbnRhaW4gaGludCBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBmbkhpbnRzKGV4aXN0aW5nSGludHMsIHJ1bGUpIHtcbiAgICBpZiAoIWV4aXN0aW5nSGludHMubmFtZSkge1xuICAgICAgICBleGlzdGluZ0hpbnRzLm5hbWUgPSBydWxlLnJ1bGVOYW1lIHx8IHJ1bGUubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFsnc2tpcEVtcHR5JywgJ2ZvcmNlJywgJ2RlYm91bmNlJywgJ2Jsb2NraW5nJ10ucmVkdWNlKChoaW50cywgaGludCkgPT4ge1xuICAgICAgICBpZiAoaGFzKHJ1bGUsIGhpbnQpICYmICFoYXMoaGludHMsIGhpbnQpKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGhpbnRzLCB7XG4gICAgICAgICAgICAgICAgW2hpbnRdOiBydWxlW2hpbnRdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpbnRzO1xuICAgIH0sIGV4aXN0aW5nSGludHMpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVWYWxpZGF0aW9uUGx1Z2luIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formkit/validation/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/@formkit/vue/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@formkit/vue/dist/index.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormKit\": function() { return /* binding */ FormKit; },\n/* harmony export */   \"FormKitSchema\": function() { return /* binding */ FormKitSchema; },\n/* harmony export */   \"bindings\": function() { return /* binding */ vueBindings; },\n/* harmony export */   \"clearErrors\": function() { return /* reexport safe */ _formkit_core__WEBPACK_IMPORTED_MODULE_0__.clearErrors; },\n/* harmony export */   \"configSymbol\": function() { return /* binding */ configSymbol; },\n/* harmony export */   \"createInput\": function() { return /* binding */ createInput; },\n/* harmony export */   \"defaultConfig\": function() { return /* binding */ defaultConfig; },\n/* harmony export */   \"errorHandler\": function() { return /* reexport safe */ _formkit_core__WEBPACK_IMPORTED_MODULE_0__.errorHandler; },\n/* harmony export */   \"optionsSymbol\": function() { return /* binding */ optionsSymbol; },\n/* harmony export */   \"parentSymbol\": function() { return /* binding */ parentSymbol; },\n/* harmony export */   \"plugin\": function() { return /* binding */ plugin; },\n/* harmony export */   \"reset\": function() { return /* reexport safe */ _formkit_core__WEBPACK_IMPORTED_MODULE_0__.reset; },\n/* harmony export */   \"resetCount\": function() { return /* reexport safe */ _formkit_core__WEBPACK_IMPORTED_MODULE_0__.resetCount; },\n/* harmony export */   \"setErrors\": function() { return /* reexport safe */ _formkit_core__WEBPACK_IMPORTED_MODULE_0__.setErrors; },\n/* harmony export */   \"submitForm\": function() { return /* reexport safe */ _formkit_core__WEBPACK_IMPORTED_MODULE_0__.submitForm; },\n/* harmony export */   \"useInput\": function() { return /* binding */ useInput; },\n/* harmony export */   \"watchVerbose\": function() { return /* binding */ watchVerbose; }\n/* harmony export */ });\n/* harmony import */ var _formkit_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formkit/core */ \"./node_modules/@formkit/core/dist/index.mjs\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm-bundler.js\");\n/* harmony import */ var _formkit_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @formkit/utils */ \"./node_modules/@formkit/utils/dist/index.mjs\");\n/* harmony import */ var _formkit_inputs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @formkit/inputs */ \"./node_modules/@formkit/inputs/dist/index.mjs\");\n/* harmony import */ var _formkit_rules__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @formkit/rules */ \"./node_modules/@formkit/rules/dist/index.mjs\");\n/* harmony import */ var _formkit_validation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @formkit/validation */ \"./node_modules/@formkit/validation/dist/index.mjs\");\n/* harmony import */ var _formkit_i18n__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @formkit/i18n */ \"./node_modules/@formkit/i18n/dist/index.mjs\");\n/* harmony import */ var _formkit_observer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @formkit/observer */ \"./node_modules/@formkit/observer/dist/index.mjs\");\n/* harmony import */ var _formkit_dev__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @formkit/dev */ \"./node_modules/@formkit/dev/dist/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A registry of memoized schemas (in JSON) to their respective render function\n * and provider registry.\n */\nconst memo = {};\n/**\n * This symbol represents the current component instance during render. It is\n * critical for linking the current instance to the data required for render.\n */\nlet instanceKey;\n/**\n * A registry of scoped data produced during runtime that is keyed by the\n * instance symbol. For example data from: for-loop instances and slot data.\n */\nconst instanceScopes = new Map();\n/**\n * Indicates the a section of the schema is raw.\n */\nconst raw = '__raw__';\n/**\n * Is a class prop.\n */\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\n/**\n * Returns a reference as a placeholder to a specific location on an object.\n * @param data - A reactive data object\n * @param token - A dot-syntax string representing the object path\n * @returns\n */\nfunction getRef(token, data) {\n    const value = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(null);\n    if (token === 'get') {\n        const nodeRefs = {};\n        value.value = get$1.bind(null, nodeRefs);\n        return value;\n    }\n    const path = token.split('.');\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => (value.value = getValue(data, path)));\n    return value;\n}\n/**\n * Returns a value inside a set of data objects.\n * @param sets - An array of objects to search through\n * @param path - A array of string paths easily produced by split()\n * @returns\n */\nfunction getValue(set, path) {\n    if (Array.isArray(set)) {\n        for (const subset of set) {\n            const value = subset !== false && getValue(subset, path);\n            if (value !== undefined)\n                return value;\n        }\n        return undefined;\n    }\n    let foundValue = undefined;\n    path.reduce((obj, segment, i, arr) => {\n        if (typeof obj !== 'object') {\n            foundValue = undefined;\n            return arr.splice(1); // Forces an exit\n        }\n        const currentValue = obj[segment];\n        if (i === path.length - 1 && currentValue !== undefined) {\n            foundValue = currentValue;\n        }\n        return obj[segment];\n    }, set);\n    return foundValue;\n}\n/**\n * Get the node from the global registry\n * @param id - A dot-syntax string where the node is located.\n */\nfunction get$1(nodeRefs, id) {\n    if (typeof id !== 'string')\n        return (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.warn)(650);\n    if (!(id in nodeRefs))\n        nodeRefs[id] = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(undefined);\n    if (nodeRefs[id].value === undefined) {\n        nodeRefs[id].value = null;\n        const root = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.getNode)(id);\n        if (root)\n            nodeRefs[id].value = root.context;\n        (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.watchRegistry)(id, ({ payload: node }) => {\n            nodeRefs[id].value = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.isNode)(node) ? node.context : node;\n        });\n    }\n    return nodeRefs[id].value;\n}\n/**\n *\n * @param library - A library of concrete components to use\n * @param schema -\n * @returns\n */\nfunction parseSchema(library, schema) {\n    /**\n     * Given an if/then/else schema node, pre-compile the node and return the\n     * artifacts for the render function.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     */\n    function parseCondition(library, node) {\n        const condition = provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(node.if), { if: true });\n        const children = createElements(library, node.then);\n        const alternate = node.else ? createElements(library, node.else) : null;\n        return [condition, children, alternate];\n    }\n    /**\n     * Parses a conditional if/then/else attribute statement.\n     * @param data - The data object\n     * @param attr - The attribute\n     * @param _default - The default value\n     * @returns\n     */\n    function parseConditionAttr(attr, _default) {\n        var _a, _b;\n        const condition = provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(attr.if));\n        let b = () => _default;\n        let a = () => _default;\n        if (typeof attr.then === 'object') {\n            a = parseAttrs(attr.then, undefined);\n        }\n        else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {\n            a = provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(attr.then));\n        }\n        else {\n            a = () => attr.then;\n        }\n        if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(attr, 'else')) {\n            if (typeof attr.else === 'object') {\n                b = parseAttrs(attr.else);\n            }\n            else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {\n                b = provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(attr.else));\n            }\n            else {\n                b = () => attr.else;\n            }\n        }\n        return () => (condition() ? a() : b());\n    }\n    /**\n     * Parse attributes for dynamic content.\n     * @param attrs - Object of attributes\n     * @returns\n     */\n    function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\n        const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\n        const boundAttrs = bindExp ? provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(bindExp)) : () => ({});\n        const staticAttrs = {};\n        const setters = [\n            (attrs) => {\n                const bound = boundAttrs();\n                for (const attr in bound) {\n                    if (!explicitAttrs.has(attr)) {\n                        attrs[attr] = bound[attr];\n                    }\n                }\n            },\n        ];\n        if (unparsedAttrs) {\n            if ((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.isConditional)(unparsedAttrs)) {\n                // This is a root conditional object that must produce an object of\n                // attributes.\n                const condition = parseConditionAttr(unparsedAttrs, _default);\n                return condition;\n            }\n            // Some attributes are explicitly bound, we need to parse those ones\n            // using the compiler and create a dynamic \"setter\".\n            for (let attr in unparsedAttrs) {\n                const value = unparsedAttrs[attr];\n                let getValue;\n                const isStr = typeof value === 'string';\n                if (attr.startsWith(raw)) {\n                    // attributes prefixed with __raw__ should not be parsed\n                    attr = attr.substring(7);\n                    getValue = () => value;\n                }\n                else if (isStr &&\n                    value.startsWith('$') &&\n                    value.length > 1 &&\n                    !(value.startsWith('$reset') && isClassProp.test(attr))) {\n                    // Most attribute values starting with $ should be compiled\n                    // -class attributes starting with `$reset` should not be compiled\n                    getValue = provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(value));\n                }\n                else if (typeof value === 'object' && (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.isConditional)(value)) {\n                    // Conditional attrs require further processing\n                    getValue = parseConditionAttr(value, undefined);\n                }\n                else if (typeof value === 'object' && (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.isPojo)(value)) {\n                    // Sub-parse pojos\n                    getValue = parseAttrs(value);\n                }\n                else {\n                    // In all other cases, the value is static\n                    getValue = () => value;\n                    staticAttrs[attr] = value;\n                }\n                setters.push((attrs) => {\n                    attrs[attr] = getValue();\n                });\n            }\n        }\n        return () => {\n            const attrs = {};\n            setters.forEach((setter) => setter(attrs));\n            return attrs;\n        };\n    }\n    /**\n     * Given a single schema node, parse it and extract the value.\n     * @param data - A state object provided to each node\n     * @param node - The schema node being parsed\n     * @returns\n     */\n    function parseNode(library, _node) {\n        let element = null;\n        let attrs = () => null;\n        let condition = false;\n        let children = null;\n        let alternate = null;\n        let iterator = null;\n        let resolve = false;\n        const node = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.sugar)(_node);\n        if ((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.isDOM)(node)) {\n            // This is an actual HTML DOM element\n            element = node.$el;\n            attrs =\n                node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;\n        }\n        else if ((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.isComponent)(node)) {\n            // This is a Vue Component\n            if (typeof node.$cmp === 'string') {\n                if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(library, node.$cmp)) {\n                    element = library[node.$cmp];\n                }\n                else {\n                    element = node.$cmp;\n                    resolve = true;\n                }\n            }\n            else {\n                // in this case it must be an actual component\n                element = node.$cmp;\n            }\n            attrs = parseAttrs(node.props, node.bind);\n        }\n        else if ((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.isConditional)(node)) {\n            [condition, children, alternate] = parseCondition(library, node);\n        }\n        // This is the same as a \"v-if\" statement — not an if/else statement\n        if (!(0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.isConditional)(node) && 'if' in node) {\n            condition = provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(node.if));\n        }\n        else if (!(0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.isConditional)(node) && element === null) {\n            // In this odd case our element is actually a partial and\n            // we only want to render the children.\n            condition = () => true;\n        }\n        // Compile children down to a function\n        if ('children' in node && node.children) {\n            if (typeof node.children === 'string') {\n                // We are dealing with a raw string value\n                if (node.children.startsWith('$slots.')) {\n                    // this is a lone text node, turn it into a slot\n                    element = element === 'text' ? 'slot' : element;\n                    children = provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(node.children));\n                }\n                else if (node.children.startsWith('$') && node.children.length > 1) {\n                    const value = provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(node.children));\n                    children = () => String(value());\n                }\n                else {\n                    children = () => String(node.children);\n                }\n            }\n            else if (Array.isArray(node.children)) {\n                // We are dealing with node sub-children\n                children = createElements(library, node.children);\n            }\n            else {\n                // This is a conditional if/else clause\n                const [childCondition, c, a] = parseCondition(library, node.children);\n                children = (iterationData) => childCondition && childCondition()\n                    ? c && c(iterationData)\n                    : a && a(iterationData);\n            }\n        }\n        if ((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.isComponent)(node)) {\n            if (children) {\n                // Children of components need to be provided as an object of slots\n                // so we provide an object with the default slot provided as children.\n                // We also create a new scope for this default slot, and then on each\n                // render pass the scoped slot props to the scope.\n                const produceChildren = children;\n                children = (iterationData) => {\n                    return {\n                        default(slotData, key) {\n                            var _a, _b, _c, _d;\n                            // We need to switch the current instance key back to the one that\n                            // originally called this component's render function.\n                            const currentKey = instanceKey;\n                            if (key)\n                                instanceKey = key;\n                            if (slotData)\n                                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);\n                            if (iterationData)\n                                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);\n                            const c = produceChildren(iterationData);\n                            // Ensure our instance key never changed during runtime\n                            if (slotData)\n                                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();\n                            if (iterationData)\n                                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();\n                            instanceKey = currentKey;\n                            return c;\n                        },\n                    };\n                };\n                children.slot = true;\n            }\n            else {\n                // If we dont have any children, we still need to provide an object\n                // instead of an empty array (which raises a warning in vue)\n                children = () => ({});\n            }\n        }\n        // Compile the for loop down\n        if ('for' in node && node.for) {\n            const values = node.for.length === 3 ? node.for[2] : node.for[1];\n            const getValues = typeof values === 'string' && values.startsWith('$')\n                ? provider((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.compile)(values))\n                : () => values;\n            iterator = [\n                getValues,\n                node.for[0],\n                node.for.length === 3 ? String(node.for[1]) : null,\n            ];\n        }\n        return [condition, element, attrs, children, alternate, iterator, resolve];\n    }\n    /**\n     * Given a particular function that produces children, ensure that the second\n     * argument of all these slots is the original instance key being used to\n     * render the slots.\n     * @param children - The children() function that will produce slots\n     */\n    function createSlots(children, iterationData) {\n        const slots = children(iterationData);\n        const currentKey = instanceKey;\n        return Object.keys(slots).reduce((allSlots, slotName) => {\n            const slotFn = slots && slots[slotName];\n            allSlots[slotName] = (data) => {\n                return (slotFn && slotFn(data, currentKey)) || null;\n            };\n            return allSlots;\n        }, {});\n    }\n    /**\n     * Creates an element\n     * @param data - The context data available to the node\n     * @param node - The schema node to render\n     * @returns\n     */\n    function createElement(library, node) {\n        // Parses the schema node into pertinent parts\n        const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);\n        // This is a sub-render function (called within a render function). It must\n        // only use pre-compiled features, and be organized in the most efficient\n        // manner possible.\n        let createNodes = ((iterationData) => {\n            if (condition && element === null && children) {\n                // Handle conditional if/then statements\n                return condition()\n                    ? children(iterationData)\n                    : alternate && alternate(iterationData);\n            }\n            if (element && (!condition || condition())) {\n                // handle text nodes\n                if (element === 'text' && children) {\n                    return (0,vue__WEBPACK_IMPORTED_MODULE_1__.createTextVNode)(String(children()));\n                }\n                // Handle lone slots\n                if (element === 'slot' && children)\n                    return children(iterationData);\n                // Handle resolving components\n                const el = resolve ? (0,vue__WEBPACK_IMPORTED_MODULE_1__.resolveComponent)(element) : element;\n                // If we are rendering slots as children, ensure their instanceKey is properly added\n                const slots = (children === null || children === void 0 ? void 0 : children.slot)\n                    ? createSlots(children, iterationData)\n                    : null;\n                // Handle dom elements and components\n                return (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)(el, attrs(), (slots || (children ? children(iterationData) : [])));\n            }\n            return typeof alternate === 'function'\n                ? alternate(iterationData)\n                : alternate;\n        });\n        if (iterator) {\n            const repeatedNode = createNodes;\n            const [getValues, valueName, keyName] = iterator;\n            createNodes = (() => {\n                const _v = getValues();\n                const values = !isNaN(_v)\n                    ? Array(Number(_v))\n                        .fill(0)\n                        .map((_, i) => i)\n                    : _v;\n                const fragment = [];\n                if (typeof values !== 'object')\n                    return null;\n                const instanceScope = instanceScopes.get(instanceKey) || [];\n                for (const key in values) {\n                    const iterationData = Object.defineProperty({\n                        ...instanceScope.reduce((previousIterationData, scopedData) => {\n                            if (previousIterationData.__idata) {\n                                return { ...previousIterationData, ...scopedData };\n                            }\n                            return scopedData;\n                        }, {}),\n                        [valueName]: values[key],\n                        ...(keyName !== null ? { [keyName]: key } : {}),\n                    }, '__idata', { enumerable: false, value: true });\n                    instanceScope.unshift(iterationData);\n                    fragment.push(repeatedNode.bind(null, iterationData)());\n                    instanceScope.shift();\n                }\n                return fragment;\n            });\n        }\n        return createNodes;\n    }\n    /**\n     * Given a schema, parse it and return the resulting renderable nodes.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     * @returns\n     */\n    function createElements(library, schema) {\n        if (Array.isArray(schema)) {\n            const els = schema.map(createElement.bind(null, library));\n            return (iterationData) => els.map((element) => element(iterationData));\n        }\n        // Single node to render\n        const element = createElement(library, schema);\n        return (iterationData) => element(iterationData);\n    }\n    /**\n     * Data providers produced as a result of the compiler.\n     */\n    const providers = [];\n    /**\n     * Append the requisite compiler provider and return the compiled function.\n     * @param compiled - A compiled function\n     * @returns\n     */\n    function provider(compiled, hints = {}) {\n        const compiledFns = {};\n        providers.push((callback, key) => {\n            compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));\n        });\n        return () => compiledFns[instanceKey]();\n    }\n    /**\n     * Creates a new instance of a given schema — this either comes from a\n     * memoized copy of the parsed schema or a freshly parsed version. An symbol\n     * instance key, and dataProvider functions are passed in.\n     * @param providerCallback - A function that is called for each required provider\n     * @param key - a symbol representing the current instance\n     */\n    return function createInstance(providerCallback, key) {\n        const memoKey = JSON.stringify(schema);\n        const [render, compiledProviders] = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(memo, memoKey)\n            ? memo[memoKey]\n            : [createElements(library, schema), providers];\n        memo[memoKey] = [render, compiledProviders];\n        compiledProviders.forEach((compiledProvider) => {\n            compiledProvider(providerCallback, key);\n        });\n        return () => {\n            instanceKey = key;\n            return render();\n        };\n    };\n}\n/**\n * Checks the current runtime scope for data.\n * @param token - The token to lookup in the current scope\n * @param defaultValue - The default ref value to use if no scope is found.\n */\nfunction useScope(token, defaultValue) {\n    const scopedData = instanceScopes.get(instanceKey) || [];\n    let scopedValue = undefined;\n    if (scopedData.length) {\n        scopedValue = getValue(scopedData, token.split('.'));\n    }\n    return scopedValue === undefined ? defaultValue : scopedValue;\n}\n/**\n * Get the current scoped data and flatten it.\n */\nfunction slotData(data, key) {\n    return new Proxy(data, {\n        get(...args) {\n            let data = undefined;\n            const property = args[1];\n            if (typeof property === 'string') {\n                const prevKey = instanceKey;\n                instanceKey = key;\n                data = useScope(property, undefined);\n                instanceKey = prevKey;\n            }\n            return data !== undefined ? data : Reflect.get(...args);\n        },\n    });\n}\n/**\n * Provides data to a parsed schema.\n * @param provider - The SchemaProvider (output of calling parseSchema)\n * @param data - Data to fetch values from\n * @returns\n */\nfunction createRenderFn(instanceCreator, data, instanceKey) {\n    return instanceCreator((requirements, hints = {}) => {\n        return requirements.reduce((tokens, token) => {\n            if (token.startsWith('slots.')) {\n                const slot = token.substring(6);\n                const hasSlot = data.slots && (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(data.slots, slot);\n                if (hints.if) {\n                    // If statement — dont render the slot, check if it exists\n                    tokens[token] = () => hasSlot;\n                }\n                else if (data.slots && hasSlot) {\n                    // Render the slot with current scope data\n                    const scopedData = slotData(data, instanceKey);\n                    tokens[token] = () => data.slots[slot](scopedData);\n                    return tokens;\n                }\n            }\n            const value = getRef(token, data);\n            tokens[token] = () => useScope(token, value.value);\n            return tokens;\n        }, {});\n    }, instanceKey);\n}\nlet i = 0;\n/**\n * The FormKitSchema vue component:\n * @public\n */\nconst FormKitSchema = (0,vue__WEBPACK_IMPORTED_MODULE_1__.defineComponent)({\n    name: 'FormKitSchema',\n    props: {\n        schema: {\n            type: [Array, Object],\n            required: true,\n        },\n        data: {\n            type: Object,\n            default: () => ({}),\n        },\n        library: {\n            type: Object,\n            default: () => ({}),\n        },\n    },\n    setup(props, context) {\n        const instance = (0,vue__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)();\n        let instanceKey = Symbol(String(i++));\n        instanceScopes.set(instanceKey, []);\n        let provider = parseSchema(props.library, props.schema);\n        let render;\n        let data;\n        // Re-parse the schema if it changes:\n        (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(() => props.schema, (newSchema, oldSchema) => {\n            var _a;\n            instanceKey = Symbol(String(i++));\n            provider = parseSchema(props.library, props.schema);\n            render = createRenderFn(provider, data, instanceKey);\n            if (newSchema === oldSchema) {\n                ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();\n            }\n        }, { deep: true });\n        // Watch the data object explicitly\n        (0,vue__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => {\n            data = Object.assign((0,vue__WEBPACK_IMPORTED_MODULE_1__.reactive)(props.data), {\n                slots: context.slots,\n            });\n            render = createRenderFn(provider, data, instanceKey);\n        });\n        return () => render();\n    },\n});\n\n/**\n * All the explicit FormKit props.\n */\nconst nativeProps = {\n    config: {\n        type: Object,\n        default: {},\n    },\n    classes: {\n        type: Object,\n        required: false,\n    },\n    delay: {\n        type: Number,\n        required: false,\n    },\n    errors: {\n        type: Array,\n        default: [],\n    },\n    inputErrors: {\n        type: Object,\n        default: () => ({}),\n    },\n    index: {\n        type: Number,\n        required: false,\n    },\n    id: {\n        type: String,\n        required: false,\n    },\n    modelValue: {\n        required: false,\n    },\n    name: {\n        type: String,\n        required: false,\n    },\n    parent: {\n        type: Object,\n        required: false,\n    },\n    plugins: {\n        type: Array,\n        default: [],\n    },\n    sectionsSchema: {\n        type: Object,\n        default: {},\n    },\n    type: {\n        type: [String, Object],\n        default: 'text',\n    },\n    validation: {\n        type: [String, Array],\n        required: false,\n    },\n    validationMessages: {\n        type: Object,\n        required: false,\n    },\n    validationRules: {\n        type: Object,\n        required: false,\n    },\n    validationLabel: {\n        type: [String, Function],\n        required: false,\n    },\n};\n/**\n * The FormKit props object.\n * @internal\n */\nconst props = nativeProps;\n\n/**\n * The symbol that represents the formkit parent injection value.\n * @public\n */\nconst parentSymbol = Symbol('FormKitParent');\n/**\n * The root FormKit component.\n * @public\n */\nconst FormKit = (0,vue__WEBPACK_IMPORTED_MODULE_1__.defineComponent)({\n    props,\n    emits: {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        input: (_value, _node) => true,\n        inputRaw: (_value, _node) => true,\n        'update:modelValue': (_value) => true,\n        node: (node) => !!node,\n        submit: (_data, _node) => true,\n        submitRaw: (_event, _node) => true,\n        /* eslint-enable @typescript-eslint/no-unused-vars */\n    },\n    inheritAttrs: false,\n    setup(props, context) {\n        const node = useInput(props, context);\n        if (!node.props.definition)\n            (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.error)(600, node);\n        if (node.props.definition.component) {\n            return () => {\n                var _a;\n                return (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {\n                    context: node.context,\n                }, { ...context.slots });\n            };\n        }\n        const schema = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)([]);\n        const generateSchema = () => {\n            var _a, _b;\n            const schemaDefinition = (_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a.definition) === null || _b === void 0 ? void 0 : _b.schema;\n            if (!schemaDefinition)\n                (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.error)(601, node);\n            schema.value =\n                typeof schemaDefinition === 'function'\n                    ? schemaDefinition({ ...props.sectionsSchema })\n                    : schemaDefinition;\n        };\n        generateSchema();\n        // If someone emits the schema event, we re-generate the schema\n        node.on('schema', generateSchema);\n        context.emit('node', node);\n        const library = node.props.definition.library;\n        // Expose the FormKitNode to template refs.\n        context.expose({ node });\n        return () => (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)(FormKitSchema, { schema: schema.value, data: node.context, library }, { ...context.slots });\n    },\n});\n\n/**\n * The Create a new instance of the FormKit plugin for Vue.\n * @param app - A Vue application\n * @param config - FormKit Vue plugin configuration options\n */\nfunction createPlugin(app, options) {\n    app\n        .component(options.alias || 'FormKit', FormKit)\n        .component(options.schemaAlias || 'FormKitSchema', FormKitSchema);\n    return {\n        get: _formkit_core__WEBPACK_IMPORTED_MODULE_0__.getNode,\n        setLocale: (locale) => {\n            var _a;\n            if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {\n                options.config.rootConfig.locale = locale;\n            }\n        },\n        clearErrors: _formkit_core__WEBPACK_IMPORTED_MODULE_0__.clearErrors,\n        setErrors: _formkit_core__WEBPACK_IMPORTED_MODULE_0__.setErrors,\n        submit: _formkit_core__WEBPACK_IMPORTED_MODULE_0__.submitForm,\n        reset: _formkit_core__WEBPACK_IMPORTED_MODULE_0__.reset,\n    };\n}\n/**\n * The symbol key for accessing the FormKit node options.\n * @public\n */\nconst optionsSymbol = Symbol.for('FormKitOptions');\n/**\n * The symbol key for accessing FormKit root configuration.\n * @public\n */\nconst configSymbol = Symbol.for('FormKitConfig');\n/**\n * Create the FormKit plugin.\n * @public\n */\nconst plugin = {\n    install(app, _options) {\n        /**\n         * Extend the default configuration options.\n         */\n        const options = Object.assign({\n            alias: 'FormKit',\n            schemaAlias: 'FormKitSchema',\n        }, typeof _options === 'function' ? _options() : _options);\n        /**\n         * The root configuration options.\n         */\n        const rootConfig = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createConfig)(options.config || {});\n        /**\n         * We dont want to explicitly provide any \"config\" options, only a root\n         * config option — so here we override the existing config options.\n         */\n        options.config = { rootConfig };\n        /**\n         * Register the global $formkit plugin property.\n         */\n        app.config.globalProperties.$formkit = createPlugin(app, options);\n        /**\n         * Provide the config to the application for injection.\n         */\n        app.provide(optionsSymbol, options);\n        /**\n         * Provide the root config to the application.\n         */\n        app.provide(configSymbol, rootConfig);\n    },\n};\n\n/**\n * Indicates that the path that was requested is no longer valid in the object.\n */\nconst invalidGet = Symbol();\n/**\n *\n * @param obj - An object to observe at depth\n * @param callback - A callback that\n * @public\n */\nfunction watchVerbose(obj, callback) {\n    const watchers = {};\n    const applyWatch = (paths) => {\n        // Watch each property\n        for (const path of paths) {\n            // Stops pre-existing watchers at a given location to prevent dupes:\n            if (path.__str in watchers)\n                watchers[path.__str]();\n            watchers[path.__str] = (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(touch.bind(null, obj, path), dispatcher.bind(null, path), { deep: false });\n        }\n    };\n    /**\n     * Clear any watchers deeper than this path.\n     * @param path - The path to start from\n     */\n    const clearWatch = (path) => {\n        if (!path.length)\n            return;\n        for (const key in watchers) {\n            if (`${key}`.startsWith(`${path.__str}.`)) {\n                watchers[key]();\n                delete watchers[key];\n            }\n        }\n    };\n    const dispatcher = createDispatcher(obj, callback, applyWatch, clearWatch);\n    applyWatch(getPaths(obj));\n}\n/**\n * This function synchronously dispatches to the watch callbacks. It uses the\n * knowledge that the getPath function is a depth-first-search thus lower\n * specificity (lower tree nodes) will always have their watchers called first.\n * If a lower specificity watcher is triggered we want to ignore the higher\n * specificity watcher.\n * @param obj - The object to dispatch\n * @param callback - The callback function to emit\n * @param applyWatch - A way to apply watchers to update objects\n * @returns\n */\nfunction createDispatcher(obj, callback, applyWatch, clearChildWatches) {\n    // let dispatchedPaths: Record<string, ObjectPath> = {}\n    // let clear: Promise<void> | null = null\n    return (path) => {\n        const value = get(obj, path);\n        if (value === invalidGet)\n            return;\n        if (path.__deep)\n            clearChildWatches(path);\n        if (typeof value === 'object')\n            applyWatch(getPaths(value, [path], ...path));\n        callback(path, value, obj);\n    };\n}\n/**\n * \"Touches\" a given property for reactivity tracking purposes, if the value at\n * the given path is an object, we flatten it to just its keys since we will\n * already be tracking sub properties independently.\n * @param obj - A ref to traverse for a given path\n * @param path - An array of strings representing the path to locate\n * @returns\n */\nfunction touch(obj, path) {\n    const value = get(obj, path);\n    return value && typeof value === 'object' ? Object.keys(value) : value;\n}\n/**\n * \"Touches\" a given property for reactivity tracking purposes.\n * @param obj - A ref to traverse for a given path\n * @param path - An array of strings representing the path to locate\n * @returns\n */\nfunction get(obj, path) {\n    if ((0,vue__WEBPACK_IMPORTED_MODULE_1__.isRef)(obj)) {\n        if (path.length === 0)\n            return obj.value;\n        obj = obj.value;\n    }\n    return path.reduce((value, segment) => {\n        if (value === invalidGet)\n            return value;\n        if (value === null || typeof value !== 'object') {\n            return invalidGet;\n        }\n        return value[segment];\n    }, obj);\n}\n/**\n * Recursively retrieves all enumerable property paths from the origination\n * object. For example:\n * ```js\n * const obj = {\n *   a: {\n *     b: 123\n *   },\n *   c: 567\n * }\n * const paths = getPaths(obj)\n * // [\n * //   ['a'],\n * //   ['a', 'b'],\n * //   ['c']\n * // ]\n * ```\n * @param obj - An object to retrieve paths for.\n * @param parents - An array of parent paths.\n * @returns\n * @internal\n */\nfunction getPaths(obj, paths = [], ...parents) {\n    if (obj === null)\n        return paths;\n    if (!parents.length) {\n        const path = Object.defineProperty([], '__str', {\n            value: '',\n        });\n        obj = (0,vue__WEBPACK_IMPORTED_MODULE_1__.isRef)(obj) ? obj.value : obj;\n        if (obj && typeof obj === 'object') {\n            Object.defineProperty(path, '__deep', { value: true });\n            paths.push(path);\n        }\n        else {\n            return [path];\n        }\n    }\n    if (obj === null || typeof obj !== 'object')\n        return paths;\n    for (const key in obj) {\n        const path = parents.concat(key);\n        Object.defineProperty(path, '__str', { value: path.join('.') });\n        const value = obj[key];\n        if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.isPojo)(value) || Array.isArray(value)) {\n            paths.push(Object.defineProperty(path, '__deep', { value: true }));\n            paths = paths.concat(getPaths(value, [], ...path));\n        }\n        else {\n            paths.push(path);\n        }\n    }\n    return paths;\n}\n\n/**\n * Gets the raw underlying target object from a Vue Ref or Reactive object.\n * @param obj - Get the underlying target object, or no-op.\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction useRaw(obj) {\n    if (obj === null || typeof obj !== 'object')\n        return obj;\n    if ((0,vue__WEBPACK_IMPORTED_MODULE_1__.isReactive)(obj)) {\n        obj = (0,vue__WEBPACK_IMPORTED_MODULE_1__.toRaw)(obj);\n    }\n    else if ((0,vue__WEBPACK_IMPORTED_MODULE_1__.isRef)(obj)) {\n        obj = ((0,vue__WEBPACK_IMPORTED_MODULE_1__.isReactive)(obj.value) ? useRaw(obj.value) : obj.value);\n    }\n    return obj;\n}\n\n/**\n * Props that are extracted from the attrs object.\n * TODO: Currently local, this should probably exported to a inputs or another\n * package.\n */\nconst pseudoProps = [\n    'help',\n    'label',\n    'ignore',\n    'disabled',\n    'preserve',\n    /^preserve(-e|E)rrors/,\n    /^[a-z]+(?:-visibility|Visibility)$/,\n    /^[a-zA-Z-]+(?:-class|Class)$/,\n];\n/**\n * Given some props, map those props to individualized props internally.\n * @param node - A formkit node\n * @param props - Some props that may include a classes object\n */\nfunction classesToNodeProps(node, props) {\n    if (props.classes) {\n        Object.keys(props.classes).forEach((key) => {\n            if (typeof key === 'string') {\n                node.props[`_${key}Class`] = props.classes[key];\n                // We need to ensure Vue is aware that we want to actually observe the\n                // child values too, so we touch them here.\n                if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(props.classes[key]) && key === 'inner')\n                    Object.values(props.classes[key]);\n            }\n        });\n    }\n}\n/**\n * Extracts known FormKit listeners.\n * @param props - Extract known FormKit listeners.\n * @returns\n */\nfunction onlyListeners(props) {\n    if (!props)\n        return {};\n    const knownListeners = ['Submit', 'SubmitRaw'].reduce((listeners, listener) => {\n        const name = `on${listener}`;\n        if (name in props) {\n            if (typeof props[name] === 'function') {\n                listeners[name] = props[name];\n            }\n        }\n        return listeners;\n    }, {});\n    return knownListeners;\n}\n/**\n * A composable for creating a new FormKit node.\n * @param type - The type of node (input, group, list)\n * @param attrs - The FormKit \"props\" — which is really the attrs list.\n * @returns\n * @public\n */\nfunction useInput(props, context, options = {}) {\n    /**\n     * The configuration options, these are provided by either the plugin or by\n     * explicit props.\n     */\n    const config = Object.assign({}, (0,vue__WEBPACK_IMPORTED_MODULE_1__.inject)(optionsSymbol) || {}, options);\n    /**\n     * The current instance.\n     */\n    const instance = (0,vue__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance)();\n    /**\n     * Extracts the listeners.\n     */\n    const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);\n    /**\n     * Determines if the prop is v-modeled.\n     */\n    const isVModeled = props.modelValue !== undefined;\n    /**\n     * Determines if the object being passed as a v-model is reactive.\n     */\n    // const isReactiveVModel = isVModeled && isReactive(props.modelValue)\n    /**\n     * Define the initial component\n     */\n    const value = props.modelValue !== undefined\n        ? props.modelValue\n        : (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.cloneAny)(context.attrs.value);\n    /**\n     * Creates the node's initial props from the context, props, and definition\n     * @returns\n     */\n    function createInitialProps() {\n        const initialProps = {\n            ...(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.nodeProps)(props),\n            ...listeners,\n        };\n        const attrs = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.except)((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.nodeProps)(context.attrs), pseudoProps);\n        initialProps.attrs = attrs;\n        const propValues = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.only)((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.nodeProps)(context.attrs), pseudoProps);\n        for (const propName in propValues) {\n            initialProps[(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.camel)(propName)] = propValues[propName];\n        }\n        const classesProps = { props: {} };\n        classesToNodeProps(classesProps, props);\n        Object.assign(initialProps, classesProps.props);\n        if (typeof initialProps.type !== 'string') {\n            initialProps.definition = initialProps.type;\n            delete initialProps.type;\n        }\n        return initialProps;\n    }\n    /**\n     * Create the FormKitNode.\n     */\n    const initialProps = createInitialProps();\n    /**\n     * The parent node.\n     */\n    const parent = initialProps.ignore\n        ? null\n        : props.parent || (0,vue__WEBPACK_IMPORTED_MODULE_1__.inject)(parentSymbol, null);\n    const node = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createNode)((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.extend)(config || {}, {\n        name: props.name || undefined,\n        value,\n        parent,\n        plugins: (config.plugins || []).concat(props.plugins),\n        config: props.config,\n        props: initialProps,\n        index: props.index,\n    }, false, true));\n    /**\n     * If no definition has been assigned at this point — we're out!\n     */\n    if (!node.props.definition)\n        (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.error)(600, node);\n    /**\n     * All props that are bound \"late\" (after node creation) — are added to a set\n     * which is used to watch the context.attrs object.\n     */\n    const lateBoundProps = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(new Set(node.props.definition.props || []));\n    /**\n     * Any additional props added at a \"later\" time should also be part of the\n     * late bound props.\n     */\n    node.on('added-props', ({ payload: lateProps }) => {\n        if (Array.isArray(lateProps))\n            lateProps.forEach((newProp) => lateBoundProps.value.add(newProp));\n    });\n    /**\n     * These prop names must be assigned.\n     */\n    const pseudoPropNames = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n        if (typeof prop === 'string') {\n            names.push((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.camel)(prop));\n            names.push((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.kebab)(prop));\n        }\n        else {\n            names.push(prop);\n        }\n        return names;\n    }, []));\n    /* Splits Classes object into discrete props for each key */\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => classesToNodeProps(node, props));\n    /**\n     * The props object already has properties even if they start as \"undefined\"\n     * so we can loop over them and individual watchEffect to prevent responding\n     * inappropriately.\n     */\n    const passThrough = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.nodeProps)(props);\n    for (const prop in passThrough) {\n        (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(() => props[prop], () => {\n            if (props[prop] !== undefined) {\n                node.props[prop] = props[prop];\n            }\n        });\n    }\n    /**\n     * Watch \"pseudoProp\" attributes explicitly.\n     */\n    const attributeWatchers = new Set();\n    const possibleProps = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.nodeProps)(context.attrs);\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => {\n        watchAttributes((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.only)(possibleProps, pseudoPropNames.value));\n    });\n    /**\n     * Defines attributes that should be used as props.\n     * @param attrProps - Attributes that should be used as props instead\n     */\n    function watchAttributes(attrProps) {\n        attributeWatchers.forEach((stop) => {\n            stop();\n            attributeWatchers.delete(stop);\n        });\n        for (const prop in attrProps) {\n            const camelName = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.camel)(prop);\n            attributeWatchers.add((0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(() => context.attrs[prop], () => {\n                node.props[camelName] = context.attrs[prop];\n            }));\n        }\n    }\n    /**\n     * Watch and dynamically set attribute values, those values that are not\n     * props and are not pseudoProps\n     */\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => {\n        const attrs = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.except)((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.nodeProps)(context.attrs), pseudoPropNames.value);\n        node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\n    });\n    /**\n     * Add any/all \"prop\" errors to the store.\n     */\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => {\n        const messages = props.errors.map((error) => (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createMessage)({\n            key: (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.slugify)(error),\n            type: 'error',\n            value: error,\n            meta: { source: 'prop' },\n        }));\n        node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === 'prop');\n    });\n    /**\n     * Add input errors.\n     */\n    if (node.type !== 'input') {\n        const sourceKey = `${node.name}-prop`;\n        (0,vue__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => {\n            const keys = Object.keys(props.inputErrors);\n            const messages = keys.reduce((messages, key) => {\n                let value = props.inputErrors[key];\n                if (typeof value === 'string')\n                    value = [value];\n                if (Array.isArray(value)) {\n                    messages[key] = value.map((error) => (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createMessage)({\n                        key: error,\n                        type: 'error',\n                        value: error,\n                        meta: { source: sourceKey },\n                    }));\n                }\n                return messages;\n            }, {});\n            node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === sourceKey);\n        });\n    }\n    /**\n     * Watch the config prop for any changes.\n     */\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.watchEffect)(() => Object.assign(node.config, props.config));\n    /**\n     * Produce another parent object.\n     */\n    if (node.type !== 'input') {\n        (0,vue__WEBPACK_IMPORTED_MODULE_1__.provide)(parentSymbol, node);\n    }\n    let inputTimeout;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const mutex = new WeakSet();\n    /**\n     * Explicitly watch the input value, and emit changes (lazy)\n     */\n    node.on('modelUpdated', () => {\n        var _a, _b;\n        // Emit the values after commit\n        context.emit('inputRaw', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value, node);\n        clearTimeout(inputTimeout);\n        inputTimeout = setTimeout(context.emit, 20, 'input', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value, node);\n        if (isVModeled && node.context) {\n            const newValue = useRaw(node.context.value);\n            if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(newValue) && useRaw(props.modelValue) !== newValue) {\n                // If this is an object that has been mutated inside FormKit core then\n                // we know when it is emitted it will \"return\" in the watchVerbose so\n                // we pro-actively add it to the mutex.\n                mutex.add(newValue);\n            }\n            context.emit('update:modelValue', newValue);\n        }\n    });\n    /**\n     * Enabled support for v-model, using this for groups/lists is not recommended\n     */\n    if (isVModeled) {\n        watchVerbose((0,vue__WEBPACK_IMPORTED_MODULE_1__.toRef)(props, 'modelValue'), (path, value) => {\n            var _a;\n            const rawValue = useRaw(value);\n            if ((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(rawValue) && mutex.has(rawValue)) {\n                return mutex.delete(rawValue);\n            }\n            if (!path.length)\n                node.input(value, false);\n            else\n                (_a = node.at(path)) === null || _a === void 0 ? void 0 : _a.input(value, false);\n        });\n    }\n    /**\n     * When this input shuts down, we need to \"delete\" the node too.\n     */\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.onUnmounted)(() => node.destroy());\n    return node;\n}\n\nlet totalCreated = 1;\n/**\n * Determine if the given object is a vue component.\n *\n * @param obj - Object or function\n * @returns\n * @public\n */\nfunction isComponent(obj) {\n    return ((typeof obj === 'function' && obj.length === 2) ||\n        (typeof obj === 'object' &&\n            !Array.isArray(obj) &&\n            !('$el' in obj) &&\n            !('$cmp' in obj) &&\n            !('if' in obj)));\n}\n/**\n * Creates a new input from schema or a Vue component with the \"standard\"\n * FormKit features in place such as labels, help text, validation messages, and\n * class support.\n *\n * @param schemaOrComponent - The actual schema of the input.\n * @public\n */\nfunction createInput(schemaOrComponent, definitionOptions = {}) {\n    const definition = {\n        type: 'input',\n        ...definitionOptions,\n    };\n    let schema = undefined;\n    if (isComponent(schemaOrComponent)) {\n        const cmpName = `SchemaComponent${totalCreated++}`;\n        schema = () => ({\n            $cmp: cmpName,\n            props: {\n                context: '$node.context',\n            },\n        });\n        definition.library = { [cmpName]: (0,vue__WEBPACK_IMPORTED_MODULE_1__.markRaw)(schemaOrComponent) };\n    }\n    else {\n        schema = schemaOrComponent;\n    }\n    // Use the default wrapping schema\n    definition.schema = (0,_formkit_inputs__WEBPACK_IMPORTED_MODULE_3__.useSchema)(schema || 'Schema undefined');\n    return definition;\n}\n\n/**\n * A plugin that creates Vue-specific context object on each given node.\n * @param node - FormKitNode to create the context on.\n * @public\n */\nconst vueBindings = function vueBindings(node) {\n    /**\n     * Start a validity counter on all blocking messages.\n     */\n    node.ledger.count('blocking', (m) => m.blocking);\n    const isValid = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(!node.ledger.value('blocking'));\n    /**\n     * Start an error message counter.\n     */\n    node.ledger.count('errors', (m) => m.type === 'error');\n    const hasErrors = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(!!node.ledger.value('errors'));\n    /**\n     * Keep track of the first time a Vue tick cycle has passed.\n     */\n    let hasTicked = false;\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {\n        hasTicked = true;\n    });\n    /**\n     * All messages with the visibility state set to true.\n     */\n    const availableMessages = (0,vue__WEBPACK_IMPORTED_MODULE_1__.reactive)(node.store.reduce((store, message) => {\n        if (message.visible) {\n            store[message.key] = message;\n        }\n        return store;\n    }, {}));\n    /**\n     * A flag that determines when validation messages should be displayed.\n     */\n    const validationVisibility = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(node.props.validationVisibility || 'blur');\n    node.on('prop:validationVisibility', ({ payload }) => {\n        validationVisibility.value = payload;\n    });\n    /**\n     * Keep track of if this input has ever shown validation errors.\n     */\n    const hasShownErrors = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(validationVisibility.value === 'live');\n    /**\n     * The current visibility state of validation messages.\n     */\n    const validationVisible = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n        if (context.state.submitted)\n            return true;\n        if (!hasShownErrors.value && !context.state.settled) {\n            return false;\n        }\n        switch (validationVisibility.value) {\n            case 'live':\n                return true;\n            case 'blur':\n                return context.state.blurred;\n            case 'dirty':\n                return context.state.dirty;\n            default:\n                return false;\n        }\n    });\n    /**\n     * Determines if the input should be considered \"complete\".\n     */\n    const isComplete = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n        return hasValidation.value\n            ? isValid.value && !hasErrors.value\n            : context.state.dirty && !(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.empty)(context.value);\n    });\n    /**\n     * If the input has validation rules or not.\n     */\n    const hasValidation = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);\n    node.on('prop:parsedRules', ({ payload: rules }) => {\n        hasValidation.value = Array.isArray(rules) && rules.length > 0;\n    });\n    /**\n     * All messages that are currently on display to an end user. This changes\n     * based on the current message type visibility, like errorVisibility.\n     */\n    const messages = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n        const visibleMessages = {};\n        for (const key in availableMessages) {\n            const message = availableMessages[key];\n            if (message.type !== 'validation' || validationVisible.value) {\n                visibleMessages[key] = message;\n            }\n        }\n        return visibleMessages;\n    });\n    /**\n     * UI Messages.\n     */\n    const ui = (0,vue__WEBPACK_IMPORTED_MODULE_1__.reactive)(node.store.reduce((messages, message) => {\n        if (message.type === 'ui' && message.visible)\n            messages[message.key] = message;\n        return messages;\n    }, {}));\n    /**\n     * This is the reactive data object that is provided to all schemas and\n     * forms. It is a subset of data in the core node object.\n     */\n    const cachedClasses = (0,vue__WEBPACK_IMPORTED_MODULE_1__.reactive)({});\n    const classes = new Proxy(cachedClasses, {\n        get(...args) {\n            const [target, property] = args;\n            let className = Reflect.get(...args);\n            if (!className && typeof property === 'string') {\n                if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(target, property) && !property.startsWith('__v')) {\n                    const observedNode = (0,_formkit_observer__WEBPACK_IMPORTED_MODULE_7__.createObserver)(node);\n                    observedNode.watch((node) => {\n                        const rootClasses = typeof node.config.rootClasses === 'function'\n                            ? node.config.rootClasses(property, node)\n                            : {};\n                        const globalConfigClasses = node.config.classes\n                            ? (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createClasses)(property, node, node.config.classes[property])\n                            : {};\n                        const classesPropClasses = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createClasses)(property, node, node.props[`_${property}Class`]);\n                        const sectionPropClasses = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createClasses)(property, node, node.props[`${property}Class`]);\n                        className = (0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.generateClassList)(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);\n                        target[property] = className;\n                    });\n                }\n            }\n            return className;\n        },\n    });\n    const describedBy = (0,vue__WEBPACK_IMPORTED_MODULE_1__.computed)(() => {\n        const describers = [];\n        if (context.help) {\n            describers.push(`help-${node.props.id}`);\n        }\n        for (const key in messages.value) {\n            describers.push(`${node.props.id}-${key}`);\n        }\n        return describers.length ? describers.join(' ') : undefined;\n    });\n    const value = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(node.value);\n    const _value = (0,vue__WEBPACK_IMPORTED_MODULE_1__.ref)(node.value);\n    const context = (0,vue__WEBPACK_IMPORTED_MODULE_1__.reactive)({\n        _value,\n        attrs: node.props.attrs,\n        disabled: node.props.disabled,\n        describedBy,\n        fns: {\n            length: (obj) => Object.keys(obj).length,\n            number: (value) => Number(value),\n            string: (value) => String(value),\n            json: (value) => JSON.stringify(value),\n            eq: _formkit_utils__WEBPACK_IMPORTED_MODULE_2__.eq,\n        },\n        handlers: {\n            blur: () => node.store.set((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createMessage)({ key: 'blurred', visible: false, value: true })),\n            touch: () => {\n                node.store.set((0,_formkit_core__WEBPACK_IMPORTED_MODULE_0__.createMessage)({ key: 'dirty', visible: false, value: true }));\n            },\n            DOMInput: (e) => {\n                node.input(e.target.value);\n                node.emit('dom-input-event', e);\n            },\n        },\n        help: node.props.help,\n        id: node.props.id,\n        label: node.props.label,\n        messages,\n        node: (0,vue__WEBPACK_IMPORTED_MODULE_1__.markRaw)(node),\n        options: node.props.options,\n        state: {\n            blurred: false,\n            complete: isComplete,\n            dirty: false,\n            submitted: false,\n            settled: node.isSettled,\n            valid: isValid,\n            errors: hasErrors,\n            rules: hasValidation,\n            validationVisible,\n        },\n        type: node.props.type,\n        ui,\n        value,\n        classes,\n    });\n    /**\n     * Ensure the context object is properly configured after booting up.\n     */\n    node.on('created', () => {\n        if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.eq)(context.value, node.value)) {\n            _value.value = node.value;\n            value.value = node.value;\n            (0,vue__WEBPACK_IMPORTED_MODULE_1__.triggerRef)(value);\n            (0,vue__WEBPACK_IMPORTED_MODULE_1__.triggerRef)(_value);\n        }\n    });\n    /**\n     * Sets the settled state.\n     */\n    node.on('settled', ({ payload: isSettled }) => {\n        context.state.settled = isSettled;\n    });\n    /**\n     * Observes node.props properties explicitly and updates them in the context\n     * object.\n     * @param observe - Props to observe and register as context data.\n     */\n    function observeProps(observe) {\n        observe.forEach((prop) => {\n            prop = (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.camel)(prop);\n            if (!(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(context, prop) && (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.has)(node.props, prop)) {\n                context[prop] = node.props[prop];\n            }\n            node.on(`prop:${prop}`, ({ payload }) => {\n                context[prop] = payload;\n            });\n        });\n    }\n    /**\n     * We use a node observer to individually observe node props.\n     */\n    const rootProps = [\n        'help',\n        'label',\n        'disabled',\n        'options',\n        'type',\n        'attrs',\n        'preserve',\n        'preserveErrors',\n        'id',\n    ];\n    observeProps(rootProps);\n    /**\n     * Once the input is defined, deal with it.\n     * @param definition - Type definition.\n     */\n    function definedAs(definition) {\n        if (definition.props)\n            observeProps(definition.props);\n    }\n    node.props.definition && definedAs(node.props.definition);\n    /**\n     * When new props are added to the core node as \"props\" (ie not attrs) then\n     * we automatically need to start tracking them here.\n     */\n    node.on('added-props', ({ payload }) => observeProps(payload));\n    /**\n     * Watch for input events from core.\n     */\n    node.on('input', ({ payload }) => {\n        _value.value = payload;\n        (0,vue__WEBPACK_IMPORTED_MODULE_1__.triggerRef)(_value);\n    });\n    /**\n     * Watch for input commits from core.\n     */\n    node.on('commit', ({ payload }) => {\n        value.value = _value.value = payload;\n        (0,vue__WEBPACK_IMPORTED_MODULE_1__.triggerRef)(value);\n        node.emit('modelUpdated');\n        // The input is dirty after a value has been input by a user\n        if (!context.state.dirty && node.isCreated && hasTicked)\n            context.handlers.touch();\n        if (isComplete &&\n            node.type === 'input' &&\n            hasErrors.value &&\n            !(0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.undefine)(node.props.preserveErrors)) {\n            node.store.filter((message) => { var _a; return !(message.type === 'error' && ((_a = message.meta) === null || _a === void 0 ? void 0 : _a.autoClear) === true); });\n        }\n    });\n    /**\n     * Update the local state in response to messages.\n     * @param message - A formkit message\n     */\n    const updateState = async (message) => {\n        if (message.type === 'ui' &&\n            message.visible &&\n            !message.meta.showAsMessage) {\n            ui[message.key] = message;\n        }\n        else if (message.visible) {\n            availableMessages[message.key] = message;\n        }\n        else if (message.type === 'state') {\n            // await node.settled\n            context.state[message.key] = !!message.value;\n        }\n    };\n    /**\n     * Listen to message events and modify the local message data values.\n     */\n    node.on('message-added', (e) => updateState(e.payload));\n    node.on('message-updated', (e) => updateState(e.payload));\n    node.on('message-removed', ({ payload: message }) => {\n        delete ui[message.key];\n        delete availableMessages[message.key];\n        delete context.state[message.key];\n    });\n    node.on('settled:blocking', () => {\n        isValid.value = true;\n    });\n    node.on('unsettled:blocking', () => {\n        isValid.value = false;\n    });\n    node.on('settled:errors', () => {\n        hasErrors.value = false;\n    });\n    node.on('unsettled:errors', () => {\n        hasErrors.value = true;\n    });\n    /**\n     * Watch the validation visible prop and set the hasShownErrors state.\n     */\n    (0,vue__WEBPACK_IMPORTED_MODULE_1__.watch)(validationVisible, (value) => {\n        if (value) {\n            hasShownErrors.value = true;\n        }\n    });\n    node.context = context;\n    // The context is complete\n    node.emit('context', node, false);\n};\n\n/**\n * Default configuration options. Includes all validation rules,\n * en i18n messages.\n * @public\n */\nconst defaultConfig = (options = {}) => {\n    const { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = undefined, ...nodeOptions } = options;\n    /**\n     * The default configuration includes the validation plugin,\n     * with all core-available validation rules.\n     */\n    const validation = (0,_formkit_validation__WEBPACK_IMPORTED_MODULE_5__.createValidationPlugin)({\n        ..._formkit_rules__WEBPACK_IMPORTED_MODULE_4__,\n        ...(rules || {}),\n    });\n    /**\n     * Includes the i18n plugin with only the english language\n     * messages.\n     */\n    const i18n = (0,_formkit_i18n__WEBPACK_IMPORTED_MODULE_6__.createI18nPlugin)((0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.extend)({ en: _formkit_i18n__WEBPACK_IMPORTED_MODULE_6__.en, ...(locales || {}) }, messages));\n    /**\n     * Create the library of inputs that are generally available. This default\n     * config imports all \"native\" inputs by default, but\n     */\n    const library = (0,_formkit_inputs__WEBPACK_IMPORTED_MODULE_3__.createLibraryPlugin)(_formkit_inputs__WEBPACK_IMPORTED_MODULE_3__.inputs, inputs$1);\n    return (0,_formkit_utils__WEBPACK_IMPORTED_MODULE_2__.extend)({\n        plugins: [library, vueBindings, i18n, validation],\n        ...(!locale ? {} : { config: { locale } }),\n    }, nodeOptions || {}, true);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvdnVlL2Rpc3QvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvdnVlL2Rpc3QvaW5kZXgubWpzP2NkMTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2FybiwgZ2V0Tm9kZSwgd2F0Y2hSZWdpc3RyeSwgaXNOb2RlLCBzdWdhciwgaXNET00sIGlzQ29tcG9uZW50IGFzIGlzQ29tcG9uZW50JDEsIGlzQ29uZGl0aW9uYWwsIGNvbXBpbGUsIGVycm9yLCBjcmVhdGVDb25maWcsIGNsZWFyRXJyb3JzLCBzZXRFcnJvcnMsIHN1Ym1pdEZvcm0sIHJlc2V0LCBjcmVhdGVOb2RlLCBjcmVhdGVNZXNzYWdlLCBjcmVhdGVDbGFzc2VzLCBnZW5lcmF0ZUNsYXNzTGlzdCB9IGZyb20gJ0Bmb3Jta2l0L2NvcmUnO1xuZXhwb3J0IHsgY2xlYXJFcnJvcnMsIGVycm9ySGFuZGxlciwgcmVzZXQsIHJlc2V0Q291bnQsIHNldEVycm9ycywgc3VibWl0Rm9ybSB9IGZyb20gJ0Bmb3Jta2l0L2NvcmUnO1xuaW1wb3J0IHsgZGVmaW5lQ29tcG9uZW50LCBnZXRDdXJyZW50SW5zdGFuY2UsIHdhdGNoLCB3YXRjaEVmZmVjdCwgcmVhY3RpdmUsIHJlZiwgY3JlYXRlVGV4dFZOb2RlLCByZXNvbHZlQ29tcG9uZW50LCBoLCBpc1JlZiwgaXNSZWFjdGl2ZSwgdG9SYXcsIGluamVjdCwgY29tcHV0ZWQsIHByb3ZpZGUsIHRvUmVmLCBvblVubW91bnRlZCwgbWFya1JhdywgbmV4dFRpY2ssIHRyaWdnZXJSZWYgfSBmcm9tICd2dWUnO1xuaW1wb3J0IHsgaGFzLCBpc1Bvam8sIGNsb25lQW55LCBleHRlbmQsIGNhbWVsLCBrZWJhYiwgbm9kZVByb3BzLCBvbmx5LCBleGNlcHQsIHNsdWdpZnksIGlzT2JqZWN0LCBlbXB0eSwgZXEsIHVuZGVmaW5lIH0gZnJvbSAnQGZvcm1raXQvdXRpbHMnO1xuaW1wb3J0IHsgdXNlU2NoZW1hLCBjcmVhdGVMaWJyYXJ5UGx1Z2luLCBpbnB1dHMgfSBmcm9tICdAZm9ybWtpdC9pbnB1dHMnO1xuaW1wb3J0ICogYXMgZGVmYXVsdFJ1bGVzIGZyb20gJ0Bmb3Jta2l0L3J1bGVzJztcbmltcG9ydCB7IGNyZWF0ZVZhbGlkYXRpb25QbHVnaW4gfSBmcm9tICdAZm9ybWtpdC92YWxpZGF0aW9uJztcbmltcG9ydCB7IGNyZWF0ZUkxOG5QbHVnaW4sIGVuIH0gZnJvbSAnQGZvcm1raXQvaTE4bic7XG5pbXBvcnQgeyBjcmVhdGVPYnNlcnZlciB9IGZyb20gJ0Bmb3Jta2l0L29ic2VydmVyJztcbmltcG9ydCAnQGZvcm1raXQvZGV2JztcblxuLyoqXG4gKiBBIHJlZ2lzdHJ5IG9mIG1lbW9pemVkIHNjaGVtYXMgKGluIEpTT04pIHRvIHRoZWlyIHJlc3BlY3RpdmUgcmVuZGVyIGZ1bmN0aW9uXG4gKiBhbmQgcHJvdmlkZXIgcmVnaXN0cnkuXG4gKi9cbmNvbnN0IG1lbW8gPSB7fTtcbi8qKlxuICogVGhpcyBzeW1ib2wgcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQgaW5zdGFuY2UgZHVyaW5nIHJlbmRlci4gSXQgaXNcbiAqIGNyaXRpY2FsIGZvciBsaW5raW5nIHRoZSBjdXJyZW50IGluc3RhbmNlIHRvIHRoZSBkYXRhIHJlcXVpcmVkIGZvciByZW5kZXIuXG4gKi9cbmxldCBpbnN0YW5jZUtleTtcbi8qKlxuICogQSByZWdpc3RyeSBvZiBzY29wZWQgZGF0YSBwcm9kdWNlZCBkdXJpbmcgcnVudGltZSB0aGF0IGlzIGtleWVkIGJ5IHRoZVxuICogaW5zdGFuY2Ugc3ltYm9sLiBGb3IgZXhhbXBsZSBkYXRhIGZyb206IGZvci1sb29wIGluc3RhbmNlcyBhbmQgc2xvdCBkYXRhLlxuICovXG5jb25zdCBpbnN0YW5jZVNjb3BlcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogSW5kaWNhdGVzIHRoZSBhIHNlY3Rpb24gb2YgdGhlIHNjaGVtYSBpcyByYXcuXG4gKi9cbmNvbnN0IHJhdyA9ICdfX3Jhd19fJztcbi8qKlxuICogSXMgYSBjbGFzcyBwcm9wLlxuICovXG5jb25zdCBpc0NsYXNzUHJvcCA9IC9bYS16QS1aMC05XFwtXVtjQ11sYXNzJC87XG4vKipcbiAqIFJldHVybnMgYSByZWZlcmVuY2UgYXMgYSBwbGFjZWhvbGRlciB0byBhIHNwZWNpZmljIGxvY2F0aW9uIG9uIGFuIG9iamVjdC5cbiAqIEBwYXJhbSBkYXRhIC0gQSByZWFjdGl2ZSBkYXRhIG9iamVjdFxuICogQHBhcmFtIHRva2VuIC0gQSBkb3Qtc3ludGF4IHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9iamVjdCBwYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRSZWYodG9rZW4sIGRhdGEpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJlZihudWxsKTtcbiAgICBpZiAodG9rZW4gPT09ICdnZXQnKSB7XG4gICAgICAgIGNvbnN0IG5vZGVSZWZzID0ge307XG4gICAgICAgIHZhbHVlLnZhbHVlID0gZ2V0JDEuYmluZChudWxsLCBub2RlUmVmcyk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgd2F0Y2hFZmZlY3QoKCkgPT4gKHZhbHVlLnZhbHVlID0gZ2V0VmFsdWUoZGF0YSwgcGF0aCkpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBpbnNpZGUgYSBzZXQgb2YgZGF0YSBvYmplY3RzLlxuICogQHBhcmFtIHNldHMgLSBBbiBhcnJheSBvZiBvYmplY3RzIHRvIHNlYXJjaCB0aHJvdWdoXG4gKiBAcGFyYW0gcGF0aCAtIEEgYXJyYXkgb2Ygc3RyaW5nIHBhdGhzIGVhc2lseSBwcm9kdWNlZCBieSBzcGxpdCgpXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShzZXQsIHBhdGgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3Vic2V0IG9mIHNldCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzdWJzZXQgIT09IGZhbHNlICYmIGdldFZhbHVlKHN1YnNldCwgcGF0aCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGZvdW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgcGF0aC5yZWR1Y2UoKG9iaiwgc2VnbWVudCwgaSwgYXJyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm91bmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiBhcnIuc3BsaWNlKDEpOyAvLyBGb3JjZXMgYW4gZXhpdFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IG9ialtzZWdtZW50XTtcbiAgICAgICAgaWYgKGkgPT09IHBhdGgubGVuZ3RoIC0gMSAmJiBjdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm91bmRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqW3NlZ21lbnRdO1xuICAgIH0sIHNldCk7XG4gICAgcmV0dXJuIGZvdW5kVmFsdWU7XG59XG4vKipcbiAqIEdldCB0aGUgbm9kZSBmcm9tIHRoZSBnbG9iYWwgcmVnaXN0cnlcbiAqIEBwYXJhbSBpZCAtIEEgZG90LXN5bnRheCBzdHJpbmcgd2hlcmUgdGhlIG5vZGUgaXMgbG9jYXRlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0JDEobm9kZVJlZnMsIGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB3YXJuKDY1MCk7XG4gICAgaWYgKCEoaWQgaW4gbm9kZVJlZnMpKVxuICAgICAgICBub2RlUmVmc1tpZF0gPSByZWYodW5kZWZpbmVkKTtcbiAgICBpZiAobm9kZVJlZnNbaWRdLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZVJlZnNbaWRdLnZhbHVlID0gbnVsbDtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGdldE5vZGUoaWQpO1xuICAgICAgICBpZiAocm9vdClcbiAgICAgICAgICAgIG5vZGVSZWZzW2lkXS52YWx1ZSA9IHJvb3QuY29udGV4dDtcbiAgICAgICAgd2F0Y2hSZWdpc3RyeShpZCwgKHsgcGF5bG9hZDogbm9kZSB9KSA9PiB7XG4gICAgICAgICAgICBub2RlUmVmc1tpZF0udmFsdWUgPSBpc05vZGUobm9kZSkgPyBub2RlLmNvbnRleHQgOiBub2RlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVSZWZzW2lkXS52YWx1ZTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBsaWJyYXJ5IC0gQSBsaWJyYXJ5IG9mIGNvbmNyZXRlIGNvbXBvbmVudHMgdG8gdXNlXG4gKiBAcGFyYW0gc2NoZW1hIC1cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2NoZW1hKGxpYnJhcnksIHNjaGVtYSkge1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGlmL3RoZW4vZWxzZSBzY2hlbWEgbm9kZSwgcHJlLWNvbXBpbGUgdGhlIG5vZGUgYW5kIHJldHVybiB0aGVcbiAgICAgKiBhcnRpZmFjdHMgZm9yIHRoZSByZW5kZXIgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgc2NoZW1hIGNvbnRleHQgb2JqZWN0XG4gICAgICogQHBhcmFtIGxpYnJhcnkgLSBUaGUgYXZhaWxhYmxlIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIHBhcnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VDb25kaXRpb24obGlicmFyeSwgbm9kZSkge1xuICAgICAgICBjb25zdCBjb25kaXRpb24gPSBwcm92aWRlcihjb21waWxlKG5vZGUuaWYpLCB7IGlmOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGNyZWF0ZUVsZW1lbnRzKGxpYnJhcnksIG5vZGUudGhlbik7XG4gICAgICAgIGNvbnN0IGFsdGVybmF0ZSA9IG5vZGUuZWxzZSA/IGNyZWF0ZUVsZW1lbnRzKGxpYnJhcnksIG5vZGUuZWxzZSkgOiBudWxsO1xuICAgICAgICByZXR1cm4gW2NvbmRpdGlvbiwgY2hpbGRyZW4sIGFsdGVybmF0ZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNvbmRpdGlvbmFsIGlmL3RoZW4vZWxzZSBhdHRyaWJ1dGUgc3RhdGVtZW50LlxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0XG4gICAgICogQHBhcmFtIGF0dHIgLSBUaGUgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIF9kZWZhdWx0IC0gVGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uQXR0cihhdHRyLCBfZGVmYXVsdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjb25kaXRpb24gPSBwcm92aWRlcihjb21waWxlKGF0dHIuaWYpKTtcbiAgICAgICAgbGV0IGIgPSAoKSA9PiBfZGVmYXVsdDtcbiAgICAgICAgbGV0IGEgPSAoKSA9PiBfZGVmYXVsdDtcbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyLnRoZW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhID0gcGFyc2VBdHRycyhhdHRyLnRoZW4sIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGF0dHIudGhlbiA9PT0gJ3N0cmluZycgJiYgKChfYSA9IGF0dHIudGhlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0c1dpdGgoJyQnKSkpIHtcbiAgICAgICAgICAgIGEgPSBwcm92aWRlcihjb21waWxlKGF0dHIudGhlbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYSA9ICgpID0+IGF0dHIudGhlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzKGF0dHIsICdlbHNlJykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0ci5lbHNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGIgPSBwYXJzZUF0dHJzKGF0dHIuZWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXR0ci5lbHNlID09PSAnc3RyaW5nJyAmJiAoKF9iID0gYXR0ci5lbHNlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhcnRzV2l0aCgnJCcpKSkge1xuICAgICAgICAgICAgICAgIGIgPSBwcm92aWRlcihjb21waWxlKGF0dHIuZWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9ICgpID0+IGF0dHIuZWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4gKGNvbmRpdGlvbigpID8gYSgpIDogYigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYXR0cmlidXRlcyBmb3IgZHluYW1pYyBjb250ZW50LlxuICAgICAqIEBwYXJhbSBhdHRycyAtIE9iamVjdCBvZiBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUF0dHJzKHVucGFyc2VkQXR0cnMsIGJpbmRFeHAsIF9kZWZhdWx0ID0ge30pIHtcbiAgICAgICAgY29uc3QgZXhwbGljaXRBdHRycyA9IG5ldyBTZXQoT2JqZWN0LmtleXModW5wYXJzZWRBdHRycyB8fCB7fSkpO1xuICAgICAgICBjb25zdCBib3VuZEF0dHJzID0gYmluZEV4cCA/IHByb3ZpZGVyKGNvbXBpbGUoYmluZEV4cCkpIDogKCkgPT4gKHt9KTtcbiAgICAgICAgY29uc3Qgc3RhdGljQXR0cnMgPSB7fTtcbiAgICAgICAgY29uc3Qgc2V0dGVycyA9IFtcbiAgICAgICAgICAgIChhdHRycykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kID0gYm91bmRBdHRycygpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBpbiBib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cGxpY2l0QXR0cnMuaGFzKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRyXSA9IGJvdW5kW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHVucGFyc2VkQXR0cnMpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbmRpdGlvbmFsKHVucGFyc2VkQXR0cnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJvb3QgY29uZGl0aW9uYWwgb2JqZWN0IHRoYXQgbXVzdCBwcm9kdWNlIGFuIG9iamVjdCBvZlxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gcGFyc2VDb25kaXRpb25BdHRyKHVucGFyc2VkQXR0cnMsIF9kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSBhdHRyaWJ1dGVzIGFyZSBleHBsaWNpdGx5IGJvdW5kLCB3ZSBuZWVkIHRvIHBhcnNlIHRob3NlIG9uZXNcbiAgICAgICAgICAgIC8vIHVzaW5nIHRoZSBjb21waWxlciBhbmQgY3JlYXRlIGEgZHluYW1pYyBcInNldHRlclwiLlxuICAgICAgICAgICAgZm9yIChsZXQgYXR0ciBpbiB1bnBhcnNlZEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB1bnBhcnNlZEF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgICAgIGxldCBnZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1N0ciA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIuc3RhcnRzV2l0aChyYXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMgcHJlZml4ZWQgd2l0aCBfX3Jhd19fIHNob3VsZCBub3QgYmUgcGFyc2VkXG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyLnN1YnN0cmluZyg3KTtcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWUgPSAoKSA9PiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHIgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3RhcnRzV2l0aCgnJCcpICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgISh2YWx1ZS5zdGFydHNXaXRoKCckcmVzZXQnKSAmJiBpc0NsYXNzUHJvcC50ZXN0KGF0dHIpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3N0IGF0dHJpYnV0ZSB2YWx1ZXMgc3RhcnRpbmcgd2l0aCAkIHNob3VsZCBiZSBjb21waWxlZFxuICAgICAgICAgICAgICAgICAgICAvLyAtY2xhc3MgYXR0cmlidXRlcyBzdGFydGluZyB3aXRoIGAkcmVzZXRgIHNob3VsZCBub3QgYmUgY29tcGlsZWRcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWUgPSBwcm92aWRlcihjb21waWxlKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgaXNDb25kaXRpb25hbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGl0aW9uYWwgYXR0cnMgcmVxdWlyZSBmdXJ0aGVyIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWUgPSBwYXJzZUNvbmRpdGlvbkF0dHIodmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgaXNQb2pvKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdWItcGFyc2UgcG9qb3NcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWUgPSBwYXJzZUF0dHJzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGFsbCBvdGhlciBjYXNlcywgdGhlIHZhbHVlIGlzIHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZSA9ICgpID0+IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNBdHRyc1thdHRyXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXR0ZXJzLnB1c2goKGF0dHJzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2F0dHJdID0gZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICAgICAgICAgIHNldHRlcnMuZm9yRWFjaCgoc2V0dGVyKSA9PiBzZXR0ZXIoYXR0cnMpKTtcbiAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzaW5nbGUgc2NoZW1hIG5vZGUsIHBhcnNlIGl0IGFuZCBleHRyYWN0IHRoZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIEEgc3RhdGUgb2JqZWN0IHByb3ZpZGVkIHRvIGVhY2ggbm9kZVxuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIHNjaGVtYSBub2RlIGJlaW5nIHBhcnNlZFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VOb2RlKGxpYnJhcnksIF9ub2RlKSB7XG4gICAgICAgIGxldCBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgbGV0IGF0dHJzID0gKCkgPT4gbnVsbDtcbiAgICAgICAgbGV0IGNvbmRpdGlvbiA9IGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICBsZXQgYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgbGV0IGl0ZXJhdG9yID0gbnVsbDtcbiAgICAgICAgbGV0IHJlc29sdmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHN1Z2FyKF9ub2RlKTtcbiAgICAgICAgaWYgKGlzRE9NKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGFjdHVhbCBIVE1MIERPTSBlbGVtZW50XG4gICAgICAgICAgICBlbGVtZW50ID0gbm9kZS4kZWw7XG4gICAgICAgICAgICBhdHRycyA9XG4gICAgICAgICAgICAgICAgbm9kZS4kZWwgIT09ICd0ZXh0JyA/IHBhcnNlQXR0cnMobm9kZS5hdHRycywgbm9kZS5iaW5kKSA6ICgpID0+IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb21wb25lbnQkMShub2RlKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIFZ1ZSBDb21wb25lbnRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS4kY21wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChoYXMobGlicmFyeSwgbm9kZS4kY21wKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGlicmFyeVtub2RlLiRjbXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5vZGUuJGNtcDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIGl0IG11c3QgYmUgYW4gYWN0dWFsIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBub2RlLiRjbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRycyA9IHBhcnNlQXR0cnMobm9kZS5wcm9wcywgbm9kZS5iaW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NvbmRpdGlvbmFsKG5vZGUpKSB7XG4gICAgICAgICAgICBbY29uZGl0aW9uLCBjaGlsZHJlbiwgYWx0ZXJuYXRlXSA9IHBhcnNlQ29uZGl0aW9uKGxpYnJhcnksIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgYXMgYSBcInYtaWZcIiBzdGF0ZW1lbnQg4oCUIG5vdCBhbiBpZi9lbHNlIHN0YXRlbWVudFxuICAgICAgICBpZiAoIWlzQ29uZGl0aW9uYWwobm9kZSkgJiYgJ2lmJyBpbiBub2RlKSB7XG4gICAgICAgICAgICBjb25kaXRpb24gPSBwcm92aWRlcihjb21waWxlKG5vZGUuaWYpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNDb25kaXRpb25hbChub2RlKSAmJiBlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJbiB0aGlzIG9kZCBjYXNlIG91ciBlbGVtZW50IGlzIGFjdHVhbGx5IGEgcGFydGlhbCBhbmRcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byByZW5kZXIgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgICAgY29uZGl0aW9uID0gKCkgPT4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21waWxlIGNoaWxkcmVuIGRvd24gdG8gYSBmdW5jdGlvblxuICAgICAgICBpZiAoJ2NoaWxkcmVuJyBpbiBub2RlICYmIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5jaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgZGVhbGluZyB3aXRoIGEgcmF3IHN0cmluZyB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLnN0YXJ0c1dpdGgoJyRzbG90cy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgbG9uZSB0ZXh0IG5vZGUsIHR1cm4gaXQgaW50byBhIHNsb3RcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQgPT09ICd0ZXh0JyA/ICdzbG90JyA6IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gcHJvdmlkZXIoY29tcGlsZShub2RlLmNoaWxkcmVuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4uc3RhcnRzV2l0aCgnJCcpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3ZpZGVyKGNvbXBpbGUobm9kZS5jaGlsZHJlbikpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9ICgpID0+IFN0cmluZyh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gKCkgPT4gU3RyaW5nKG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgZGVhbGluZyB3aXRoIG5vZGUgc3ViLWNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBjcmVhdGVFbGVtZW50cyhsaWJyYXJ5LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjb25kaXRpb25hbCBpZi9lbHNlIGNsYXVzZVxuICAgICAgICAgICAgICAgIGNvbnN0IFtjaGlsZENvbmRpdGlvbiwgYywgYV0gPSBwYXJzZUNvbmRpdGlvbihsaWJyYXJ5LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IChpdGVyYXRpb25EYXRhKSA9PiBjaGlsZENvbmRpdGlvbiAmJiBjaGlsZENvbmRpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgID8gYyAmJiBjKGl0ZXJhdGlvbkRhdGEpXG4gICAgICAgICAgICAgICAgICAgIDogYSAmJiBhKGl0ZXJhdGlvbkRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbXBvbmVudCQxKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBDaGlsZHJlbiBvZiBjb21wb25lbnRzIG5lZWQgdG8gYmUgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IG9mIHNsb3RzXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgcHJvdmlkZSBhbiBvYmplY3Qgd2l0aCB0aGUgZGVmYXVsdCBzbG90IHByb3ZpZGVkIGFzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIC8vIFdlIGFsc28gY3JlYXRlIGEgbmV3IHNjb3BlIGZvciB0aGlzIGRlZmF1bHQgc2xvdCwgYW5kIHRoZW4gb24gZWFjaFxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBwYXNzIHRoZSBzY29wZWQgc2xvdCBwcm9wcyB0byB0aGUgc2NvcGUuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZHVjZUNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSAoaXRlcmF0aW9uRGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdChzbG90RGF0YSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc3dpdGNoIHRoZSBjdXJyZW50IGluc3RhbmNlIGtleSBiYWNrIHRvIHRoZSBvbmUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsbHkgY2FsbGVkIHRoaXMgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRLZXkgPSBpbnN0YW5jZUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUtleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xvdERhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGluc3RhbmNlU2NvcGVzLmdldChpbnN0YW5jZUtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bnNoaWZ0KHNsb3REYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gaW5zdGFuY2VTY29wZXMuZ2V0KGluc3RhbmNlS2V5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVuc2hpZnQoaXRlcmF0aW9uRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IHByb2R1Y2VDaGlsZHJlbihpdGVyYXRpb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgb3VyIGluc3RhbmNlIGtleSBuZXZlciBjaGFuZ2VkIGR1cmluZyBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3REYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSBpbnN0YW5jZVNjb3Blcy5nZXQoaW5zdGFuY2VLZXkpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9kID0gaW5zdGFuY2VTY29wZXMuZ2V0KGluc3RhbmNlS2V5KSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VLZXkgPSBjdXJyZW50S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNsb3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9udCBoYXZlIGFueSBjaGlsZHJlbiwgd2Ugc3RpbGwgbmVlZCB0byBwcm92aWRlIGFuIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgYW4gZW1wdHkgYXJyYXkgKHdoaWNoIHJhaXNlcyBhIHdhcm5pbmcgaW4gdnVlKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gKCkgPT4gKHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21waWxlIHRoZSBmb3IgbG9vcCBkb3duXG4gICAgICAgIGlmICgnZm9yJyBpbiBub2RlICYmIG5vZGUuZm9yKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBub2RlLmZvci5sZW5ndGggPT09IDMgPyBub2RlLmZvclsyXSA6IG5vZGUuZm9yWzFdO1xuICAgICAgICAgICAgY29uc3QgZ2V0VmFsdWVzID0gdHlwZW9mIHZhbHVlcyA9PT0gJ3N0cmluZycgJiYgdmFsdWVzLnN0YXJ0c1dpdGgoJyQnKVxuICAgICAgICAgICAgICAgID8gcHJvdmlkZXIoY29tcGlsZSh2YWx1ZXMpKVxuICAgICAgICAgICAgICAgIDogKCkgPT4gdmFsdWVzO1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBbXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWVzLFxuICAgICAgICAgICAgICAgIG5vZGUuZm9yWzBdLFxuICAgICAgICAgICAgICAgIG5vZGUuZm9yLmxlbmd0aCA9PT0gMyA/IFN0cmluZyhub2RlLmZvclsxXSkgOiBudWxsLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2NvbmRpdGlvbiwgZWxlbWVudCwgYXR0cnMsIGNoaWxkcmVuLCBhbHRlcm5hdGUsIGl0ZXJhdG9yLCByZXNvbHZlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgY2hpbGRyZW4sIGVuc3VyZSB0aGF0IHRoZSBzZWNvbmRcbiAgICAgKiBhcmd1bWVudCBvZiBhbGwgdGhlc2Ugc2xvdHMgaXMgdGhlIG9yaWdpbmFsIGluc3RhbmNlIGtleSBiZWluZyB1c2VkIHRvXG4gICAgICogcmVuZGVyIHRoZSBzbG90cy5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gLSBUaGUgY2hpbGRyZW4oKSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvZHVjZSBzbG90c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNsb3RzKGNoaWxkcmVuLCBpdGVyYXRpb25EYXRhKSB7XG4gICAgICAgIGNvbnN0IHNsb3RzID0gY2hpbGRyZW4oaXRlcmF0aW9uRGF0YSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRLZXkgPSBpbnN0YW5jZUtleTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHNsb3RzKS5yZWR1Y2UoKGFsbFNsb3RzLCBzbG90TmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2xvdEZuID0gc2xvdHMgJiYgc2xvdHNbc2xvdE5hbWVdO1xuICAgICAgICAgICAgYWxsU2xvdHNbc2xvdE5hbWVdID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNsb3RGbiAmJiBzbG90Rm4oZGF0YSwgY3VycmVudEtleSkpIHx8IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFsbFNsb3RzO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZWxlbWVudFxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGNvbnRleHQgZGF0YSBhdmFpbGFibGUgdG8gdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBzY2hlbWEgbm9kZSB0byByZW5kZXJcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobGlicmFyeSwgbm9kZSkge1xuICAgICAgICAvLyBQYXJzZXMgdGhlIHNjaGVtYSBub2RlIGludG8gcGVydGluZW50IHBhcnRzXG4gICAgICAgIGNvbnN0IFtjb25kaXRpb24sIGVsZW1lbnQsIGF0dHJzLCBjaGlsZHJlbiwgYWx0ZXJuYXRlLCBpdGVyYXRvciwgcmVzb2x2ZV0gPSBwYXJzZU5vZGUobGlicmFyeSwgbm9kZSk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzdWItcmVuZGVyIGZ1bmN0aW9uIChjYWxsZWQgd2l0aGluIGEgcmVuZGVyIGZ1bmN0aW9uKS4gSXQgbXVzdFxuICAgICAgICAvLyBvbmx5IHVzZSBwcmUtY29tcGlsZWQgZmVhdHVyZXMsIGFuZCBiZSBvcmdhbml6ZWQgaW4gdGhlIG1vc3QgZWZmaWNpZW50XG4gICAgICAgIC8vIG1hbm5lciBwb3NzaWJsZS5cbiAgICAgICAgbGV0IGNyZWF0ZU5vZGVzID0gKChpdGVyYXRpb25EYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uICYmIGVsZW1lbnQgPT09IG51bGwgJiYgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY29uZGl0aW9uYWwgaWYvdGhlbiBzdGF0ZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgID8gY2hpbGRyZW4oaXRlcmF0aW9uRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgOiBhbHRlcm5hdGUgJiYgYWx0ZXJuYXRlKGl0ZXJhdGlvbkRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgKCFjb25kaXRpb24gfHwgY29uZGl0aW9uKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRleHQgbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gJ3RleHQnICYmIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVUZXh0Vk5vZGUoU3RyaW5nKGNoaWxkcmVuKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGxvbmUgc2xvdHNcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gJ3Nsb3QnICYmIGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4oaXRlcmF0aW9uRGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHJlc29sdmluZyBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSByZXNvbHZlID8gcmVzb2x2ZUNvbXBvbmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHJlbmRlcmluZyBzbG90cyBhcyBjaGlsZHJlbiwgZW5zdXJlIHRoZWlyIGluc3RhbmNlS2V5IGlzIHByb3Blcmx5IGFkZGVkXG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdHMgPSAoY2hpbGRyZW4gPT09IG51bGwgfHwgY2hpbGRyZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkcmVuLnNsb3QpXG4gICAgICAgICAgICAgICAgICAgID8gY3JlYXRlU2xvdHMoY2hpbGRyZW4sIGl0ZXJhdGlvbkRhdGEpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZG9tIGVsZW1lbnRzIGFuZCBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGgoZWwsIGF0dHJzKCksIChzbG90cyB8fCAoY2hpbGRyZW4gPyBjaGlsZHJlbihpdGVyYXRpb25EYXRhKSA6IFtdKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhbHRlcm5hdGUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGFsdGVybmF0ZShpdGVyYXRpb25EYXRhKVxuICAgICAgICAgICAgICAgIDogYWx0ZXJuYXRlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCByZXBlYXRlZE5vZGUgPSBjcmVhdGVOb2RlcztcbiAgICAgICAgICAgIGNvbnN0IFtnZXRWYWx1ZXMsIHZhbHVlTmFtZSwga2V5TmFtZV0gPSBpdGVyYXRvcjtcbiAgICAgICAgICAgIGNyZWF0ZU5vZGVzID0gKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfdiA9IGdldFZhbHVlcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9ICFpc05hTihfdilcbiAgICAgICAgICAgICAgICAgICAgPyBBcnJheShOdW1iZXIoX3YpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbGwoMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKF8sIGkpID0+IGkpXG4gICAgICAgICAgICAgICAgICAgIDogX3Y7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlcyAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlU2NvcGUgPSBpbnN0YW5jZVNjb3Blcy5nZXQoaW5zdGFuY2VLZXkpIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVyYXRpb25EYXRhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmluc3RhbmNlU2NvcGUucmVkdWNlKChwcmV2aW91c0l0ZXJhdGlvbkRhdGEsIHNjb3BlZERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNJdGVyYXRpb25EYXRhLl9faWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucHJldmlvdXNJdGVyYXRpb25EYXRhLCAuLi5zY29wZWREYXRhIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZWREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlTmFtZV06IHZhbHVlc1trZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGtleU5hbWUgIT09IG51bGwgPyB7IFtrZXlOYW1lXToga2V5IH0gOiB7fSksXG4gICAgICAgICAgICAgICAgICAgIH0sICdfX2lkYXRhJywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlU2NvcGUudW5zaGlmdChpdGVyYXRpb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQucHVzaChyZXBlYXRlZE5vZGUuYmluZChudWxsLCBpdGVyYXRpb25EYXRhKSgpKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VTY29wZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlTm9kZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc2NoZW1hLCBwYXJzZSBpdCBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgcmVuZGVyYWJsZSBub2Rlcy5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBzY2hlbWEgY29udGV4dCBvYmplY3RcbiAgICAgKiBAcGFyYW0gbGlicmFyeSAtIFRoZSBhdmFpbGFibGUgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzKGxpYnJhcnksIHNjaGVtYSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBjb25zdCBlbHMgPSBzY2hlbWEubWFwKGNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCBsaWJyYXJ5KSk7XG4gICAgICAgICAgICByZXR1cm4gKGl0ZXJhdGlvbkRhdGEpID0+IGVscy5tYXAoKGVsZW1lbnQpID0+IGVsZW1lbnQoaXRlcmF0aW9uRGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmdsZSBub2RlIHRvIHJlbmRlclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gY3JlYXRlRWxlbWVudChsaWJyYXJ5LCBzY2hlbWEpO1xuICAgICAgICByZXR1cm4gKGl0ZXJhdGlvbkRhdGEpID0+IGVsZW1lbnQoaXRlcmF0aW9uRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGEgcHJvdmlkZXJzIHByb2R1Y2VkIGFzIGEgcmVzdWx0IG9mIHRoZSBjb21waWxlci5cbiAgICAgKi9cbiAgICBjb25zdCBwcm92aWRlcnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBBcHBlbmQgdGhlIHJlcXVpc2l0ZSBjb21waWxlciBwcm92aWRlciBhbmQgcmV0dXJuIHRoZSBjb21waWxlZCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gY29tcGlsZWQgLSBBIGNvbXBpbGVkIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm92aWRlcihjb21waWxlZCwgaGludHMgPSB7fSkge1xuICAgICAgICBjb25zdCBjb21waWxlZEZucyA9IHt9O1xuICAgICAgICBwcm92aWRlcnMucHVzaCgoY2FsbGJhY2ssIGtleSkgPT4ge1xuICAgICAgICAgICAgY29tcGlsZWRGbnNba2V5XSA9IGNvbXBpbGVkLnByb3ZpZGUoKHRva2VucykgPT4gY2FsbGJhY2sodG9rZW5zLCBoaW50cykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNvbXBpbGVkRm5zW2luc3RhbmNlS2V5XSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgZ2l2ZW4gc2NoZW1hIOKAlCB0aGlzIGVpdGhlciBjb21lcyBmcm9tIGFcbiAgICAgKiBtZW1vaXplZCBjb3B5IG9mIHRoZSBwYXJzZWQgc2NoZW1hIG9yIGEgZnJlc2hseSBwYXJzZWQgdmVyc2lvbi4gQW4gc3ltYm9sXG4gICAgICogaW5zdGFuY2Uga2V5LCBhbmQgZGF0YVByb3ZpZGVyIGZ1bmN0aW9ucyBhcmUgcGFzc2VkIGluLlxuICAgICAqIEBwYXJhbSBwcm92aWRlckNhbGxiYWNrIC0gQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZWFjaCByZXF1aXJlZCBwcm92aWRlclxuICAgICAqIEBwYXJhbSBrZXkgLSBhIHN5bWJvbCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UocHJvdmlkZXJDYWxsYmFjaywga2V5KSB7XG4gICAgICAgIGNvbnN0IG1lbW9LZXkgPSBKU09OLnN0cmluZ2lmeShzY2hlbWEpO1xuICAgICAgICBjb25zdCBbcmVuZGVyLCBjb21waWxlZFByb3ZpZGVyc10gPSBoYXMobWVtbywgbWVtb0tleSlcbiAgICAgICAgICAgID8gbWVtb1ttZW1vS2V5XVxuICAgICAgICAgICAgOiBbY3JlYXRlRWxlbWVudHMobGlicmFyeSwgc2NoZW1hKSwgcHJvdmlkZXJzXTtcbiAgICAgICAgbWVtb1ttZW1vS2V5XSA9IFtyZW5kZXIsIGNvbXBpbGVkUHJvdmlkZXJzXTtcbiAgICAgICAgY29tcGlsZWRQcm92aWRlcnMuZm9yRWFjaCgoY29tcGlsZWRQcm92aWRlcikgPT4ge1xuICAgICAgICAgICAgY29tcGlsZWRQcm92aWRlcihwcm92aWRlckNhbGxiYWNrLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlS2V5ID0ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcigpO1xuICAgICAgICB9O1xuICAgIH07XG59XG4vKipcbiAqIENoZWNrcyB0aGUgY3VycmVudCBydW50aW1lIHNjb3BlIGZvciBkYXRhLlxuICogQHBhcmFtIHRva2VuIC0gVGhlIHRva2VuIHRvIGxvb2t1cCBpbiB0aGUgY3VycmVudCBzY29wZVxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHJlZiB2YWx1ZSB0byB1c2UgaWYgbm8gc2NvcGUgaXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHVzZVNjb3BlKHRva2VuLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCBzY29wZWREYXRhID0gaW5zdGFuY2VTY29wZXMuZ2V0KGluc3RhbmNlS2V5KSB8fCBbXTtcbiAgICBsZXQgc2NvcGVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHNjb3BlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgIHNjb3BlZFZhbHVlID0gZ2V0VmFsdWUoc2NvcGVkRGF0YSwgdG9rZW4uc3BsaXQoJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRWYWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogc2NvcGVkVmFsdWU7XG59XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzY29wZWQgZGF0YSBhbmQgZmxhdHRlbiBpdC5cbiAqL1xuZnVuY3Rpb24gc2xvdERhdGEoZGF0YSwga2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eShkYXRhLCB7XG4gICAgICAgIGdldCguLi5hcmdzKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldktleSA9IGluc3RhbmNlS2V5O1xuICAgICAgICAgICAgICAgIGluc3RhbmNlS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1c2VTY29wZShwcm9wZXJ0eSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUtleSA9IHByZXZLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YSAhPT0gdW5kZWZpbmVkID8gZGF0YSA6IFJlZmxlY3QuZ2V0KC4uLmFyZ3MpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGEgcGFyc2VkIHNjaGVtYS5cbiAqIEBwYXJhbSBwcm92aWRlciAtIFRoZSBTY2hlbWFQcm92aWRlciAob3V0cHV0IG9mIGNhbGxpbmcgcGFyc2VTY2hlbWEpXG4gKiBAcGFyYW0gZGF0YSAtIERhdGEgdG8gZmV0Y2ggdmFsdWVzIGZyb21cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlckZuKGluc3RhbmNlQ3JlYXRvciwgZGF0YSwgaW5zdGFuY2VLZXkpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VDcmVhdG9yKChyZXF1aXJlbWVudHMsIGhpbnRzID0ge30pID0+IHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmVtZW50cy5yZWR1Y2UoKHRva2VucywgdG9rZW4pID0+IHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5zdGFydHNXaXRoKCdzbG90cy4nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3QgPSB0b2tlbi5zdWJzdHJpbmcoNik7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzU2xvdCA9IGRhdGEuc2xvdHMgJiYgaGFzKGRhdGEuc2xvdHMsIHNsb3QpO1xuICAgICAgICAgICAgICAgIGlmIChoaW50cy5pZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGF0ZW1lbnQg4oCUIGRvbnQgcmVuZGVyIHRoZSBzbG90LCBjaGVjayBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3Rva2VuXSA9ICgpID0+IGhhc1Nsb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuc2xvdHMgJiYgaGFzU2xvdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHNsb3Qgd2l0aCBjdXJyZW50IHNjb3BlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVkRGF0YSA9IHNsb3REYXRhKGRhdGEsIGluc3RhbmNlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3Rva2VuXSA9ICgpID0+IGRhdGEuc2xvdHNbc2xvdF0oc2NvcGVkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRSZWYodG9rZW4sIGRhdGEpO1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXSA9ICgpID0+IHVzZVNjb3BlKHRva2VuLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9LCB7fSk7XG4gICAgfSwgaW5zdGFuY2VLZXkpO1xufVxubGV0IGkgPSAwO1xuLyoqXG4gKiBUaGUgRm9ybUtpdFNjaGVtYSB2dWUgY29tcG9uZW50OlxuICogQHB1YmxpY1xuICovXG5jb25zdCBGb3JtS2l0U2NoZW1hID0gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBuYW1lOiAnRm9ybUtpdFNjaGVtYScsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBbQXJyYXksIE9iamVjdF0sXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgZGVmYXVsdDogKCkgPT4gKHt9KSxcbiAgICAgICAgfSxcbiAgICAgICAgbGlicmFyeToge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgZGVmYXVsdDogKCkgPT4gKHt9KSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIGxldCBpbnN0YW5jZUtleSA9IFN5bWJvbChTdHJpbmcoaSsrKSk7XG4gICAgICAgIGluc3RhbmNlU2NvcGVzLnNldChpbnN0YW5jZUtleSwgW10pO1xuICAgICAgICBsZXQgcHJvdmlkZXIgPSBwYXJzZVNjaGVtYShwcm9wcy5saWJyYXJ5LCBwcm9wcy5zY2hlbWEpO1xuICAgICAgICBsZXQgcmVuZGVyO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgLy8gUmUtcGFyc2UgdGhlIHNjaGVtYSBpZiBpdCBjaGFuZ2VzOlxuICAgICAgICB3YXRjaCgoKSA9PiBwcm9wcy5zY2hlbWEsIChuZXdTY2hlbWEsIG9sZFNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaW5zdGFuY2VLZXkgPSBTeW1ib2woU3RyaW5nKGkrKykpO1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBwYXJzZVNjaGVtYShwcm9wcy5saWJyYXJ5LCBwcm9wcy5zY2hlbWEpO1xuICAgICAgICAgICAgcmVuZGVyID0gY3JlYXRlUmVuZGVyRm4ocHJvdmlkZXIsIGRhdGEsIGluc3RhbmNlS2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdTY2hlbWEgPT09IG9sZFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICgoX2EgPSBpbnN0YW5jZSA9PT0gbnVsbCB8fCBpbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFuY2UucHJveHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS4kZm9yY2VVcGRhdGUpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgZGVlcDogdHJ1ZSB9KTtcbiAgICAgICAgLy8gV2F0Y2ggdGhlIGRhdGEgb2JqZWN0IGV4cGxpY2l0bHlcbiAgICAgICAgd2F0Y2hFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgZGF0YSA9IE9iamVjdC5hc3NpZ24ocmVhY3RpdmUocHJvcHMuZGF0YSksIHtcbiAgICAgICAgICAgICAgICBzbG90czogY29udGV4dC5zbG90cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVuZGVyID0gY3JlYXRlUmVuZGVyRm4ocHJvdmlkZXIsIGRhdGEsIGluc3RhbmNlS2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiByZW5kZXIoKTtcbiAgICB9LFxufSk7XG5cbi8qKlxuICogQWxsIHRoZSBleHBsaWNpdCBGb3JtS2l0IHByb3BzLlxuICovXG5jb25zdCBuYXRpdmVQcm9wcyA9IHtcbiAgICBjb25maWc6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0OiB7fSxcbiAgICB9LFxuICAgIGNsYXNzZXM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgfSxcbiAgICBkZWxheToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICB9LFxuICAgIGVycm9yczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgZGVmYXVsdDogW10sXG4gICAgfSxcbiAgICBpbnB1dEVycm9yczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQ6ICgpID0+ICh7fSksXG4gICAgfSxcbiAgICBpbmRleDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICB9LFxuICAgIGlkOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgIH0sXG4gICAgbW9kZWxWYWx1ZToge1xuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgIH0sXG4gICAgcGFyZW50OiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgIH0sXG4gICAgcGx1Z2luczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgZGVmYXVsdDogW10sXG4gICAgfSxcbiAgICBzZWN0aW9uc1NjaGVtYToge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQ6IHt9LFxuICAgIH0sXG4gICAgdHlwZToge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgICAgICBkZWZhdWx0OiAndGV4dCcsXG4gICAgfSxcbiAgICB2YWxpZGF0aW9uOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgIH0sXG4gICAgdmFsaWRhdGlvbk1lc3NhZ2VzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgIH0sXG4gICAgdmFsaWRhdGlvblJ1bGVzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgIH0sXG4gICAgdmFsaWRhdGlvbkxhYmVsOiB7XG4gICAgICAgIHR5cGU6IFtTdHJpbmcsIEZ1bmN0aW9uXSxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgIH0sXG59O1xuLyoqXG4gKiBUaGUgRm9ybUtpdCBwcm9wcyBvYmplY3QuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgcHJvcHMgPSBuYXRpdmVQcm9wcztcblxuLyoqXG4gKiBUaGUgc3ltYm9sIHRoYXQgcmVwcmVzZW50cyB0aGUgZm9ybWtpdCBwYXJlbnQgaW5qZWN0aW9uIHZhbHVlLlxuICogQHB1YmxpY1xuICovXG5jb25zdCBwYXJlbnRTeW1ib2wgPSBTeW1ib2woJ0Zvcm1LaXRQYXJlbnQnKTtcbi8qKlxuICogVGhlIHJvb3QgRm9ybUtpdCBjb21wb25lbnQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IEZvcm1LaXQgPSBkZWZpbmVDb21wb25lbnQoe1xuICAgIHByb3BzLFxuICAgIGVtaXRzOiB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuICAgICAgICBpbnB1dDogKF92YWx1ZSwgX25vZGUpID0+IHRydWUsXG4gICAgICAgIGlucHV0UmF3OiAoX3ZhbHVlLCBfbm9kZSkgPT4gdHJ1ZSxcbiAgICAgICAgJ3VwZGF0ZTptb2RlbFZhbHVlJzogKF92YWx1ZSkgPT4gdHJ1ZSxcbiAgICAgICAgbm9kZTogKG5vZGUpID0+ICEhbm9kZSxcbiAgICAgICAgc3VibWl0OiAoX2RhdGEsIF9ub2RlKSA9PiB0cnVlLFxuICAgICAgICBzdWJtaXRSYXc6IChfZXZlbnQsIF9ub2RlKSA9PiB0cnVlLFxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuICAgIH0sXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBzZXR1cChwcm9wcywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlID0gdXNlSW5wdXQocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIW5vZGUucHJvcHMuZGVmaW5pdGlvbilcbiAgICAgICAgICAgIGVycm9yKDYwMCwgbm9kZSk7XG4gICAgICAgIGlmIChub2RlLnByb3BzLmRlZmluaXRpb24uY29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaCgoX2EgPSBub2RlLnByb3BzLmRlZmluaXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbm9kZS5jb250ZXh0LFxuICAgICAgICAgICAgICAgIH0sIHsgLi4uY29udGV4dC5zbG90cyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NoZW1hID0gcmVmKFtdKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVTY2hlbWEgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hRGVmaW5pdGlvbiA9IChfYiA9IChfYSA9IG5vZGUucHJvcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZpbml0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2NoZW1hO1xuICAgICAgICAgICAgaWYgKCFzY2hlbWFEZWZpbml0aW9uKVxuICAgICAgICAgICAgICAgIGVycm9yKDYwMSwgbm9kZSk7XG4gICAgICAgICAgICBzY2hlbWEudmFsdWUgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBzY2hlbWFEZWZpbml0aW9uID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gc2NoZW1hRGVmaW5pdGlvbih7IC4uLnByb3BzLnNlY3Rpb25zU2NoZW1hIH0pXG4gICAgICAgICAgICAgICAgICAgIDogc2NoZW1hRGVmaW5pdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgZ2VuZXJhdGVTY2hlbWEoKTtcbiAgICAgICAgLy8gSWYgc29tZW9uZSBlbWl0cyB0aGUgc2NoZW1hIGV2ZW50LCB3ZSByZS1nZW5lcmF0ZSB0aGUgc2NoZW1hXG4gICAgICAgIG5vZGUub24oJ3NjaGVtYScsIGdlbmVyYXRlU2NoZW1hKTtcbiAgICAgICAgY29udGV4dC5lbWl0KCdub2RlJywgbm9kZSk7XG4gICAgICAgIGNvbnN0IGxpYnJhcnkgPSBub2RlLnByb3BzLmRlZmluaXRpb24ubGlicmFyeTtcbiAgICAgICAgLy8gRXhwb3NlIHRoZSBGb3JtS2l0Tm9kZSB0byB0ZW1wbGF0ZSByZWZzLlxuICAgICAgICBjb250ZXh0LmV4cG9zZSh7IG5vZGUgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBoKEZvcm1LaXRTY2hlbWEsIHsgc2NoZW1hOiBzY2hlbWEudmFsdWUsIGRhdGE6IG5vZGUuY29udGV4dCwgbGlicmFyeSB9LCB7IC4uLmNvbnRleHQuc2xvdHMgfSk7XG4gICAgfSxcbn0pO1xuXG4vKipcbiAqIFRoZSBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEZvcm1LaXQgcGx1Z2luIGZvciBWdWUuXG4gKiBAcGFyYW0gYXBwIC0gQSBWdWUgYXBwbGljYXRpb25cbiAqIEBwYXJhbSBjb25maWcgLSBGb3JtS2l0IFZ1ZSBwbHVnaW4gY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBsdWdpbihhcHAsIG9wdGlvbnMpIHtcbiAgICBhcHBcbiAgICAgICAgLmNvbXBvbmVudChvcHRpb25zLmFsaWFzIHx8ICdGb3JtS2l0JywgRm9ybUtpdClcbiAgICAgICAgLmNvbXBvbmVudChvcHRpb25zLnNjaGVtYUFsaWFzIHx8ICdGb3JtS2l0U2NoZW1hJywgRm9ybUtpdFNjaGVtYSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBnZXROb2RlLFxuICAgICAgICBzZXRMb2NhbGU6IChsb2NhbGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICgoX2EgPSBvcHRpb25zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb3RDb25maWcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbmZpZy5yb290Q29uZmlnLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJFcnJvcnMsXG4gICAgICAgIHNldEVycm9ycyxcbiAgICAgICAgc3VibWl0OiBzdWJtaXRGb3JtLFxuICAgICAgICByZXNldCxcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUgc3ltYm9sIGtleSBmb3IgYWNjZXNzaW5nIHRoZSBGb3JtS2l0IG5vZGUgb3B0aW9ucy5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3Qgb3B0aW9uc1N5bWJvbCA9IFN5bWJvbC5mb3IoJ0Zvcm1LaXRPcHRpb25zJyk7XG4vKipcbiAqIFRoZSBzeW1ib2wga2V5IGZvciBhY2Nlc3NpbmcgRm9ybUtpdCByb290IGNvbmZpZ3VyYXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGNvbmZpZ1N5bWJvbCA9IFN5bWJvbC5mb3IoJ0Zvcm1LaXRDb25maWcnKTtcbi8qKlxuICogQ3JlYXRlIHRoZSBGb3JtS2l0IHBsdWdpbi5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgcGx1Z2luID0ge1xuICAgIGluc3RhbGwoYXBwLCBfb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogRXh0ZW5kIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGFsaWFzOiAnRm9ybUtpdCcsXG4gICAgICAgICAgICBzY2hlbWFBbGlhczogJ0Zvcm1LaXRTY2hlbWEnLFxuICAgICAgICB9LCB0eXBlb2YgX29wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBfb3B0aW9ucygpIDogX29wdGlvbnMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJvb3QgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgcm9vdENvbmZpZyA9IGNyZWF0ZUNvbmZpZyhvcHRpb25zLmNvbmZpZyB8fCB7fSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBkb250IHdhbnQgdG8gZXhwbGljaXRseSBwcm92aWRlIGFueSBcImNvbmZpZ1wiIG9wdGlvbnMsIG9ubHkgYSByb290XG4gICAgICAgICAqIGNvbmZpZyBvcHRpb24g4oCUIHNvIGhlcmUgd2Ugb3ZlcnJpZGUgdGhlIGV4aXN0aW5nIGNvbmZpZyBvcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgb3B0aW9ucy5jb25maWcgPSB7IHJvb3RDb25maWcgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnbG9iYWwgJGZvcm1raXQgcGx1Z2luIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLiRmb3Jta2l0ID0gY3JlYXRlUGx1Z2luKGFwcCwgb3B0aW9ucyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm92aWRlIHRoZSBjb25maWcgdG8gdGhlIGFwcGxpY2F0aW9uIGZvciBpbmplY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBhcHAucHJvdmlkZShvcHRpb25zU3ltYm9sLCBvcHRpb25zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGUgdGhlIHJvb3QgY29uZmlnIHRvIHRoZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGFwcC5wcm92aWRlKGNvbmZpZ1N5bWJvbCwgcm9vdENvbmZpZyk7XG4gICAgfSxcbn07XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgdGhlIHBhdGggdGhhdCB3YXMgcmVxdWVzdGVkIGlzIG5vIGxvbmdlciB2YWxpZCBpbiB0aGUgb2JqZWN0LlxuICovXG5jb25zdCBpbnZhbGlkR2V0ID0gU3ltYm9sKCk7XG4vKipcbiAqXG4gKiBAcGFyYW0gb2JqIC0gQW4gb2JqZWN0IHRvIG9ic2VydmUgYXQgZGVwdGhcbiAqIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdGhhdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB3YXRjaFZlcmJvc2Uob2JqLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHdhdGNoZXJzID0ge307XG4gICAgY29uc3QgYXBwbHlXYXRjaCA9IChwYXRocykgPT4ge1xuICAgICAgICAvLyBXYXRjaCBlYWNoIHByb3BlcnR5XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgLy8gU3RvcHMgcHJlLWV4aXN0aW5nIHdhdGNoZXJzIGF0IGEgZ2l2ZW4gbG9jYXRpb24gdG8gcHJldmVudCBkdXBlczpcbiAgICAgICAgICAgIGlmIChwYXRoLl9fc3RyIGluIHdhdGNoZXJzKVxuICAgICAgICAgICAgICAgIHdhdGNoZXJzW3BhdGguX19zdHJdKCk7XG4gICAgICAgICAgICB3YXRjaGVyc1twYXRoLl9fc3RyXSA9IHdhdGNoKHRvdWNoLmJpbmQobnVsbCwgb2JqLCBwYXRoKSwgZGlzcGF0Y2hlci5iaW5kKG51bGwsIHBhdGgpLCB7IGRlZXA6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciBhbnkgd2F0Y2hlcnMgZGVlcGVyIHRoYW4gdGhpcyBwYXRoLlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gc3RhcnQgZnJvbVxuICAgICAqL1xuICAgIGNvbnN0IGNsZWFyV2F0Y2ggPSAocGF0aCkgPT4ge1xuICAgICAgICBpZiAoIXBhdGgubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaGVycykge1xuICAgICAgICAgICAgaWYgKGAke2tleX1gLnN0YXJ0c1dpdGgoYCR7cGF0aC5fX3N0cn0uYCkpIHtcbiAgICAgICAgICAgICAgICB3YXRjaGVyc1trZXldKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdhdGNoZXJzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSBjcmVhdGVEaXNwYXRjaGVyKG9iaiwgY2FsbGJhY2ssIGFwcGx5V2F0Y2gsIGNsZWFyV2F0Y2gpO1xuICAgIGFwcGx5V2F0Y2goZ2V0UGF0aHMob2JqKSk7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc3luY2hyb25vdXNseSBkaXNwYXRjaGVzIHRvIHRoZSB3YXRjaCBjYWxsYmFja3MuIEl0IHVzZXMgdGhlXG4gKiBrbm93bGVkZ2UgdGhhdCB0aGUgZ2V0UGF0aCBmdW5jdGlvbiBpcyBhIGRlcHRoLWZpcnN0LXNlYXJjaCB0aHVzIGxvd2VyXG4gKiBzcGVjaWZpY2l0eSAobG93ZXIgdHJlZSBub2Rlcykgd2lsbCBhbHdheXMgaGF2ZSB0aGVpciB3YXRjaGVycyBjYWxsZWQgZmlyc3QuXG4gKiBJZiBhIGxvd2VyIHNwZWNpZmljaXR5IHdhdGNoZXIgaXMgdHJpZ2dlcmVkIHdlIHdhbnQgdG8gaWdub3JlIHRoZSBoaWdoZXJcbiAqIHNwZWNpZmljaXR5IHdhdGNoZXIuXG4gKiBAcGFyYW0gb2JqIC0gVGhlIG9iamVjdCB0byBkaXNwYXRjaFxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGVtaXRcbiAqIEBwYXJhbSBhcHBseVdhdGNoIC0gQSB3YXkgdG8gYXBwbHkgd2F0Y2hlcnMgdG8gdXBkYXRlIG9iamVjdHNcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoZXIob2JqLCBjYWxsYmFjaywgYXBwbHlXYXRjaCwgY2xlYXJDaGlsZFdhdGNoZXMpIHtcbiAgICAvLyBsZXQgZGlzcGF0Y2hlZFBhdGhzOiBSZWNvcmQ8c3RyaW5nLCBPYmplY3RQYXRoPiA9IHt9XG4gICAgLy8gbGV0IGNsZWFyOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGxcbiAgICByZXR1cm4gKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQob2JqLCBwYXRoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBpbnZhbGlkR2V0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocGF0aC5fX2RlZXApXG4gICAgICAgICAgICBjbGVhckNoaWxkV2F0Y2hlcyhwYXRoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICBhcHBseVdhdGNoKGdldFBhdGhzKHZhbHVlLCBbcGF0aF0sIC4uLnBhdGgpKTtcbiAgICAgICAgY2FsbGJhY2socGF0aCwgdmFsdWUsIG9iaik7XG4gICAgfTtcbn1cbi8qKlxuICogXCJUb3VjaGVzXCIgYSBnaXZlbiBwcm9wZXJ0eSBmb3IgcmVhY3Rpdml0eSB0cmFja2luZyBwdXJwb3NlcywgaWYgdGhlIHZhbHVlIGF0XG4gKiB0aGUgZ2l2ZW4gcGF0aCBpcyBhbiBvYmplY3QsIHdlIGZsYXR0ZW4gaXQgdG8ganVzdCBpdHMga2V5cyBzaW5jZSB3ZSB3aWxsXG4gKiBhbHJlYWR5IGJlIHRyYWNraW5nIHN1YiBwcm9wZXJ0aWVzIGluZGVwZW5kZW50bHkuXG4gKiBAcGFyYW0gb2JqIC0gQSByZWYgdG8gdHJhdmVyc2UgZm9yIGEgZ2l2ZW4gcGF0aFxuICogQHBhcmFtIHBhdGggLSBBbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgcGF0aCB0byBsb2NhdGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHRvdWNoKG9iaiwgcGF0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0KG9iaiwgcGF0aCk7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBPYmplY3Qua2V5cyh2YWx1ZSkgOiB2YWx1ZTtcbn1cbi8qKlxuICogXCJUb3VjaGVzXCIgYSBnaXZlbiBwcm9wZXJ0eSBmb3IgcmVhY3Rpdml0eSB0cmFja2luZyBwdXJwb3Nlcy5cbiAqIEBwYXJhbSBvYmogLSBBIHJlZiB0byB0cmF2ZXJzZSBmb3IgYSBnaXZlbiBwYXRoXG4gKiBAcGFyYW0gcGF0aCAtIEFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBwYXRoIHRvIGxvY2F0ZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICAgIGlmIChpc1JlZihvYmopKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBvYmoudmFsdWU7XG4gICAgICAgIG9iaiA9IG9iai52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgucmVkdWNlKCh2YWx1ZSwgc2VnbWVudCkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IGludmFsaWRHZXQpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW52YWxpZEdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVbc2VnbWVudF07XG4gICAgfSwgb2JqKTtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgcmV0cmlldmVzIGFsbCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIGZyb20gdGhlIG9yaWdpbmF0aW9uXG4gKiBvYmplY3QuIEZvciBleGFtcGxlOlxuICogYGBganNcbiAqIGNvbnN0IG9iaiA9IHtcbiAqICAgYToge1xuICogICAgIGI6IDEyM1xuICogICB9LFxuICogICBjOiA1NjdcbiAqIH1cbiAqIGNvbnN0IHBhdGhzID0gZ2V0UGF0aHMob2JqKVxuICogLy8gW1xuICogLy8gICBbJ2EnXSxcbiAqIC8vICAgWydhJywgJ2InXSxcbiAqIC8vICAgWydjJ11cbiAqIC8vIF1cbiAqIGBgYFxuICogQHBhcmFtIG9iaiAtIEFuIG9iamVjdCB0byByZXRyaWV2ZSBwYXRocyBmb3IuXG4gKiBAcGFyYW0gcGFyZW50cyAtIEFuIGFycmF5IG9mIHBhcmVudCBwYXRocy5cbiAqIEByZXR1cm5zXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0UGF0aHMob2JqLCBwYXRocyA9IFtdLCAuLi5wYXJlbnRzKSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIGlmICghcGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShbXSwgJ19fc3RyJywge1xuICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICB9KTtcbiAgICAgICAgb2JqID0gaXNSZWYob2JqKSA/IG9iai52YWx1ZSA6IG9iajtcbiAgICAgICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhdGgsICdfX2RlZXAnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcGF0aF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBjb25zdCBwYXRoID0gcGFyZW50cy5jb25jYXQoa2V5KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhdGgsICdfX3N0cicsIHsgdmFsdWU6IHBhdGguam9pbignLicpIH0pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAoaXNQb2pvKHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcGF0aHMucHVzaChPYmplY3QuZGVmaW5lUHJvcGVydHkocGF0aCwgJ19fZGVlcCcsIHsgdmFsdWU6IHRydWUgfSkpO1xuICAgICAgICAgICAgcGF0aHMgPSBwYXRocy5jb25jYXQoZ2V0UGF0aHModmFsdWUsIFtdLCAuLi5wYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRocztcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSByYXcgdW5kZXJseWluZyB0YXJnZXQgb2JqZWN0IGZyb20gYSBWdWUgUmVmIG9yIFJlYWN0aXZlIG9iamVjdC5cbiAqIEBwYXJhbSBvYmogLSBHZXQgdGhlIHVuZGVybHlpbmcgdGFyZ2V0IG9iamVjdCwgb3Igbm8tb3AuXG4gKiBAcmV0dXJuc1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gdXNlUmF3KG9iaikge1xuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICBvYmogPSB0b1JhdyhvYmopO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlZihvYmopKSB7XG4gICAgICAgIG9iaiA9IChpc1JlYWN0aXZlKG9iai52YWx1ZSkgPyB1c2VSYXcob2JqLnZhbHVlKSA6IG9iai52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUHJvcHMgdGhhdCBhcmUgZXh0cmFjdGVkIGZyb20gdGhlIGF0dHJzIG9iamVjdC5cbiAqIFRPRE86IEN1cnJlbnRseSBsb2NhbCwgdGhpcyBzaG91bGQgcHJvYmFibHkgZXhwb3J0ZWQgdG8gYSBpbnB1dHMgb3IgYW5vdGhlclxuICogcGFja2FnZS5cbiAqL1xuY29uc3QgcHNldWRvUHJvcHMgPSBbXG4gICAgJ2hlbHAnLFxuICAgICdsYWJlbCcsXG4gICAgJ2lnbm9yZScsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAncHJlc2VydmUnLFxuICAgIC9ecHJlc2VydmUoLWV8RSlycm9ycy8sXG4gICAgL15bYS16XSsoPzotdmlzaWJpbGl0eXxWaXNpYmlsaXR5KSQvLFxuICAgIC9eW2EtekEtWi1dKyg/Oi1jbGFzc3xDbGFzcykkLyxcbl07XG4vKipcbiAqIEdpdmVuIHNvbWUgcHJvcHMsIG1hcCB0aG9zZSBwcm9wcyB0byBpbmRpdmlkdWFsaXplZCBwcm9wcyBpbnRlcm5hbGx5LlxuICogQHBhcmFtIG5vZGUgLSBBIGZvcm1raXQgbm9kZVxuICogQHBhcmFtIHByb3BzIC0gU29tZSBwcm9wcyB0aGF0IG1heSBpbmNsdWRlIGEgY2xhc3NlcyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY2xhc3Nlc1RvTm9kZVByb3BzKG5vZGUsIHByb3BzKSB7XG4gICAgaWYgKHByb3BzLmNsYXNzZXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcHMuY2xhc3NlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BzW2BfJHtrZXl9Q2xhc3NgXSA9IHByb3BzLmNsYXNzZXNba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGVuc3VyZSBWdWUgaXMgYXdhcmUgdGhhdCB3ZSB3YW50IHRvIGFjdHVhbGx5IG9ic2VydmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgdmFsdWVzIHRvbywgc28gd2UgdG91Y2ggdGhlbSBoZXJlLlxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwcm9wcy5jbGFzc2VzW2tleV0pICYmIGtleSA9PT0gJ2lubmVyJylcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhwcm9wcy5jbGFzc2VzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIGtub3duIEZvcm1LaXQgbGlzdGVuZXJzLlxuICogQHBhcmFtIHByb3BzIC0gRXh0cmFjdCBrbm93biBGb3JtS2l0IGxpc3RlbmVycy5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIG9ubHlMaXN0ZW5lcnMocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3Qga25vd25MaXN0ZW5lcnMgPSBbJ1N1Ym1pdCcsICdTdWJtaXRSYXcnXS5yZWR1Y2UoKGxpc3RlbmVycywgbGlzdGVuZXIpID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGBvbiR7bGlzdGVuZXJ9YDtcbiAgICAgICAgaWYgKG5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcHNbbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4ga25vd25MaXN0ZW5lcnM7XG59XG4vKipcbiAqIEEgY29tcG9zYWJsZSBmb3IgY3JlYXRpbmcgYSBuZXcgRm9ybUtpdCBub2RlLlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiBub2RlIChpbnB1dCwgZ3JvdXAsIGxpc3QpXG4gKiBAcGFyYW0gYXR0cnMgLSBUaGUgRm9ybUtpdCBcInByb3BzXCIg4oCUIHdoaWNoIGlzIHJlYWxseSB0aGUgYXR0cnMgbGlzdC5cbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZUlucHV0KHByb3BzLCBjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zLCB0aGVzZSBhcmUgcHJvdmlkZWQgYnkgZWl0aGVyIHRoZSBwbHVnaW4gb3IgYnlcbiAgICAgKiBleHBsaWNpdCBwcm9wcy5cbiAgICAgKi9cbiAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBpbmplY3Qob3B0aW9uc1N5bWJvbCkgfHwge30sIG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBvbmx5TGlzdGVuZXJzKGluc3RhbmNlID09PSBudWxsIHx8IGluc3RhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnN0YW5jZS52bm9kZS5wcm9wcyk7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgcHJvcCBpcyB2LW1vZGVsZWQuXG4gICAgICovXG4gICAgY29uc3QgaXNWTW9kZWxlZCA9IHByb3BzLm1vZGVsVmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBvYmplY3QgYmVpbmcgcGFzc2VkIGFzIGEgdi1tb2RlbCBpcyByZWFjdGl2ZS5cbiAgICAgKi9cbiAgICAvLyBjb25zdCBpc1JlYWN0aXZlVk1vZGVsID0gaXNWTW9kZWxlZCAmJiBpc1JlYWN0aXZlKHByb3BzLm1vZGVsVmFsdWUpXG4gICAgLyoqXG4gICAgICogRGVmaW5lIHRoZSBpbml0aWFsIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHMubW9kZWxWYWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcHJvcHMubW9kZWxWYWx1ZVxuICAgICAgICA6IGNsb25lQW55KGNvbnRleHQuYXR0cnMudmFsdWUpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG5vZGUncyBpbml0aWFsIHByb3BzIGZyb20gdGhlIGNvbnRleHQsIHByb3BzLCBhbmQgZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFByb3BzKCkge1xuICAgICAgICBjb25zdCBpbml0aWFsUHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5ub2RlUHJvcHMocHJvcHMpLFxuICAgICAgICAgICAgLi4ubGlzdGVuZXJzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhdHRycyA9IGV4Y2VwdChub2RlUHJvcHMoY29udGV4dC5hdHRycyksIHBzZXVkb1Byb3BzKTtcbiAgICAgICAgaW5pdGlhbFByb3BzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIGNvbnN0IHByb3BWYWx1ZXMgPSBvbmx5KG5vZGVQcm9wcyhjb250ZXh0LmF0dHJzKSwgcHNldWRvUHJvcHMpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIHByb3BWYWx1ZXMpIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wc1tjYW1lbChwcm9wTmFtZSldID0gcHJvcFZhbHVlc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xhc3Nlc1Byb3BzID0geyBwcm9wczoge30gfTtcbiAgICAgICAgY2xhc3Nlc1RvTm9kZVByb3BzKGNsYXNzZXNQcm9wcywgcHJvcHMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGluaXRpYWxQcm9wcywgY2xhc3Nlc1Byb3BzLnByb3BzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsUHJvcHMudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGluaXRpYWxQcm9wcy5kZWZpbml0aW9uID0gaW5pdGlhbFByb3BzLnR5cGU7XG4gICAgICAgICAgICBkZWxldGUgaW5pdGlhbFByb3BzLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluaXRpYWxQcm9wcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBGb3JtS2l0Tm9kZS5cbiAgICAgKi9cbiAgICBjb25zdCBpbml0aWFsUHJvcHMgPSBjcmVhdGVJbml0aWFsUHJvcHMoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IG5vZGUuXG4gICAgICovXG4gICAgY29uc3QgcGFyZW50ID0gaW5pdGlhbFByb3BzLmlnbm9yZVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBwcm9wcy5wYXJlbnQgfHwgaW5qZWN0KHBhcmVudFN5bWJvbCwgbnVsbCk7XG4gICAgY29uc3Qgbm9kZSA9IGNyZWF0ZU5vZGUoZXh0ZW5kKGNvbmZpZyB8fCB7fSwge1xuICAgICAgICBuYW1lOiBwcm9wcy5uYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcGx1Z2luczogKGNvbmZpZy5wbHVnaW5zIHx8IFtdKS5jb25jYXQocHJvcHMucGx1Z2lucyksXG4gICAgICAgIGNvbmZpZzogcHJvcHMuY29uZmlnLFxuICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICBpbmRleDogcHJvcHMuaW5kZXgsXG4gICAgfSwgZmFsc2UsIHRydWUpKTtcbiAgICAvKipcbiAgICAgKiBJZiBubyBkZWZpbml0aW9uIGhhcyBiZWVuIGFzc2lnbmVkIGF0IHRoaXMgcG9pbnQg4oCUIHdlJ3JlIG91dCFcbiAgICAgKi9cbiAgICBpZiAoIW5vZGUucHJvcHMuZGVmaW5pdGlvbilcbiAgICAgICAgZXJyb3IoNjAwLCBub2RlKTtcbiAgICAvKipcbiAgICAgKiBBbGwgcHJvcHMgdGhhdCBhcmUgYm91bmQgXCJsYXRlXCIgKGFmdGVyIG5vZGUgY3JlYXRpb24pIOKAlCBhcmUgYWRkZWQgdG8gYSBzZXRcbiAgICAgKiB3aGljaCBpcyB1c2VkIHRvIHdhdGNoIHRoZSBjb250ZXh0LmF0dHJzIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdCBsYXRlQm91bmRQcm9wcyA9IHJlZihuZXcgU2V0KG5vZGUucHJvcHMuZGVmaW5pdGlvbi5wcm9wcyB8fCBbXSkpO1xuICAgIC8qKlxuICAgICAqIEFueSBhZGRpdGlvbmFsIHByb3BzIGFkZGVkIGF0IGEgXCJsYXRlclwiIHRpbWUgc2hvdWxkIGFsc28gYmUgcGFydCBvZiB0aGVcbiAgICAgKiBsYXRlIGJvdW5kIHByb3BzLlxuICAgICAqL1xuICAgIG5vZGUub24oJ2FkZGVkLXByb3BzJywgKHsgcGF5bG9hZDogbGF0ZVByb3BzIH0pID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZVByb3BzKSlcbiAgICAgICAgICAgIGxhdGVQcm9wcy5mb3JFYWNoKChuZXdQcm9wKSA9PiBsYXRlQm91bmRQcm9wcy52YWx1ZS5hZGQobmV3UHJvcCkpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZXNlIHByb3AgbmFtZXMgbXVzdCBiZSBhc3NpZ25lZC5cbiAgICAgKi9cbiAgICBjb25zdCBwc2V1ZG9Qcm9wTmFtZXMgPSBjb21wdXRlZCgoKSA9PiBwc2V1ZG9Qcm9wcy5jb25jYXQoWy4uLmxhdGVCb3VuZFByb3BzLnZhbHVlXSkucmVkdWNlKChuYW1lcywgcHJvcCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKGNhbWVsKHByb3ApKTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goa2ViYWIocHJvcCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmFtZXMucHVzaChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfSwgW10pKTtcbiAgICAvKiBTcGxpdHMgQ2xhc3NlcyBvYmplY3QgaW50byBkaXNjcmV0ZSBwcm9wcyBmb3IgZWFjaCBrZXkgKi9cbiAgICB3YXRjaEVmZmVjdCgoKSA9PiBjbGFzc2VzVG9Ob2RlUHJvcHMobm9kZSwgcHJvcHMpKTtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJvcHMgb2JqZWN0IGFscmVhZHkgaGFzIHByb3BlcnRpZXMgZXZlbiBpZiB0aGV5IHN0YXJ0IGFzIFwidW5kZWZpbmVkXCJcbiAgICAgKiBzbyB3ZSBjYW4gbG9vcCBvdmVyIHRoZW0gYW5kIGluZGl2aWR1YWwgd2F0Y2hFZmZlY3QgdG8gcHJldmVudCByZXNwb25kaW5nXG4gICAgICogaW5hcHByb3ByaWF0ZWx5LlxuICAgICAqL1xuICAgIGNvbnN0IHBhc3NUaHJvdWdoID0gbm9kZVByb3BzKHByb3BzKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFzc1Rocm91Z2gpIHtcbiAgICAgICAgd2F0Y2goKCkgPT4gcHJvcHNbcHJvcF0sICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9wc1twcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wc1twcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2F0Y2ggXCJwc2V1ZG9Qcm9wXCIgYXR0cmlidXRlcyBleHBsaWNpdGx5LlxuICAgICAqL1xuICAgIGNvbnN0IGF0dHJpYnV0ZVdhdGNoZXJzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHBvc3NpYmxlUHJvcHMgPSBub2RlUHJvcHMoY29udGV4dC5hdHRycyk7XG4gICAgd2F0Y2hFZmZlY3QoKCkgPT4ge1xuICAgICAgICB3YXRjaEF0dHJpYnV0ZXMob25seShwb3NzaWJsZVByb3BzLCBwc2V1ZG9Qcm9wTmFtZXMudmFsdWUpKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBwcm9wcy5cbiAgICAgKiBAcGFyYW0gYXR0clByb3BzIC0gQXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIHByb3BzIGluc3RlYWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3YXRjaEF0dHJpYnV0ZXMoYXR0clByb3BzKSB7XG4gICAgICAgIGF0dHJpYnV0ZVdhdGNoZXJzLmZvckVhY2goKHN0b3ApID0+IHtcbiAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZVdhdGNoZXJzLmRlbGV0ZShzdG9wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBhdHRyUHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVsTmFtZSA9IGNhbWVsKHByb3ApO1xuICAgICAgICAgICAgYXR0cmlidXRlV2F0Y2hlcnMuYWRkKHdhdGNoKCgpID0+IGNvbnRleHQuYXR0cnNbcHJvcF0sICgpID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BzW2NhbWVsTmFtZV0gPSBjb250ZXh0LmF0dHJzW3Byb3BdO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhdGNoIGFuZCBkeW5hbWljYWxseSBzZXQgYXR0cmlidXRlIHZhbHVlcywgdGhvc2UgdmFsdWVzIHRoYXQgYXJlIG5vdFxuICAgICAqIHByb3BzIGFuZCBhcmUgbm90IHBzZXVkb1Byb3BzXG4gICAgICovXG4gICAgd2F0Y2hFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBhdHRycyA9IGV4Y2VwdChub2RlUHJvcHMoY29udGV4dC5hdHRycyksIHBzZXVkb1Byb3BOYW1lcy52YWx1ZSk7XG4gICAgICAgIG5vZGUucHJvcHMuYXR0cnMgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLnByb3BzLmF0dHJzIHx8IHt9LCBhdHRycyk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWRkIGFueS9hbGwgXCJwcm9wXCIgZXJyb3JzIHRvIHRoZSBzdG9yZS5cbiAgICAgKi9cbiAgICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gcHJvcHMuZXJyb3JzLm1hcCgoZXJyb3IpID0+IGNyZWF0ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAga2V5OiBzbHVnaWZ5KGVycm9yKSxcbiAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICB2YWx1ZTogZXJyb3IsXG4gICAgICAgICAgICBtZXRhOiB7IHNvdXJjZTogJ3Byb3AnIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgbm9kZS5zdG9yZS5hcHBseShtZXNzYWdlcywgKG1lc3NhZ2UpID0+IG1lc3NhZ2UudHlwZSA9PT0gJ2Vycm9yJyAmJiBtZXNzYWdlLm1ldGEuc291cmNlID09PSAncHJvcCcpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFkZCBpbnB1dCBlcnJvcnMuXG4gICAgICovXG4gICAgaWYgKG5vZGUudHlwZSAhPT0gJ2lucHV0Jykge1xuICAgICAgICBjb25zdCBzb3VyY2VLZXkgPSBgJHtub2RlLm5hbWV9LXByb3BgO1xuICAgICAgICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMuaW5wdXRFcnJvcnMpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBrZXlzLnJlZHVjZSgobWVzc2FnZXMsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3BzLmlucHV0RXJyb3JzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNba2V5XSA9IHZhbHVlLm1hcCgoZXJyb3IpID0+IGNyZWF0ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7IHNvdXJjZTogc291cmNlS2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgbm9kZS5zdG9yZS5hcHBseShtZXNzYWdlcywgKG1lc3NhZ2UpID0+IG1lc3NhZ2UudHlwZSA9PT0gJ2Vycm9yJyAmJiBtZXNzYWdlLm1ldGEuc291cmNlID09PSBzb3VyY2VLZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2F0Y2ggdGhlIGNvbmZpZyBwcm9wIGZvciBhbnkgY2hhbmdlcy5cbiAgICAgKi9cbiAgICB3YXRjaEVmZmVjdCgoKSA9PiBPYmplY3QuYXNzaWduKG5vZGUuY29uZmlnLCBwcm9wcy5jb25maWcpKTtcbiAgICAvKipcbiAgICAgKiBQcm9kdWNlIGFub3RoZXIgcGFyZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBpZiAobm9kZS50eXBlICE9PSAnaW5wdXQnKSB7XG4gICAgICAgIHByb3ZpZGUocGFyZW50U3ltYm9sLCBub2RlKTtcbiAgICB9XG4gICAgbGV0IGlucHV0VGltZW91dDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGNvbnN0IG11dGV4ID0gbmV3IFdlYWtTZXQoKTtcbiAgICAvKipcbiAgICAgKiBFeHBsaWNpdGx5IHdhdGNoIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIGVtaXQgY2hhbmdlcyAobGF6eSlcbiAgICAgKi9cbiAgICBub2RlLm9uKCdtb2RlbFVwZGF0ZWQnLCAoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIEVtaXQgdGhlIHZhbHVlcyBhZnRlciBjb21taXRcbiAgICAgICAgY29udGV4dC5lbWl0KCdpbnB1dFJhdycsIChfYSA9IG5vZGUuY29udGV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlLCBub2RlKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlucHV0VGltZW91dCk7XG4gICAgICAgIGlucHV0VGltZW91dCA9IHNldFRpbWVvdXQoY29udGV4dC5lbWl0LCAyMCwgJ2lucHV0JywgKF9iID0gbm9kZS5jb250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmFsdWUsIG5vZGUpO1xuICAgICAgICBpZiAoaXNWTW9kZWxlZCAmJiBub2RlLmNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdXNlUmF3KG5vZGUuY29udGV4dC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QobmV3VmFsdWUpICYmIHVzZVJhdyhwcm9wcy5tb2RlbFZhbHVlKSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBiZWVuIG11dGF0ZWQgaW5zaWRlIEZvcm1LaXQgY29yZSB0aGVuXG4gICAgICAgICAgICAgICAgLy8gd2Uga25vdyB3aGVuIGl0IGlzIGVtaXR0ZWQgaXQgd2lsbCBcInJldHVyblwiIGluIHRoZSB3YXRjaFZlcmJvc2Ugc29cbiAgICAgICAgICAgICAgICAvLyB3ZSBwcm8tYWN0aXZlbHkgYWRkIGl0IHRvIHRoZSBtdXRleC5cbiAgICAgICAgICAgICAgICBtdXRleC5hZGQobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5lbWl0KCd1cGRhdGU6bW9kZWxWYWx1ZScsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZWQgc3VwcG9ydCBmb3Igdi1tb2RlbCwgdXNpbmcgdGhpcyBmb3IgZ3JvdXBzL2xpc3RzIGlzIG5vdCByZWNvbW1lbmRlZFxuICAgICAqL1xuICAgIGlmIChpc1ZNb2RlbGVkKSB7XG4gICAgICAgIHdhdGNoVmVyYm9zZSh0b1JlZihwcm9wcywgJ21vZGVsVmFsdWUnKSwgKHBhdGgsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCByYXdWYWx1ZSA9IHVzZVJhdyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QocmF3VmFsdWUpICYmIG11dGV4LmhhcyhyYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXV0ZXguZGVsZXRlKHJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbm9kZS5pbnB1dCh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChfYSA9IG5vZGUuYXQocGF0aCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnB1dCh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGlzIGlucHV0IHNodXRzIGRvd24sIHdlIG5lZWQgdG8gXCJkZWxldGVcIiB0aGUgbm9kZSB0b28uXG4gICAgICovXG4gICAgb25Vbm1vdW50ZWQoKCkgPT4gbm9kZS5kZXN0cm95KCkpO1xuICAgIHJldHVybiBub2RlO1xufVxuXG5sZXQgdG90YWxDcmVhdGVkID0gMTtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSB2dWUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSBvYmogLSBPYmplY3Qgb3IgZnVuY3Rpb25cbiAqIEByZXR1cm5zXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzQ29tcG9uZW50KG9iaikge1xuICAgIHJldHVybiAoKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicgJiYgb2JqLmxlbmd0aCA9PT0gMikgfHxcbiAgICAgICAgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShvYmopICYmXG4gICAgICAgICAgICAhKCckZWwnIGluIG9iaikgJiZcbiAgICAgICAgICAgICEoJyRjbXAnIGluIG9iaikgJiZcbiAgICAgICAgICAgICEoJ2lmJyBpbiBvYmopKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5wdXQgZnJvbSBzY2hlbWEgb3IgYSBWdWUgY29tcG9uZW50IHdpdGggdGhlIFwic3RhbmRhcmRcIlxuICogRm9ybUtpdCBmZWF0dXJlcyBpbiBwbGFjZSBzdWNoIGFzIGxhYmVscywgaGVscCB0ZXh0LCB2YWxpZGF0aW9uIG1lc3NhZ2VzLCBhbmRcbiAqIGNsYXNzIHN1cHBvcnQuXG4gKlxuICogQHBhcmFtIHNjaGVtYU9yQ29tcG9uZW50IC0gVGhlIGFjdHVhbCBzY2hlbWEgb2YgdGhlIGlucHV0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dChzY2hlbWFPckNvbXBvbmVudCwgZGVmaW5pdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgIC4uLmRlZmluaXRpb25PcHRpb25zLFxuICAgIH07XG4gICAgbGV0IHNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNDb21wb25lbnQoc2NoZW1hT3JDb21wb25lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNtcE5hbWUgPSBgU2NoZW1hQ29tcG9uZW50JHt0b3RhbENyZWF0ZWQrK31gO1xuICAgICAgICBzY2hlbWEgPSAoKSA9PiAoe1xuICAgICAgICAgICAgJGNtcDogY21wTmFtZSxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgY29udGV4dDogJyRub2RlLmNvbnRleHQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluaXRpb24ubGlicmFyeSA9IHsgW2NtcE5hbWVdOiBtYXJrUmF3KHNjaGVtYU9yQ29tcG9uZW50KSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hT3JDb21wb25lbnQ7XG4gICAgfVxuICAgIC8vIFVzZSB0aGUgZGVmYXVsdCB3cmFwcGluZyBzY2hlbWFcbiAgICBkZWZpbml0aW9uLnNjaGVtYSA9IHVzZVNjaGVtYShzY2hlbWEgfHwgJ1NjaGVtYSB1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cblxuLyoqXG4gKiBBIHBsdWdpbiB0aGF0IGNyZWF0ZXMgVnVlLXNwZWNpZmljIGNvbnRleHQgb2JqZWN0IG9uIGVhY2ggZ2l2ZW4gbm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gRm9ybUtpdE5vZGUgdG8gY3JlYXRlIHRoZSBjb250ZXh0IG9uLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB2dWVCaW5kaW5ncyA9IGZ1bmN0aW9uIHZ1ZUJpbmRpbmdzKG5vZGUpIHtcbiAgICAvKipcbiAgICAgKiBTdGFydCBhIHZhbGlkaXR5IGNvdW50ZXIgb24gYWxsIGJsb2NraW5nIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIG5vZGUubGVkZ2VyLmNvdW50KCdibG9ja2luZycsIChtKSA9PiBtLmJsb2NraW5nKTtcbiAgICBjb25zdCBpc1ZhbGlkID0gcmVmKCFub2RlLmxlZGdlci52YWx1ZSgnYmxvY2tpbmcnKSk7XG4gICAgLyoqXG4gICAgICogU3RhcnQgYW4gZXJyb3IgbWVzc2FnZSBjb3VudGVyLlxuICAgICAqL1xuICAgIG5vZGUubGVkZ2VyLmNvdW50KCdlcnJvcnMnLCAobSkgPT4gbS50eXBlID09PSAnZXJyb3InKTtcbiAgICBjb25zdCBoYXNFcnJvcnMgPSByZWYoISFub2RlLmxlZGdlci52YWx1ZSgnZXJyb3JzJykpO1xuICAgIC8qKlxuICAgICAqIEtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IHRpbWUgYSBWdWUgdGljayBjeWNsZSBoYXMgcGFzc2VkLlxuICAgICAqL1xuICAgIGxldCBoYXNUaWNrZWQgPSBmYWxzZTtcbiAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGhhc1RpY2tlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWxsIG1lc3NhZ2VzIHdpdGggdGhlIHZpc2liaWxpdHkgc3RhdGUgc2V0IHRvIHRydWUuXG4gICAgICovXG4gICAgY29uc3QgYXZhaWxhYmxlTWVzc2FnZXMgPSByZWFjdGl2ZShub2RlLnN0b3JlLnJlZHVjZSgoc3RvcmUsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudmlzaWJsZSkge1xuICAgICAgICAgICAgc3RvcmVbbWVzc2FnZS5rZXldID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgfSwge30pKTtcbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBkZXRlcm1pbmVzIHdoZW4gdmFsaWRhdGlvbiBtZXNzYWdlcyBzaG91bGQgYmUgZGlzcGxheWVkLlxuICAgICAqL1xuICAgIGNvbnN0IHZhbGlkYXRpb25WaXNpYmlsaXR5ID0gcmVmKG5vZGUucHJvcHMudmFsaWRhdGlvblZpc2liaWxpdHkgfHwgJ2JsdXInKTtcbiAgICBub2RlLm9uKCdwcm9wOnZhbGlkYXRpb25WaXNpYmlsaXR5JywgKHsgcGF5bG9hZCB9KSA9PiB7XG4gICAgICAgIHZhbGlkYXRpb25WaXNpYmlsaXR5LnZhbHVlID0gcGF5bG9hZDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBLZWVwIHRyYWNrIG9mIGlmIHRoaXMgaW5wdXQgaGFzIGV2ZXIgc2hvd24gdmFsaWRhdGlvbiBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3QgaGFzU2hvd25FcnJvcnMgPSByZWYodmFsaWRhdGlvblZpc2liaWxpdHkudmFsdWUgPT09ICdsaXZlJyk7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgdmlzaWJpbGl0eSBzdGF0ZSBvZiB2YWxpZGF0aW9uIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIGNvbnN0IHZhbGlkYXRpb25WaXNpYmxlID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICBpZiAoY29udGV4dC5zdGF0ZS5zdWJtaXR0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCFoYXNTaG93bkVycm9ycy52YWx1ZSAmJiAhY29udGV4dC5zdGF0ZS5zZXR0bGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWxpZGF0aW9uVmlzaWJpbGl0eS52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnbGl2ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5zdGF0ZS5ibHVycmVkO1xuICAgICAgICAgICAgY2FzZSAnZGlydHknOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnN0YXRlLmRpcnR5O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBzaG91bGQgYmUgY29uc2lkZXJlZCBcImNvbXBsZXRlXCIuXG4gICAgICovXG4gICAgY29uc3QgaXNDb21wbGV0ZSA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGhhc1ZhbGlkYXRpb24udmFsdWVcbiAgICAgICAgICAgID8gaXNWYWxpZC52YWx1ZSAmJiAhaGFzRXJyb3JzLnZhbHVlXG4gICAgICAgICAgICA6IGNvbnRleHQuc3RhdGUuZGlydHkgJiYgIWVtcHR5KGNvbnRleHQudmFsdWUpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBpbnB1dCBoYXMgdmFsaWRhdGlvbiBydWxlcyBvciBub3QuXG4gICAgICovXG4gICAgY29uc3QgaGFzVmFsaWRhdGlvbiA9IHJlZihBcnJheS5pc0FycmF5KG5vZGUucHJvcHMucGFyc2VkUnVsZXMpICYmIG5vZGUucHJvcHMucGFyc2VkUnVsZXMubGVuZ3RoID4gMCk7XG4gICAgbm9kZS5vbigncHJvcDpwYXJzZWRSdWxlcycsICh7IHBheWxvYWQ6IHJ1bGVzIH0pID0+IHtcbiAgICAgICAgaGFzVmFsaWRhdGlvbi52YWx1ZSA9IEFycmF5LmlzQXJyYXkocnVsZXMpICYmIHJ1bGVzLmxlbmd0aCA+IDA7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWxsIG1lc3NhZ2VzIHRoYXQgYXJlIGN1cnJlbnRseSBvbiBkaXNwbGF5IHRvIGFuIGVuZCB1c2VyLiBUaGlzIGNoYW5nZXNcbiAgICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBtZXNzYWdlIHR5cGUgdmlzaWJpbGl0eSwgbGlrZSBlcnJvclZpc2liaWxpdHkuXG4gICAgICovXG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpc2libGVNZXNzYWdlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdmFpbGFibGVNZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF2YWlsYWJsZU1lc3NhZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSAndmFsaWRhdGlvbicgfHwgdmFsaWRhdGlvblZpc2libGUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlTWVzc2FnZXNba2V5XSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpc2libGVNZXNzYWdlcztcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBVSSBNZXNzYWdlcy5cbiAgICAgKi9cbiAgICBjb25zdCB1aSA9IHJlYWN0aXZlKG5vZGUuc3RvcmUucmVkdWNlKChtZXNzYWdlcywgbWVzc2FnZSkgPT4ge1xuICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSAndWknICYmIG1lc3NhZ2UudmlzaWJsZSlcbiAgICAgICAgICAgIG1lc3NhZ2VzW21lc3NhZ2Uua2V5XSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9LCB7fSkpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHJlYWN0aXZlIGRhdGEgb2JqZWN0IHRoYXQgaXMgcHJvdmlkZWQgdG8gYWxsIHNjaGVtYXMgYW5kXG4gICAgICogZm9ybXMuIEl0IGlzIGEgc3Vic2V0IG9mIGRhdGEgaW4gdGhlIGNvcmUgbm9kZSBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3QgY2FjaGVkQ2xhc3NlcyA9IHJlYWN0aXZlKHt9KTtcbiAgICBjb25zdCBjbGFzc2VzID0gbmV3IFByb3h5KGNhY2hlZENsYXNzZXMsIHtcbiAgICAgICAgZ2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IFt0YXJnZXQsIHByb3BlcnR5XSA9IGFyZ3M7XG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gUmVmbGVjdC5nZXQoLi4uYXJncyk7XG4gICAgICAgICAgICBpZiAoIWNsYXNzTmFtZSAmJiB0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXModGFyZ2V0LCBwcm9wZXJ0eSkgJiYgIXByb3BlcnR5LnN0YXJ0c1dpdGgoJ19fdicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ic2VydmVkTm9kZSA9IGNyZWF0ZU9ic2VydmVyKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlZE5vZGUud2F0Y2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RDbGFzc2VzID0gdHlwZW9mIG5vZGUuY29uZmlnLnJvb3RDbGFzc2VzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBub2RlLmNvbmZpZy5yb290Q2xhc3Nlcyhwcm9wZXJ0eSwgbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsQ29uZmlnQ2xhc3NlcyA9IG5vZGUuY29uZmlnLmNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUNsYXNzZXMocHJvcGVydHksIG5vZGUsIG5vZGUuY29uZmlnLmNsYXNzZXNbcHJvcGVydHldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGFzc2VzUHJvcENsYXNzZXMgPSBjcmVhdGVDbGFzc2VzKHByb3BlcnR5LCBub2RlLCBub2RlLnByb3BzW2BfJHtwcm9wZXJ0eX1DbGFzc2BdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25Qcm9wQ2xhc3NlcyA9IGNyZWF0ZUNsYXNzZXMocHJvcGVydHksIG5vZGUsIG5vZGUucHJvcHNbYCR7cHJvcGVydHl9Q2xhc3NgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTGlzdChub2RlLCBwcm9wZXJ0eSwgcm9vdENsYXNzZXMsIGdsb2JhbENvbmZpZ0NsYXNzZXMsIGNsYXNzZXNQcm9wQ2xhc3Nlcywgc2VjdGlvblByb3BDbGFzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBjbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgZGVzY3JpYmVkQnkgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlc2NyaWJlcnMgPSBbXTtcbiAgICAgICAgaWYgKGNvbnRleHQuaGVscCkge1xuICAgICAgICAgICAgZGVzY3JpYmVycy5wdXNoKGBoZWxwLSR7bm9kZS5wcm9wcy5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXNzYWdlcy52YWx1ZSkge1xuICAgICAgICAgICAgZGVzY3JpYmVycy5wdXNoKGAke25vZGUucHJvcHMuaWR9LSR7a2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmliZXJzLmxlbmd0aCA/IGRlc2NyaWJlcnMuam9pbignICcpIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGNvbnN0IHZhbHVlID0gcmVmKG5vZGUudmFsdWUpO1xuICAgIGNvbnN0IF92YWx1ZSA9IHJlZihub2RlLnZhbHVlKTtcbiAgICBjb25zdCBjb250ZXh0ID0gcmVhY3RpdmUoe1xuICAgICAgICBfdmFsdWUsXG4gICAgICAgIGF0dHJzOiBub2RlLnByb3BzLmF0dHJzLFxuICAgICAgICBkaXNhYmxlZDogbm9kZS5wcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgZGVzY3JpYmVkQnksXG4gICAgICAgIGZuczoge1xuICAgICAgICAgICAgbGVuZ3RoOiAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCxcbiAgICAgICAgICAgIG51bWJlcjogKHZhbHVlKSA9PiBOdW1iZXIodmFsdWUpLFxuICAgICAgICAgICAgc3RyaW5nOiAodmFsdWUpID0+IFN0cmluZyh2YWx1ZSksXG4gICAgICAgICAgICBqc29uOiAodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSxcbiAgICAgICAgICAgIGVxLFxuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVyczoge1xuICAgICAgICAgICAgYmx1cjogKCkgPT4gbm9kZS5zdG9yZS5zZXQoY3JlYXRlTWVzc2FnZSh7IGtleTogJ2JsdXJyZWQnLCB2aXNpYmxlOiBmYWxzZSwgdmFsdWU6IHRydWUgfSkpLFxuICAgICAgICAgICAgdG91Y2g6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLnN0b3JlLnNldChjcmVhdGVNZXNzYWdlKHsga2V5OiAnZGlydHknLCB2aXNpYmxlOiBmYWxzZSwgdmFsdWU6IHRydWUgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIERPTUlucHV0OiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIG5vZGUuZW1pdCgnZG9tLWlucHV0LWV2ZW50JywgZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBoZWxwOiBub2RlLnByb3BzLmhlbHAsXG4gICAgICAgIGlkOiBub2RlLnByb3BzLmlkLFxuICAgICAgICBsYWJlbDogbm9kZS5wcm9wcy5sYWJlbCxcbiAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgIG5vZGU6IG1hcmtSYXcobm9kZSksXG4gICAgICAgIG9wdGlvbnM6IG5vZGUucHJvcHMub3B0aW9ucyxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIGJsdXJyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tcGxldGU6IGlzQ29tcGxldGUsXG4gICAgICAgICAgICBkaXJ0eTogZmFsc2UsXG4gICAgICAgICAgICBzdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc2V0dGxlZDogbm9kZS5pc1NldHRsZWQsXG4gICAgICAgICAgICB2YWxpZDogaXNWYWxpZCxcbiAgICAgICAgICAgIGVycm9yczogaGFzRXJyb3JzLFxuICAgICAgICAgICAgcnVsZXM6IGhhc1ZhbGlkYXRpb24sXG4gICAgICAgICAgICB2YWxpZGF0aW9uVmlzaWJsZSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogbm9kZS5wcm9wcy50eXBlLFxuICAgICAgICB1aSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNsYXNzZXMsXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoZSBjb250ZXh0IG9iamVjdCBpcyBwcm9wZXJseSBjb25maWd1cmVkIGFmdGVyIGJvb3RpbmcgdXAuXG4gICAgICovXG4gICAgbm9kZS5vbignY3JlYXRlZCcsICgpID0+IHtcbiAgICAgICAgaWYgKCFlcShjb250ZXh0LnZhbHVlLCBub2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgX3ZhbHVlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHZhbHVlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHRyaWdnZXJSZWYodmFsdWUpO1xuICAgICAgICAgICAgdHJpZ2dlclJlZihfdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2V0dGxlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBub2RlLm9uKCdzZXR0bGVkJywgKHsgcGF5bG9hZDogaXNTZXR0bGVkIH0pID0+IHtcbiAgICAgICAgY29udGV4dC5zdGF0ZS5zZXR0bGVkID0gaXNTZXR0bGVkO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE9ic2VydmVzIG5vZGUucHJvcHMgcHJvcGVydGllcyBleHBsaWNpdGx5IGFuZCB1cGRhdGVzIHRoZW0gaW4gdGhlIGNvbnRleHRcbiAgICAgKiBvYmplY3QuXG4gICAgICogQHBhcmFtIG9ic2VydmUgLSBQcm9wcyB0byBvYnNlcnZlIGFuZCByZWdpc3RlciBhcyBjb250ZXh0IGRhdGEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JzZXJ2ZVByb3BzKG9ic2VydmUpIHtcbiAgICAgICAgb2JzZXJ2ZS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICBwcm9wID0gY2FtZWwocHJvcCk7XG4gICAgICAgICAgICBpZiAoIWhhcyhjb250ZXh0LCBwcm9wKSAmJiBoYXMobm9kZS5wcm9wcywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0W3Byb3BdID0gbm9kZS5wcm9wc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUub24oYHByb3A6JHtwcm9wfWAsICh7IHBheWxvYWQgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRleHRbcHJvcF0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZSB1c2UgYSBub2RlIG9ic2VydmVyIHRvIGluZGl2aWR1YWxseSBvYnNlcnZlIG5vZGUgcHJvcHMuXG4gICAgICovXG4gICAgY29uc3Qgcm9vdFByb3BzID0gW1xuICAgICAgICAnaGVscCcsXG4gICAgICAgICdsYWJlbCcsXG4gICAgICAgICdkaXNhYmxlZCcsXG4gICAgICAgICdvcHRpb25zJyxcbiAgICAgICAgJ3R5cGUnLFxuICAgICAgICAnYXR0cnMnLFxuICAgICAgICAncHJlc2VydmUnLFxuICAgICAgICAncHJlc2VydmVFcnJvcnMnLFxuICAgICAgICAnaWQnLFxuICAgIF07XG4gICAgb2JzZXJ2ZVByb3BzKHJvb3RQcm9wcyk7XG4gICAgLyoqXG4gICAgICogT25jZSB0aGUgaW5wdXQgaXMgZGVmaW5lZCwgZGVhbCB3aXRoIGl0LlxuICAgICAqIEBwYXJhbSBkZWZpbml0aW9uIC0gVHlwZSBkZWZpbml0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmluZWRBcyhkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmIChkZWZpbml0aW9uLnByb3BzKVxuICAgICAgICAgICAgb2JzZXJ2ZVByb3BzKGRlZmluaXRpb24ucHJvcHMpO1xuICAgIH1cbiAgICBub2RlLnByb3BzLmRlZmluaXRpb24gJiYgZGVmaW5lZEFzKG5vZGUucHJvcHMuZGVmaW5pdGlvbik7XG4gICAgLyoqXG4gICAgICogV2hlbiBuZXcgcHJvcHMgYXJlIGFkZGVkIHRvIHRoZSBjb3JlIG5vZGUgYXMgXCJwcm9wc1wiIChpZSBub3QgYXR0cnMpIHRoZW5cbiAgICAgKiB3ZSBhdXRvbWF0aWNhbGx5IG5lZWQgdG8gc3RhcnQgdHJhY2tpbmcgdGhlbSBoZXJlLlxuICAgICAqL1xuICAgIG5vZGUub24oJ2FkZGVkLXByb3BzJywgKHsgcGF5bG9hZCB9KSA9PiBvYnNlcnZlUHJvcHMocGF5bG9hZCkpO1xuICAgIC8qKlxuICAgICAqIFdhdGNoIGZvciBpbnB1dCBldmVudHMgZnJvbSBjb3JlLlxuICAgICAqL1xuICAgIG5vZGUub24oJ2lucHV0JywgKHsgcGF5bG9hZCB9KSA9PiB7XG4gICAgICAgIF92YWx1ZS52YWx1ZSA9IHBheWxvYWQ7XG4gICAgICAgIHRyaWdnZXJSZWYoX3ZhbHVlKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXYXRjaCBmb3IgaW5wdXQgY29tbWl0cyBmcm9tIGNvcmUuXG4gICAgICovXG4gICAgbm9kZS5vbignY29tbWl0JywgKHsgcGF5bG9hZCB9KSA9PiB7XG4gICAgICAgIHZhbHVlLnZhbHVlID0gX3ZhbHVlLnZhbHVlID0gcGF5bG9hZDtcbiAgICAgICAgdHJpZ2dlclJlZih2YWx1ZSk7XG4gICAgICAgIG5vZGUuZW1pdCgnbW9kZWxVcGRhdGVkJyk7XG4gICAgICAgIC8vIFRoZSBpbnB1dCBpcyBkaXJ0eSBhZnRlciBhIHZhbHVlIGhhcyBiZWVuIGlucHV0IGJ5IGEgdXNlclxuICAgICAgICBpZiAoIWNvbnRleHQuc3RhdGUuZGlydHkgJiYgbm9kZS5pc0NyZWF0ZWQgJiYgaGFzVGlja2VkKVxuICAgICAgICAgICAgY29udGV4dC5oYW5kbGVycy50b3VjaCgpO1xuICAgICAgICBpZiAoaXNDb21wbGV0ZSAmJlxuICAgICAgICAgICAgbm9kZS50eXBlID09PSAnaW5wdXQnICYmXG4gICAgICAgICAgICBoYXNFcnJvcnMudmFsdWUgJiZcbiAgICAgICAgICAgICF1bmRlZmluZShub2RlLnByb3BzLnByZXNlcnZlRXJyb3JzKSkge1xuICAgICAgICAgICAgbm9kZS5zdG9yZS5maWx0ZXIoKG1lc3NhZ2UpID0+IHsgdmFyIF9hOyByZXR1cm4gIShtZXNzYWdlLnR5cGUgPT09ICdlcnJvcicgJiYgKChfYSA9IG1lc3NhZ2UubWV0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9DbGVhcikgPT09IHRydWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgbG9jYWwgc3RhdGUgaW4gcmVzcG9uc2UgdG8gbWVzc2FnZXMuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBBIGZvcm1raXQgbWVzc2FnZVxuICAgICAqL1xuICAgIGNvbnN0IHVwZGF0ZVN0YXRlID0gYXN5bmMgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3VpJyAmJlxuICAgICAgICAgICAgbWVzc2FnZS52aXNpYmxlICYmXG4gICAgICAgICAgICAhbWVzc2FnZS5tZXRhLnNob3dBc01lc3NhZ2UpIHtcbiAgICAgICAgICAgIHVpW21lc3NhZ2Uua2V5XSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZS52aXNpYmxlKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVNZXNzYWdlc1ttZXNzYWdlLmtleV0gPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3N0YXRlJykge1xuICAgICAgICAgICAgLy8gYXdhaXQgbm9kZS5zZXR0bGVkXG4gICAgICAgICAgICBjb250ZXh0LnN0YXRlW21lc3NhZ2Uua2V5XSA9ICEhbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTGlzdGVuIHRvIG1lc3NhZ2UgZXZlbnRzIGFuZCBtb2RpZnkgdGhlIGxvY2FsIG1lc3NhZ2UgZGF0YSB2YWx1ZXMuXG4gICAgICovXG4gICAgbm9kZS5vbignbWVzc2FnZS1hZGRlZCcsIChlKSA9PiB1cGRhdGVTdGF0ZShlLnBheWxvYWQpKTtcbiAgICBub2RlLm9uKCdtZXNzYWdlLXVwZGF0ZWQnLCAoZSkgPT4gdXBkYXRlU3RhdGUoZS5wYXlsb2FkKSk7XG4gICAgbm9kZS5vbignbWVzc2FnZS1yZW1vdmVkJywgKHsgcGF5bG9hZDogbWVzc2FnZSB9KSA9PiB7XG4gICAgICAgIGRlbGV0ZSB1aVttZXNzYWdlLmtleV07XG4gICAgICAgIGRlbGV0ZSBhdmFpbGFibGVNZXNzYWdlc1ttZXNzYWdlLmtleV07XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0LnN0YXRlW21lc3NhZ2Uua2V5XTtcbiAgICB9KTtcbiAgICBub2RlLm9uKCdzZXR0bGVkOmJsb2NraW5nJywgKCkgPT4ge1xuICAgICAgICBpc1ZhbGlkLnZhbHVlID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBub2RlLm9uKCd1bnNldHRsZWQ6YmxvY2tpbmcnLCAoKSA9PiB7XG4gICAgICAgIGlzVmFsaWQudmFsdWUgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBub2RlLm9uKCdzZXR0bGVkOmVycm9ycycsICgpID0+IHtcbiAgICAgICAgaGFzRXJyb3JzLnZhbHVlID0gZmFsc2U7XG4gICAgfSk7XG4gICAgbm9kZS5vbigndW5zZXR0bGVkOmVycm9ycycsICgpID0+IHtcbiAgICAgICAgaGFzRXJyb3JzLnZhbHVlID0gdHJ1ZTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXYXRjaCB0aGUgdmFsaWRhdGlvbiB2aXNpYmxlIHByb3AgYW5kIHNldCB0aGUgaGFzU2hvd25FcnJvcnMgc3RhdGUuXG4gICAgICovXG4gICAgd2F0Y2godmFsaWRhdGlvblZpc2libGUsICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGhhc1Nob3duRXJyb3JzLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG5vZGUuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgLy8gVGhlIGNvbnRleHQgaXMgY29tcGxldGVcbiAgICBub2RlLmVtaXQoJ2NvbnRleHQnLCBub2RlLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY29uZmlndXJhdGlvbiBvcHRpb25zLiBJbmNsdWRlcyBhbGwgdmFsaWRhdGlvbiBydWxlcyxcbiAqIGVuIGkxOG4gbWVzc2FnZXMuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGRlZmF1bHRDb25maWcgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3QgeyBydWxlcyA9IHt9LCBsb2NhbGVzID0ge30sIGlucHV0czogaW5wdXRzJDEgPSB7fSwgbWVzc2FnZXMgPSB7fSwgbG9jYWxlID0gdW5kZWZpbmVkLCAuLi5ub2RlT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGluY2x1ZGVzIHRoZSB2YWxpZGF0aW9uIHBsdWdpbixcbiAgICAgKiB3aXRoIGFsbCBjb3JlLWF2YWlsYWJsZSB2YWxpZGF0aW9uIHJ1bGVzLlxuICAgICAqL1xuICAgIGNvbnN0IHZhbGlkYXRpb24gPSBjcmVhdGVWYWxpZGF0aW9uUGx1Z2luKHtcbiAgICAgICAgLi4uZGVmYXVsdFJ1bGVzLFxuICAgICAgICAuLi4ocnVsZXMgfHwge30pLFxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEluY2x1ZGVzIHRoZSBpMThuIHBsdWdpbiB3aXRoIG9ubHkgdGhlIGVuZ2xpc2ggbGFuZ3VhZ2VcbiAgICAgKiBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBjb25zdCBpMThuID0gY3JlYXRlSTE4blBsdWdpbihleHRlbmQoeyBlbiwgLi4uKGxvY2FsZXMgfHwge30pIH0sIG1lc3NhZ2VzKSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBsaWJyYXJ5IG9mIGlucHV0cyB0aGF0IGFyZSBnZW5lcmFsbHkgYXZhaWxhYmxlLiBUaGlzIGRlZmF1bHRcbiAgICAgKiBjb25maWcgaW1wb3J0cyBhbGwgXCJuYXRpdmVcIiBpbnB1dHMgYnkgZGVmYXVsdCwgYnV0XG4gICAgICovXG4gICAgY29uc3QgbGlicmFyeSA9IGNyZWF0ZUxpYnJhcnlQbHVnaW4oaW5wdXRzLCBpbnB1dHMkMSk7XG4gICAgcmV0dXJuIGV4dGVuZCh7XG4gICAgICAgIHBsdWdpbnM6IFtsaWJyYXJ5LCB2dWVCaW5kaW5ncywgaTE4biwgdmFsaWRhdGlvbl0sXG4gICAgICAgIC4uLighbG9jYWxlID8ge30gOiB7IGNvbmZpZzogeyBsb2NhbGUgfSB9KSxcbiAgICB9LCBub2RlT3B0aW9ucyB8fCB7fSwgdHJ1ZSk7XG59O1xuXG5leHBvcnQgeyBGb3JtS2l0LCBGb3JtS2l0U2NoZW1hLCB2dWVCaW5kaW5ncyBhcyBiaW5kaW5ncywgY29uZmlnU3ltYm9sLCBjcmVhdGVJbnB1dCwgZGVmYXVsdENvbmZpZywgb3B0aW9uc1N5bWJvbCwgcGFyZW50U3ltYm9sLCBwbHVnaW4sIHVzZUlucHV0LCB3YXRjaFZlcmJvc2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formkit/vue/dist/index.mjs\n");

/***/ })

});